<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Legends: Idle Champion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a0a0a;
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        #top-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
        }

        .resource-icon {
            font-size: 24px;
        }

        #stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            min-width: 250px;
        }

        #upgrades-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        h3 {
            color: #4a90e2;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .upgrade-item {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upgrade-item:hover {
            background: rgba(60, 60, 80, 0.9);
            border-color: #4a90e2;
            transform: translateX(-3px);
        }

        .upgrade-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-item.disabled:hover {
            background: rgba(40, 40, 60, 0.8);
            border-color: #555;
            transform: none;
        }

        .upgrade-name {
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 5px;
        }

        .upgrade-desc {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 8px;
        }

        .upgrade-cost {
            font-weight: bold;
            color: #ffd700;
        }

        .upgrade-level {
            float: right;
            color: #4a90e2;
            font-size: 12px;
        }

        .match-status {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            padding: 10px 30px;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .team-health {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .health-indicator {
            flex: 1;
            text-align: center;
            padding: 5px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 4px;
            font-size: 12px;
        }

        .health-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            transition: width 0.3s;
        }

        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            color: #ff4444;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }

        .heal-number {
            color: #44ff44;
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        #upgrades-panel::-webkit-scrollbar {
            width: 8px;
        }

        #upgrades-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #upgrades-panel::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }

        .prestige-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #a78bfa;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .prestige-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(167, 139, 250, 0.6);
        }

        .prestige-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .prestige-button.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .class-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
        }

        .warrior { background: #c79c6e; }
        .mage { background: #69ccf0; }
        .priest { background: #ffffff; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <!-- Top Resource Bar -->
        <div id="top-bar" class="ui-panel">
            <div class="resource">
                <span class="resource-icon">üí∞</span>
                <span id="gold-amount">0</span>
            </div>
            <div class="resource">
                <span class="resource-icon">‚≠ê</span>
                <span>Rating: <span id="rating-amount">0</span></span>
            </div>
            <div class="resource">
                <span class="resource-icon">üèÜ</span>
                <span>Prestige: <span id="prestige-amount">0</span></span>
            </div>
        </div>

        <!-- Stats Panel -->
        <div id="stats-panel" class="ui-panel">
            <h3>‚öîÔ∏è Arena Stats</h3>
            <div class="stat-row">
                <span class="stat-label">Wins</span>
                <span class="stat-value" id="wins">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Losses</span>
                <span class="stat-value" id="losses">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Win Rate</span>
                <span class="stat-value" id="winrate">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Gold/Win</span>
                <span class="stat-value" id="gold-per-win">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Match Speed</span>
                <span class="stat-value" id="match-speed">1.0x</span>
            </div>
        </div>

        <!-- Upgrades Panel -->
        <div id="upgrades-panel" class="ui-panel">
            <h3>‚ö° Upgrades</h3>
            <div id="upgrades-container"></div>
        </div>

        <!-- Bottom Match Status -->
        <div id="bottom-bar">
            <div class="match-status">
                <div>Match <span id="match-number">1</span></div>
                <div style="font-size: 14px; color: #aaa; margin-top: 5px;">
                    <span id="match-timer">0.0</span>s
                </div>
            </div>
            <div class="ui-panel" style="margin-top: 10px;">
                <div style="display: flex; gap: 30px; justify-content: center;">
                    <div>
                        <div style="color: #4a90e2; font-weight: bold; margin-bottom: 5px;">YOUR TEAM</div>
                        <div class="team-health" id="team-health"></div>
                    </div>
                    <div>
                        <div style="color: #e24a4a; font-weight: bold; margin-bottom: 5px;">ENEMY TEAM</div>
                        <div class="team-health" id="enemy-health"></div>
                    </div>
                </div>
            </div>
            <button class="prestige-button disabled" id="prestige-btn" style="margin-top: 15px;">
                Prestige (Requires 1000 Rating)
            </button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.169.0",
            "three/addons/": "https://esm.sh/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            baseHealth: 1000,
            baseDamage: 50,
            baseGoldPerWin: 10,
            matchDuration: 15,
            prestigeRequirement: 1000
        };

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            gold: 0,
            rating: 0,
            prestige: 0,
            wins: 0,
            losses: 0,
            matchNumber: 0,
            matchTime: 0,
            inMatch: false,
            
            // Upgrades
            upgrades: {
                damage: 0,
                health: 0,
                goldBonus: 0,
                critChance: 0,
                matchSpeed: 0,
                healing: 0,
                warriorUnlock: false,
                mageUnlock: false,
                priestUnlock: false
            },

            // Current match
            team: [],
            enemies: []
        };

        // ============================================
        // CHARACTER CLASSES
        // ============================================
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                color: 0xc79c6e,
                health: 1500,
                damage: 80,
                abilities: [
                    { name: 'Mortal Strike', damage: 150, cooldown: 6 },
                    { name: 'Execute', damage: 200, cooldown: 10 }
                ]
            },
            mage: {
                name: 'Mage',
                color: 0x69ccf0,
                health: 800,
                damage: 120,
                abilities: [
                    { name: 'Fireball', damage: 180, cooldown: 4 },
                    { name: 'Polymorph', damage: 0, cooldown: 15, cc: true }
                ]
            },
            priest: {
                name: 'Priest',
                color: 0xffffff,
                health: 1000,
                damage: 60,
                abilities: [
                    { name: 'Flash Heal', heal: 250, cooldown: 8 },
                    { name: 'Smite', damage: 100, cooldown: 5 }
                ]
            }
        };

        // ============================================
        // UPGRADE DEFINITIONS
        // ============================================
        const UPGRADES = [
            {
                id: 'damage',
                name: 'Team Damage',
                desc: 'Increase all damage by 10%',
                baseCost: 50,
                costMultiplier: 1.5,
                icon: '‚öîÔ∏è'
            },
            {
                id: 'health',
                name: 'Team Health',
                desc: 'Increase all health by 15%',
                baseCost: 40,
                costMultiplier: 1.5,
                icon: '‚ù§Ô∏è'
            },
            {
                id: 'goldBonus',
                name: 'Gold Gain',
                desc: 'Increase gold per win by 20%',
                baseCost: 100,
                costMultiplier: 1.6,
                icon: 'üí∞'
            },
            {
                id: 'critChance',
                name: 'Critical Strike',
                desc: 'Increase crit chance by 5%',
                baseCost: 200,
                costMultiplier: 1.8,
                icon: 'üí•'
            },
            {
                id: 'matchSpeed',
                name: 'Match Speed',
                desc: 'Matches complete 10% faster',
                baseCost: 300,
                costMultiplier: 2.0,
                icon: '‚ö°'
            },
            {
                id: 'healing',
                name: 'Healing Power',
                desc: 'Increase healing by 15%',
                baseCost: 150,
                costMultiplier: 1.7,
                icon: '‚ú®'
            },
            {
                id: 'warriorUnlock',
                name: 'Unlock Warrior',
                desc: 'Add a Warrior to your team',
                baseCost: 500,
                maxLevel: 1,
                icon: 'üõ°Ô∏è'
            },
            {
                id: 'mageUnlock',
                name: 'Unlock Mage',
                desc: 'Add a Mage to your team',
                baseCost: 800,
                maxLevel: 1,
                icon: 'üîÆ'
            },
            {
                id: 'priestUnlock',
                name: 'Unlock Priest',
                desc: 'Add a Priest to your team',
                baseCost: 1200,
                maxLevel: 1,
                icon: '‚úùÔ∏è'
            }
        ];

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 12, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(10, 20, 10);
        mainLight.castShadow = true;
        mainLight.shadow.camera.left = -20;
        mainLight.shadow.camera.right = 20;
        mainLight.shadow.camera.top = 20;
        mainLight.shadow.camera.bottom = -20;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        const rimLight = new THREE.DirectionalLight(0x4a90e2, 0.5);
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // Arena Floor
        const floorGeometry = new THREE.CircleGeometry(15, 64);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            metalness: 0.4,
            roughness: 0.6
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Arena boundary ring
        const ringGeometry = new THREE.TorusGeometry(15, 0.3, 16, 100);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90e2,
            emissive: 0x2a70c2,
            emissiveIntensity: 0.5,
            metalness: 0.8,
            roughness: 0.2
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.1;
        scene.add(ring);

        // Pillars
        const pillarGeometry = new THREE.CylinderGeometry(0.8, 1, 8, 8);
        const pillarMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a3e,
            metalness: 0.6,
            roughness: 0.4
        });

        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.set(Math.cos(angle) * 12, 4, Math.sin(angle) * 12);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            scene.add(pillar);

            // Pillar glow
            const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.6
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(pillar.position);
            glow.position.y = 8;
            scene.add(glow);
        }

        // ============================================
        // CHARACTER CREATION
        // ============================================
        function createCharacter(classType, isEnemy) {
            const classData = CLASSES[classType];
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: classData.color,
                metalness: 0.3,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2;
            head.castShadow = true;
            group.add(head);

            // Weapon indicator
            const weaponGeometry = new THREE.BoxGeometry(0.2, 1.2, 0.2);
            const weaponMaterial = new THREE.MeshStandardMaterial({
                color: isEnemy ? 0xff4444 : 0x44ff44,
                emissive: isEnemy ? 0xff0000 : 0x00ff00,
                emissiveIntensity: 0.5
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0.6, 1.2, 0);
            weapon.rotation.z = Math.PI / 4;
            group.add(weapon);

            // Team indicator ring
            const ringGeo = new THREE.TorusGeometry(0.6, 0.05, 16, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: isEnemy ? 0xff4444 : 0x4444ff
            });
            const indicatorRing = new THREE.Mesh(ringGeo, ringMat);
            indicatorRing.rotation.x = -Math.PI / 2;
            indicatorRing.position.y = 0.05;
            group.add(indicatorRing);

            group.userData = {
                classType,
                classData,
                health: classData.health,
                maxHealth: classData.health,
                damage: classData.damage,
                abilities: classData.abilities.map(a => ({...a, currentCooldown: 0})),
                isEnemy,
                target: null,
                ccUntil: 0
            };

            return group;
        }

        // ============================================
        // MATCH SYSTEM
        // ============================================
        function startNewMatch() {
            // Clear previous characters
            gameState.team.forEach(char => scene.remove(char));
            gameState.enemies.forEach(char => scene.remove(char));
            gameState.team = [];
            gameState.enemies = [];

            gameState.matchNumber++;
            gameState.matchTime = 0;
            gameState.inMatch = true;

            // Determine team composition
            const teamComp = ['warrior'];
            if (gameState.upgrades.warriorUnlock) teamComp.push('warrior');
            if (gameState.upgrades.mageUnlock) teamComp.push('mage');
            if (gameState.upgrades.priestUnlock) teamComp.push('priest');

            // Create team
            for (let i = 0; i < Math.min(3, teamComp.length); i++) {
                const char = createCharacter(teamComp[i], false);
                const angle = (i / 3) * Math.PI * 0.6 - Math.PI * 0.3;
                char.position.set(Math.cos(angle) * 6, 0, Math.sin(angle) * 6 - 5);
                char.rotation.y = 0;
                
                // Apply upgrades
                char.userData.maxHealth = char.userData.classData.health * (1 + gameState.upgrades.health * 0.15);
                char.userData.health = char.userData.maxHealth;
                char.userData.damage = char.userData.classData.damage * (1 + gameState.upgrades.damage * 0.1);
                
                scene.add(char);
                gameState.team.push(char);
            }

            // Create enemies (matching composition)
            const enemyComp = [...teamComp];
            for (let i = 0; i < Math.min(3, enemyComp.length); i++) {
                const char = createCharacter(enemyComp[i], true);
                const angle = (i / 3) * Math.PI * 0.6 - Math.PI * 0.3;
                char.position.set(Math.cos(angle) * 6, 0, Math.sin(angle) * 6 + 5);
                char.rotation.y = Math.PI;
                
                // Enemy scaling based on rating
                const enemyScale = 1 + (gameState.rating / 100) * 0.1;
                char.userData.maxHealth = char.userData.classData.health * enemyScale;
                char.userData.health = char.userData.maxHealth;
                char.userData.damage = char.userData.classData.damage * enemyScale;
                
                scene.add(char);
                gameState.enemies.push(char);
            }

            updateHealthBars();
        }

        // ============================================
        // COMBAT SYSTEM
        // ============================================
        function updateCombat(deltaTime) {
            if (!gameState.inMatch) return;

            const speedMultiplier = 1 + gameState.upgrades.matchSpeed * 0.1;
            const effectiveDelta = deltaTime * speedMultiplier;
            gameState.matchTime += effectiveDelta;

            // Update cooldowns
            [...gameState.team, ...gameState.enemies].forEach(char => {
                char.userData.abilities.forEach(ability => {
                    if (ability.currentCooldown > 0) {
                        ability.currentCooldown -= effectiveDelta;
                    }
                });
            });

            // Combat AI
            gameState.team.forEach(char => {
                if (char.userData.health <= 0) return;

                // Target selection
                if (!char.userData.target || char.userData.target.userData.health <= 0) {
                    const aliveEnemies = gameState.enemies.filter(e => e.userData.health > 0);
                    if (aliveEnemies.length > 0) {
                        // Target lowest health enemy
                        char.userData.target = aliveEnemies.reduce((lowest, e) => 
                            e.userData.health < lowest.userData.health ? e : lowest
                        );
                    }
                }

                // Use abilities
                if (char.userData.target) {
                    char.userData.abilities.forEach(ability => {
                        if (ability.currentCooldown <= 0) {
                            useAbility(char, char.userData.target, ability);
                            ability.currentCooldown = ability.cooldown;
                        }
                    });

                    // Look at target
                    char.lookAt(char.userData.target.position);
                }
            });

            // Enemy AI (same logic)
            gameState.enemies.forEach(char => {
                if (char.userData.health <= 0) return;

                if (!char.userData.target || char.userData.target.userData.health <= 0) {
                    const aliveAllies = gameState.team.filter(e => e.userData.health > 0);
                    if (aliveAllies.length > 0) {
                        char.userData.target = aliveAllies[Math.floor(Math.random() * aliveAllies.length)];
                    }
                }

                if (char.userData.target) {
                    char.userData.abilities.forEach(ability => {
                        if (ability.currentCooldown <= 0) {
                            useAbility(char, char.userData.target, ability);
                            ability.currentCooldown = ability.cooldown;
                        }
                    });
                    char.lookAt(char.userData.target.position);
                }
            });

            // Check match end
            const teamAlive = gameState.team.filter(c => c.userData.health > 0).length;
            const enemiesAlive = gameState.enemies.filter(c => c.userData.health > 0).length;

            if (teamAlive === 0 || enemiesAlive === 0) {
                endMatch(teamAlive > 0);
            }

            updateHealthBars();
        }

        function useAbility(caster, target, ability) {
            if (ability.heal) {
                // Healing
                const aliveAllies = caster.userData.isEnemy ? gameState.enemies : gameState.team;
                const damagedAllies = aliveAllies.filter(a => a.userData.health > 0 && a.userData.health < a.userData.maxHealth);
                if (damagedAllies.length > 0) {
                    const healTarget = damagedAllies.reduce((lowest, a) => 
                        a.userData.health < lowest.userData.health ? a : lowest
                    );
                    const healAmount = ability.heal * (1 + gameState.upgrades.healing * 0.15);
                    healTarget.userData.health = Math.min(healTarget.userData.maxHealth, healTarget.userData.health + healAmount);
                    showDamageNumber(healTarget.position, Math.round(healAmount), true);
                    createAbilityEffect(healTarget.position, 0x44ff44);
                }
            } else if (ability.damage) {
                // Damage
                let damage = ability.damage * (caster.userData.damage / caster.userData.classData.damage);
                
                // Crit chance
                const critChance = gameState.upgrades.critChance * 0.05;
                const isCrit = Math.random() < critChance;
                if (isCrit) damage *= 2;

                target.userData.health -= damage;
                showDamageNumber(target.position, Math.round(damage), false, isCrit);
                createAbilityEffect(target.position, isCrit ? 0xffff00 : 0xff4444);

                // Death check
                if (target.userData.health <= 0) {
                    target.userData.health = 0;
                    target.visible = false;
                }
            }
        }

        function createAbilityEffect(position, color) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity: 0.8
            });
            const effect = new THREE.Mesh(geometry, material);
            effect.position.copy(position);
            effect.position.y += 1;
            scene.add(effect);

            // Animate and remove
            let scale = 1;
            const animateEffect = () => {
                scale += 0.1;
                effect.scale.setScalar(scale);
                material.opacity -= 0.05;
                
                if (material.opacity <= 0) {
                    scene.remove(effect);
                } else {
                    requestAnimationFrame(animateEffect);
                }
            };
            animateEffect();
        }

        function showDamageNumber(position, amount, isHeal = false, isCrit = false) {
            const div = document.createElement('div');
            div.className = isHeal ? 'damage-number heal-number' : 'damage-number';
            div.textContent = (isCrit ? 'CRIT! ' : '') + Math.round(amount);
            div.style.left = '50%';
            div.style.top = '50%';
            div.style.transform = `translate(-50%, -50%)`;
            document.getElementById('ui-overlay').appendChild(div);

            // Project 3D position to 2D screen
            const vector = position.clone();
            vector.y += 2;
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y) * 0.5 + 0.5) * window.innerHeight;
            
            div.style.left = x + 'px';
            div.style.top = y + 'px';

            setTimeout(() => div.remove(), 1000);
        }

        function endMatch(victory) {
            gameState.inMatch = false;

            if (victory) {
                gameState.wins++;
                const goldPerWin = CONFIG.baseGoldPerWin * (1 + gameState.upgrades.goldBonus * 0.2) * (1 + gameState.prestige * 0.5);
                gameState.gold += goldPerWin;
                gameState.rating += 10;
            } else {
                gameState.losses++;
                gameState.rating = Math.max(0, gameState.rating - 5);
            }

            updateUI();
            setTimeout(() => startNewMatch(), 1500);
        }

        // ============================================
        // UI SYSTEM
        // ============================================
        function updateUI() {
            document.getElementById('gold-amount').textContent = Math.floor(gameState.gold);
            document.getElementById('rating-amount').textContent = gameState.rating;
            document.getElementById('prestige-amount').textContent = gameState.prestige;
            document.getElementById('wins').textContent = gameState.wins;
            document.getElementById('losses').textContent = gameState.losses;
            
            const winRate = gameState.wins + gameState.losses > 0 
                ? (gameState.wins / (gameState.wins + gameState.losses) * 100).toFixed(1)
                : 0;
            document.getElementById('winrate').textContent = winRate + '%';
            
            const goldPerWin = Math.floor(CONFIG.baseGoldPerWin * (1 + gameState.upgrades.goldBonus * 0.2) * (1 + gameState.prestige * 0.5));
            document.getElementById('gold-per-win').textContent = goldPerWin;
            
            const matchSpeed = (1 + gameState.upgrades.matchSpeed * 0.1).toFixed(1);
            document.getElementById('match-speed').textContent = matchSpeed + 'x';

            document.getElementById('match-number').textContent = gameState.matchNumber;
            document.getElementById('match-timer').textContent = gameState.matchTime.toFixed(1);

            // Prestige button
            const prestigeBtn = document.getElementById('prestige-btn');
            if (gameState.rating >= CONFIG.prestigeRequirement) {
                prestigeBtn.classList.remove('disabled');
            } else {
                prestigeBtn.classList.add('disabled');
            }
        }

        function updateHealthBars() {
            const teamHealthDiv = document.getElementById('team-health');
            const enemyHealthDiv = document.getElementById('enemy-health');

            teamHealthDiv.innerHTML = '';
            enemyHealthDiv.innerHTML = '';

            gameState.team.forEach((char, i) => {
                const healthPercent = (char.userData.health / char.userData.maxHealth) * 100;
                const div = document.createElement('div');
                div.className = 'health-indicator';
                div.innerHTML = `
                    <div>${char.userData.classData.name}</div>
                    <div class="health-bar">
                        <div class="health-fill" style="width: ${healthPercent}%"></div>
                    </div>
                `;
                teamHealthDiv.appendChild(div);
            });

            gameState.enemies.forEach((char, i) => {
                const healthPercent = (char.userData.health / char.userData.maxHealth) * 100;
                const div = document.createElement('div');
                div.className = 'health-indicator';
                div.innerHTML = `
                    <div>${char.userData.classData.name}</div>
                    <div class="health-bar">
                        <div class="health-fill" style="width: ${healthPercent}%"></div>
                    </div>
                `;
                enemyHealthDiv.appendChild(div);
            });
        }

        function renderUpgrades() {
            const container = document.getElementById('upgrades-container');
            container.innerHTML = '';

            UPGRADES.forEach(upgrade => {
                const level = gameState.upgrades[upgrade.id];
                const maxLevel = upgrade.maxLevel || 999;
                
                if (typeof level === 'boolean' && level) return; // Already unlocked

                const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier || 1.5, level));
                const canAfford = gameState.gold >= cost;
                const isMaxLevel = level >= maxLevel;

                const div = document.createElement('div');
                div.className = 'upgrade-item' + (!canAfford || isMaxLevel ? ' disabled' : '');
                
                const levelText = typeof level === 'number' && maxLevel === 999 ? `Lvl ${level}` : '';
                
                div.innerHTML = `
                    <div class="upgrade-name">
                        ${upgrade.icon} ${upgrade.name}
                        <span class="upgrade-level">${levelText}</span>
                    </div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-cost">
                        ${isMaxLevel ? 'MAX LEVEL' : `üí∞ ${cost} Gold`}
                    </div>
                `;

                if (!isMaxLevel) {
                    div.addEventListener('click', () => {
                        if (canAfford) {
                            gameState.gold -= cost;
                            if (typeof gameState.upgrades[upgrade.id] === 'boolean') {
                                gameState.upgrades[upgrade.id] = true;
                            } else {
                                gameState.upgrades[upgrade.id]++;
                            }
                            updateUI();
                            renderUpgrades();
                        }
                    });
                }

                container.appendChild(div);
            });
        }

        function doPrestige() {
            if (gameState.rating < CONFIG.prestigeRequirement) return;

            gameState.prestige++;
            gameState.gold = 0;
            gameState.rating = 0;
            gameState.wins = 0;
            gameState.losses = 0;
            gameState.matchNumber = 0;

            // Keep class unlocks, reset other upgrades
            const warriorUnlock = gameState.upgrades.warriorUnlock;
            const mageUnlock = gameState.upgrades.mageUnlock;
            const priestUnlock = gameState.upgrades.priestUnlock;

            gameState.upgrades = {
                damage: 0,
                health: 0,
                goldBonus: 0,
                critChance: 0,
                matchSpeed: 0,
                healing: 0,
                warriorUnlock,
                mageUnlock,
                priestUnlock
            };

            updateUI();
            renderUpgrades();
            startNewMatch();
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        document.getElementById('prestige-btn').addEventListener('click', doPrestige);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update combat
            updateCombat(deltaTime);

            // Animate ring glow
            ring.material.emissiveIntensity = 0.3 + Math.sin(currentTime * 0.002) * 0.2;

            // Camera gentle movement
            camera.position.x = Math.sin(currentTime * 0.0003) * 2;
            camera.position.y = 12 + Math.sin(currentTime * 0.0005) * 1;
            camera.lookAt(0, 0, 0);

            // Update UI
            if (gameState.inMatch) {
                document.getElementById('match-timer').textContent = gameState.matchTime.toFixed(1);
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZE
        // ============================================
        updateUI();
        renderUpgrades();
        startNewMatch();
        animate();
    </script>
</body>
</html>