<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Legends: Idle Champion</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Quicksand:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Quicksand', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(20, 15, 10, 0.95);
            border: 1px solid #8e6d3f;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.9), inset 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }

        .ui-panel::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border: 1px solid #d4af37;
            border-radius: 3px;
            pointer-events: none;
        }

        #top-bar {
            display: flex;
            gap: 40px;
            align-items: center;
            justify-content: center;
            width: fit-content;
            margin: 0 auto;
            padding: 10px 40px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 1px 1px 2px #000;
            font-family: 'Cinzel', serif;
        }

        .resource-icon-img {
            width: 32px;
            height: 32px;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        #side-panels {
            display: flex;
            justify-content: space-between;
            height: 60vh;
            pointer-events: none;
        }

        #stats-panel {
            width: 280px;
            pointer-events: auto;
            align-self: flex-start;
        }

        #upgrades-panel {
            width: 380px;
            max-height: 100%;
            overflow-y: auto;
            pointer-events: auto;
            align-self: flex-start;
        }
        
        /* Remove ::after border from upgrades panel to prevent scroll overflow issue */
        #upgrades-panel::after {
            display: none;
        }

        #bottom-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .match-summary-panel {
            width: 600px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        #mobile-toggle-hud {
            display: none;
            position: absolute;
            top: -38px;
            left: 50%;
            transform: translateX(-50%);
            background: #d4af37; /* Brighter gold for better visibility */
            border: 2px solid #fff;
            border-bottom: none;
            color: #000; /* High contrast black on gold */
            padding: 10px 25px;
            border-radius: 15px 15px 0 0;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            white-space: nowrap;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.6);
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .match-summary-panel.collapsed #mobile-toggle-hud {
            top: -45px;
            background: #ffd700;
            padding: 12px 35px;
            animation: expandPulse 2s infinite;
        }

        @keyframes expandPulse {
            0% { transform: translateX(-50%) scale(1); box-shadow: 0 -5px 15px rgba(212, 175, 55, 0.5); }
            50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 -8px 25px rgba(212, 175, 55, 0.8); }
            100% { transform: translateX(-50%) scale(1); box-shadow: 0 -5px 15px rgba(212, 175, 55, 0.5); }
        }

        .match-summary-panel.collapsed {
            height: 5px;
            min-height: 0;
            min-width: 0;
            overflow: visible; /* Allow the larger button to be seen */
            padding: 0;
            background: rgba(30, 25, 20, 0.98);
            border: none;
            border-top: 2px solid #ffd700;
        }

        .match-summary-panel.collapsed .team-health-container,
        .match-summary-panel.collapsed #match-timer-container,
        .match-summary-panel.collapsed .match-status-header {
            display: none !important;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(142, 109, 63, 0.3);
        }

        .stat-label {
            color: #bfa07a;
            font-family: 'Cinzel', serif;
            font-size: 14px;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        h3 {
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
            font-size: 20px;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid #8e6d3f;
            padding-bottom: 8px;
        }

        .upgrade-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #4a3a25;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .upgrade-item:hover {
            background: rgba(212, 175, 55, 0.15);
            border-color: #ffd700;
            transform: translateX(-5px);
        }

        .upgrade-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }

        .upgrade-icon-img {
            width: 44px;
            height: 44px;
            border: 2px solid #8e6d3f;
            border-radius: 4px;
            background: #111;
        }

        .upgrade-info {
            flex: 1;
        }

        .upgrade-name {
            font-weight: bold;
            color: #ffd700;
            font-family: 'Cinzel', serif;
            font-size: 15px;
        }

        .upgrade-desc {
            font-size: 12px;
            color: #ccc;
            margin: 2px 0 5px 0;
        }

        .upgrade-cost-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .upgrade-cost {
            font-weight: bold;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }

        .upgrade-level {
            color: #4a90e2;
            font-size: 11px;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 10px;
        }

        .match-status-header {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            color: #ffd700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0,0,0,1);
        }

        .team-health-container {
            display: flex;
            gap: 40px;
            justify-content: center;
        }

        .team-box {
            width: 250px;
        }

        .team-name {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
            letter-spacing: 1px;
        }

        .team-health {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .health-indicator {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #4a3a25;
            padding: 4px 8px;
            border-radius: 3px;
            position: relative;
        }

        .health-bar {
            height: 8px;
            background: #222;
            border: 1px solid #000;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 4px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(180deg, #40ff40, #00aa00);
            transition: width 0.3s;
        }

        .mana-bar {
            height: 4px;
            background: #111;
            border-radius: 1px;
            margin-top: 2px;
            overflow: hidden;
        }

        .mana-fill.energy { background: linear-gradient(180deg, #fff569, #d9cf5a); }
        .mana-fill.rage { background: linear-gradient(180deg, #ff4444, #cc0000); }

        .unit-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            font-weight: bold;
        }

        .prestige-button {
            background: linear-gradient(180deg, #4a3a25, #221a11);
            border: 2px solid #8e6d3f;
            color: #ffd700;
            padding: 12px 40px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Cinzel', serif;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .prestige-button:hover:not(.disabled) {
            background: linear-gradient(180deg, #8e6d3f, #4a3a25);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3);
        }

        .prestige-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .forfeit-button {
            background: linear-gradient(180deg, #880000, #440000) !important;
            border: 1px solid #ff4444 !important;
            color: #ffcccc !important;
            margin-top: 10px;
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
            display: none; /* Hidden by default, shown in updateUI during match */
        }

        .forfeit-button:hover:not(.disabled) {
            background: linear-gradient(180deg, #aa0000, #660000) !important;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            transform: translateY(-1px);
        }

        .forfeit-button.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1);
            box-shadow: none;
        }

        @keyframes shopPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(212, 175, 55, 0.5); }
            50% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.8), 0 0 30px rgba(212, 175, 55, 0.4); }
        }

        .shop-available {
            animation: shopPulse 2s ease-in-out infinite;
            border-color: #d4af37 !important;
        }

        .nameplate {
            position: absolute;
            pointer-events: none;
            text-align: center;
            min-width: 120px;
            transform: translate(-50%, -100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .nameplate-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000, 0 0 5px #000;
            font-family: 'Cinzel', serif;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .nameplate-health {
            width: 110px;
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .nameplate-health-fill {
            position: absolute;
            top: 0; left: 0; height: 100%;
            background: linear-gradient(180deg, #40ff40, #00aa00);
            transition: width 0.1s;
            z-index: 2;
        }

        /* Class health bar colors */
        .nameplate-health-fill.warrior { background: linear-gradient(180deg, #c79c6e, #a77c4e); }
        .nameplate-health-fill.mage { background: linear-gradient(180deg, #69ccf0, #49ace0); }
        .nameplate-health-fill.priest { background: linear-gradient(180deg, #ffffff, #cccccc); }
        .nameplate-health-fill.druid { background: linear-gradient(180deg, #ff7d0a, #df5d00); }
        .nameplate-health-fill.hunter { background: linear-gradient(180deg, #abd473, #8db453); }
        .nameplate-health-fill.death_knight { background: linear-gradient(180deg, #c41e3a, #9c172e); }
        .nameplate-health-fill.paladin { background: linear-gradient(180deg, #f58cba, #d477a1); }
        .nameplate-health-fill.rogue { background: linear-gradient(180deg, #fff569, #d9cf5a); }
        .nameplate-health-fill.shaman { background: linear-gradient(180deg, #0070de, #0056aa); }
        .nameplate-health-fill.warlock { background: linear-gradient(180deg, #8787ed, #6b6bbd); }
        .nameplate-health-fill.demon_hunter { background: linear-gradient(180deg, #a330c9, #7a2497); }

        .nameplate-health-fill.monk { background: linear-gradient(180deg, #00ff96, #00aa64); }
        .nameplate-cast-bar {
            width: 110px;
            height: 14px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ffd700;
            margin-top: 2px;
            display: none;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .cast-bar-fill {
            height: 100%;
            background: linear-gradient(180deg, #ffd700, #b8860b);
            width: 0%;
            transition: width 0.05s linear;
        }

        .nameplate-cast-bar.interrupted {
            border-color: #ff4444;
        }

        .nameplate-cast-bar.interrupted .cast-bar-fill {
            background: linear-gradient(180deg, #ff4444, #880000);
            width: 100% !important;
        }

        .nameplate-cast-bar.interrupted .cast-bar-text {
            color: #ffcccc;
        }

        .nameplate-mana {
            width: 110px;
            height: 4px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-top: none;
            border-radius: 0 0 2px 2px;
            position: relative;
            overflow: hidden;
            display: none;
        }

        .nameplate-mana-fill {
            height: 100%;
            background: linear-gradient(180deg, #4a90e2, #2a70c2);
            transition: width 0.2s;
        }
        
        .nameplate-mana-fill.energy { background: linear-gradient(180deg, #fff569, #d9cf5a); }
        .nameplate-mana-fill.rage { background: linear-gradient(180deg, #ff4444, #cc0000); }

        .cast-bar-text {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 1px #000;
            z-index: 5;
        }

        .class-icon-mini {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }

        #upgrades-panel::-webkit-scrollbar {
            width: 6px;
        }

        #upgrades-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        #upgrades-panel::-webkit-scrollbar-thumb {
            background: #8e6d3f;
            border-radius: 3px;
        }

        .nameplate-combo-points {
            display: flex;
            gap: 2px;
            margin-top: 2px;
            height: 6px;
        }

        .combo-pip {
            width: 10px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 1px;
        }

        .combo-pip.active {
            background: #fff569;
            box-shadow: 0 0 5px #fff569;
            border-color: #fff;
        }

        /* Arena Announcements */
        #arena-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(0,0,0,1), 0 0 40px rgba(255,215,0,0.8);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #arena-announcement.show {
            opacity: 1;
        }

        /* Combat Log */
        #combat-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #8e6d3f;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-size: 11px;
            z-index: 15;
            pointer-events: none;
        }

        #combat-log::-webkit-scrollbar {
            width: 6px;
        }

        #combat-log::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        #combat-log::-webkit-scrollbar-thumb {
            background: #8e6d3f;
            border-radius: 3px;
        }

        .log-entry {
            margin: 2px 0;
            line-height: 1.4;
        }

        .log-damage { color: #ff6666; }
        .log-heal { color: #66ff66; }
        .log-cc { color: #ffaa00; }
        .log-death { color: #ff0000; font-weight: bold; }
        .log-buff { color: #4a90e2; }

        /* Arena Rating Display */
        #arena-rating {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Cinzel', serif;
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(0,0,0,1);
            z-index: 20;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border: 2px solid #8e6d3f;
            border-radius: 4px;
        }

        .rating-change {
            font-size: 16px;
            margin-left: 10px;
        }

        .rating-up { color: #66ff66; }
        .rating-down { color: #ff6666; }

        .nameplate-dr {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 4px;
        }

        /* Interrupt Tracker (OmniCC style) */
        .nameplate-interrupts {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 2px;
            height: 18px;
        }

        .interrupt-icon {
            width: 18px;
            height: 18px;
            border: 1px solid #ffd700;
            border-radius: 2px;
            background-size: cover;
            position: relative;
            background-color: #111;
        }

        .interrupt-cd-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #fff;
        }

        /* =============================================
           PET NAMEPLATE SYSTEM
           ============================================= */
        .pet-nameplate {
            min-width: 100px !important;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.8));
        }

        .pet-nameplate-header {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000, 0 0 4px #000;
            font-family: 'Cinzel', serif;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        .pet-type-icon {
            font-size: 11px;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.8));
        }

        .pet-owner-tag {
            font-size: 8px;
            color: rgba(255,255,255,0.5);
            font-family: 'Quicksand', sans-serif;
            margin-left: 2px;
        }

        .pet-health-wrapper {
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(80, 80, 80, 0.6);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.8), 0 1px 2px rgba(0,0,0,0.5);
        }

        .pet-health-wrapper.ally-pet {
            border-color: rgba(68, 255, 68, 0.3);
        }

        .pet-health-wrapper.enemy-pet {
            border-color: rgba(255, 68, 68, 0.3);
        }

        .pet-health-wrapper.soul-linked {
            border-color: rgba(135, 135, 237, 0.6);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.8), 0 0 6px rgba(135, 135, 237, 0.3);
        }

        .pet-health-fill {
            position: absolute;
            top: 0; left: 0; height: 100%;
            transition: width 0.15s ease-out;
            border-radius: 1px;
            z-index: 2;
        }

        .pet-health-fill.ally {
            background: linear-gradient(180deg, #55dd55 0%, #22aa22 50%, #118811 100%);
        }

        .pet-health-fill.enemy {
            background: linear-gradient(180deg, #ee4444 0%, #aa1111 50%, #881111 100%);
        }

        .pet-health-fill.pet-hp-mid {
            background: linear-gradient(180deg, #ffcc00 0%, #cc8800 50%, #995500 100%) !important;
        }

        .pet-health-fill.pet-hp-low {
            background: linear-gradient(180deg, #ff3333 0%, #cc0000 50%, #880000 100%) !important;
            animation: petHpPulse 0.6s ease-in-out infinite;
        }

        @keyframes petHpPulse {
            0%, 100% { opacity: 1; filter: brightness(1); }
            50% { opacity: 0.75; filter: brightness(1.4); }
        }

        .pet-health-ghost {
            position: absolute;
            top: 0; left: 0; height: 100%;
            background: rgba(255, 100, 100, 0.4);
            transition: width 0.6s ease-out 0.15s;
            z-index: 1;
            border-radius: 1px;
        }

        .pet-hp-text {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 1px #000, 0 0 3px #000;
            pointer-events: none;
            z-index: 3;
            font-family: 'Quicksand', sans-serif;
            letter-spacing: 0.3px;
        }

        /* Pet resource bar (focus/energy) */
        .pet-resource-bar {
            width: 100px;
            height: 3px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 1px;
            margin-top: 1px;
            overflow: hidden;
            position: relative;
        }

        .pet-resource-fill {
            height: 100%;
            transition: width 0.3s ease-out;
            border-radius: 1px;
        }

        .pet-resource-fill.focus {
            background: linear-gradient(180deg, #fff569, #d9cf5a);
        }

        .pet-resource-fill.shadow-energy {
            background: linear-gradient(180deg, #b070dd, #8050bb);
        }

        /* Pet defensive proc flash */
        .pet-health-wrapper.dodge-flash {
            animation: petDodgeFlash 0.4s ease-out;
        }

        @keyframes petDodgeFlash {
            0% { border-color: #ffffff; box-shadow: inset 0 0 8px rgba(255,255,255,0.5); }
            100% { border-color: rgba(80, 80, 80, 0.6); }
        }

        .pet-ability-pips {
            display: flex;
            gap: 2px;
            justify-content: center;
            margin-top: 2px;
        }

        .pet-ability-pip {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            border: 1px solid rgba(255, 215, 0, 0.5);
            background: rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
            font-size: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            text-shadow: 0 0 2px #000;
        }

        .pet-ability-pip.ready {
            border-color: #ffd700;
            background: rgba(60, 60, 0, 0.8);
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.4);
        }

        .pet-ability-pip.on-cd {
            border-color: rgba(100, 100, 100, 0.4);
        }

        .pet-ability-pip .pip-cd-sweep {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.65);
            clip-path: polygon(50% 50%, 50% 0%, 50% 0%);
            transition: clip-path 0.2s linear;
        }

        .pet-ability-pip .pip-icon {
            font-size: 9px;
            z-index: 2;
            position: relative;
        }

        .pet-cc-display {
            width: 100px;
            font-size: 9px;
            font-weight: bold;
            text-align: center;
            color: #ffcc00;
            text-shadow: 1px 1px 2px #000;
            background: rgba(0, 0, 0, 0.75);
            border-radius: 2px;
            padding: 1px 4px;
            display: none;
            margin-top: 1px;
        }

        .pet-cc-display.active {
            display: block;
            animation: petCCFlash 0.5s ease-in-out infinite alternate;
        }

        @keyframes petCCFlash {
            0% { background: rgba(80, 40, 0, 0.8); }
            100% { background: rgba(120, 60, 0, 0.9); }
        }

        /* Soul Link indicator on owner nameplate */
        .soul-link-indicator {
            font-size: 8px;
            color: #b070dd;
            text-shadow: 0 0 4px rgba(135, 135, 237, 0.6);
            display: none;
        }

        .soul-link-indicator.active {
            display: inline;
        }

        /* Pet damage type floating text colors */
        .pet-dmg-physical { color: #ffd700 !important; }
        .pet-dmg-magic { color: #b070dd !important; }
        .pet-dmg-bleed { color: #ff4444 !important; }

        .dr-indicator {
            width: 18px;
            height: 18px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(0, 0, 0, 0.6);
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            opacity: 0.2;
            transition: all 0.2s;
        }

        .dr-indicator.active-1 { background: #44ff44; border-color: #44ff44; box-shadow: 0 0 5px #44ff44; opacity: 1; }
        .dr-indicator.active-2 { background: #ffff44; border-color: #ffff44; box-shadow: 0 0 5px #ffff44; opacity: 1; }
        .dr-indicator.active-3 { background: #ff4444; border-color: #ff4444; box-shadow: 0 0 5px #ff4444; opacity: 1; }

        /* Buff/Debuff Icons */
        .nameplate-buffs {
            display: flex;
            justify-content: center;
            gap: 2px;
            margin-top: 2px;
            height: 16px;
        }

        .buff-icon {
            width: 16px;
            height: 16px;
            border: 1px solid #000;
            border-radius: 2px;
            position: relative;
            background-size: cover;
            background-color: #111;
        }

        .buff-timer {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 8px;
            color: #fff;
            text-shadow: 1px 1px 1px #000;
            font-weight: bold;
        }

        .buff-icon.debuff {
            border-color: #ff4444;
        }

        .buff-icon.buff {
            border-color: #44ff44;
        }

        .countdown-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: 140px;
            color: #ffd700;
            text-shadow: 0 0 40px rgba(0, 0, 0, 1), 0 0 20px rgba(212, 175, 55, 0.5);
            z-index: 100;
            pointer-events: none;
            display: none;
            font-weight: bold;
        }

        /* Floating Currency Rewards */
        .floating-currency {
            position: fixed;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            font-size: 32px;
            z-index: 150;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8), 2px 2px 4px rgba(0,0,0,1);
            animation: currencyFloat 2s ease-out forwards;
        }

        .floating-honor {
            color: #ffd700;
        }

        .floating-conquest {
            color: #ff88ff;
        }

        @keyframes currencyFloat {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) scale(1);
            }
        }

        /* Honor Shop Modal */
        #honor-shop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }

        #honor-shop-modal.show {
            display: flex;
        }

        .shop-container {
            background: rgba(20, 15, 10, 0.98);
            border: 2px solid #8e6d3f;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            position: relative;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 2px solid #8e6d3f;
            padding-bottom: 15px;
        }

        .shop-title {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        .shop-close {
            font-size: 32px;
            color: #fff;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0 10px;
            transition: all 0.2s;
        }

        .shop-close:hover {
            color: #ff4444;
            transform: scale(1.2);
        }

        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .shop-tab {
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #8e6d3f;
            border-radius: 4px;
            color: #bfa07a;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .shop-tab.active {
            background: linear-gradient(180deg, #8e6d3f, #4a3a25);
            color: #ffd700;
            border-color: #ffd700;
        }

        .shop-tab:hover:not(.active) {
            background: rgba(142, 109, 63, 0.3);
        }

        .shop-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .shop-item {
            background: linear-gradient(135deg, rgba(40, 30, 20, 0.9), rgba(20, 15, 10, 0.9));
            border: 2px solid #8e6d3f;
            border-radius: 6px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .shop-item:hover {
            border-color: #d4af37;
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.3);
        }

        .shop-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-item.locked:hover {
            transform: none;
            border-color: #8e6d3f;
        }

        .shop-item.cant-afford {
            opacity: 0.7;
        }

        .shop-item.cant-afford:hover {
            border-color: #ff4444;
            transform: none;
        }

        .shop-item.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .item-tier {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 12px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .tier-combatant { background: #1eff00; color: #000; }
        .tier-challenger { background: #0070dd; color: #fff; }
        .tier-rival { background: #a335ee; color: #fff; }
        .tier-duelist { background: #ff8000; color: #000; }
        .tier-gladiator { background: #e268a8; color: #fff; }
        .tier-epic { background: #a335ee; color: #fff; }

        .item-name {
            font-family: 'Cinzel', serif;
            font-size: 20px;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .item-level {
            font-size: 12px;
            color: #ffaa00;
            margin-bottom: 10px;
        }

        .item-stats {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        .item-stat {
            font-size: 13px;
            color: #00ff00;
            margin: 4px 0;
        }

        .item-description {
            font-size: 12px;
            color: #ffff00;
            font-style: italic;
            margin-bottom: 10px;
        }

        .item-cost {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #8e6d3f;
        }

        .cost-amount {
            font-size: 18px;
            color: #ffd700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .buy-button {
            padding: 8px 20px;
            background: linear-gradient(180deg, #8e6d3f, #4a3a25);
            border: 1px solid #d4af37;
            border-radius: 4px;
            color: #ffd700;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .buy-button:hover {
            background: linear-gradient(180deg, #d4af37, #8e6d3f);
            transform: scale(1.05);
        }

        .buy-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .slot-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Combat Feedback (Damage Numbers & Emojis) */
        .damage-number {
            position: absolute;
            pointer-events: none;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            font-size: 24px;
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,1), 0 0 10px rgba(0,0,0,0.8);
            z-index: 1000;
            white-space: nowrap;
            will-change: transform, opacity;
        }

        .damage-number.heal {
            color: #44ff44;
            text-shadow: 0 0 10px rgba(0,255,0,0.5), 2px 2px 4px #000;
        }

        .damage-number.crit {
            font-size: 38px;
            color: #ffff00;
            text-shadow: 0 0 15px rgba(255,255,0,0.8), 2px 2px 4px #000;
            z-index: 1001;
        }

        .damage-number.cc {
            color: #ff00ff;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(255,0,255,0.8), 2px 2px 4px #000;
        }

        @keyframes damageFloat {
            0% {
                opacity: 0;
                transform: translate(-50%, 0) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -20px) scale(1.1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -120px) scale(1);
            }
        }

        @keyframes critPop {
            0% {
                opacity: 0;
                transform: translate(-50%, 0) scale(0.3) rotate(-10deg);
            }
            15% {
                opacity: 1;
                transform: translate(-50%, -30px) scale(1.4) rotate(5deg);
            }
            30% {
                transform: translate(-50%, -35px) scale(1.2) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150px) scale(1);
            }
        }
        /* Responsive Design */
        @media screen and (max-width: 768px) {
            #ui-overlay {
                padding: 10px;
                justify-content: flex-start;
                gap: 10px;
            }
            #top-bar {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 4px;
                width: 100%;
                max-width: 100%;
                padding: 5px;
                transform: none;
                margin: 0 auto;
                pointer-events: auto;
            }
            .resource {
                font-size: 10px;
                gap: 3px;
                padding: 2px 4px;
            }
            .resource-icon-img {
                width: 18px;
                height: 18px;
            }
            #side-panels {
                display: none; /* Hide side panels by default on mobile */
            }
            #mobile-menu-trigger {
                display: flex !important;
            }
            .match-summary-panel {
                width: 95%;
                padding: 10px;
            }
            #prestige-btn {
                display: none; /* Hide large prestige button on mobile */
            }
            #combat-log {
                display: none;
            }
            .shop-container {
                width: 95% !important;
                max-height: 90vh;
                padding: 10px !important;
            }
            #arena-rating {
                top: 60px;
                font-size: 14px;
                padding: 2px 10px;
            }
            #arena-announcement {
                font-size: 24px;
            }
            .nameplate-name {
                font-size: 9px;
            }
            .nameplate-health {
                width: 70px;
                height: 8px;
            }
            #bottom-area {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%) scale(0.9);
                transform-origin: bottom center;
                width: auto;
                pointer-events: none;
            }
            #mobile-toggle-hud {
                display: block;
            }
            .match-summary-panel {
                pointer-events: auto;
                min-width: 300px;
            }
            .team-health-container {
                gap: 5px;
                pointer-events: auto;
            }
            .team-box {
                width: 100px;
            }
            .health-indicator {
                padding: 1px 3px;
                background: rgba(0, 0, 0, 0.8);
            }
            .health-bar {
                height: 4px;
            }
            .unit-label {
                font-size: 8px;
            }
            .mana-bar {
                height: 2px;
            }
        }

        @media screen and (max-height: 500px) {
            #side-panels {
                height: 35vh;
            }
            #top-bar {
                transform: scale(0.65);
            }
        }

        /* Modal specific mobile overrides */
        @media screen and (max-width: 600px) {
            #active-roster-display {
                gap: 5px !important;
                flex-wrap: wrap;
            }
            .shop-title {
                font-size: 16px !important;
            }
            #roster-items-container {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
            }
            #conquest-items-container {
                grid-template-columns: 1fr !important;
            }
            .shop-tabs {
                flex-wrap: wrap;
                gap: 5px;
            }
            .shop-tab {
                padding: 5px 10px !important;
                font-size: 12px !important;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="nameplates-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></div>
    <div id="countdown-overlay" class="countdown-overlay">5</div>
    <div id="arena-announcement"></div>
    <div id="combat-log"></div>
    <div id="arena-rating" style="display: none;">
        <span id="current-rating">1500</span>
        <span id="rating-change" class="rating-change"></span>
    </div>

    <!-- Mobile Menu Modal -->
    <div id="mobile-menu-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; overflow-y: auto; padding: 20px;">
        <div class="shop-header">
            <div class="shop-title">üè∞ Management</div>
            <button class="shop-close" id="mobile-menu-close">√ó</button>
        </div>
        
        <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
            <!-- Stats Summary -->
            <div class="ui-panel" style="background: rgba(40, 30, 20, 0.6);">
                <h4 style="color: #ffd700; font-family: 'Cinzel', serif; margin-bottom: 10px; text-align: center; border-bottom: 1px solid #8e6d3f;">Season Stats</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                    <div style="color: #aaa;">Rating:</div><div style="text-align: right;" id="m-stat-rating">0</div>
                    <div style="color: #aaa;">Wins:</div><div style="text-align: right;" id="m-stat-wins">0</div>
                    <div style="color: #aaa;">Losses:</div><div style="text-align: right;" id="m-stat-losses">0</div>
                    <div style="color: #aaa;">Win Rate:</div><div style="text-align: right;" id="m-stat-winrate">0%</div>
                </div>
            </div>

            <!-- Action Buttons -->
            <button class="prestige-button" id="m-btn-upgrades" style="background: linear-gradient(180deg, #ffd700, #b8860b); color: #000;">‚ö° Upgrade Powers</button>
            <button class="prestige-button" id="m-btn-shop" style="background: linear-gradient(180deg, #8e6d3f, #4a3a25);">üõ°Ô∏è Honor Shop</button>
            <button class="prestige-button" id="m-btn-roster" style="background: linear-gradient(180deg, #4a90e2, #2a70c2); border-color: #00ffff;">üë• Manage Roster</button>
            <button class="prestige-button" id="m-btn-vendor" style="background: linear-gradient(180deg, #9966ff, #6633cc); border-color: #ff00ff;">‚öîÔ∏è Conquest Vendor</button>
            <button class="prestige-button" id="m-btn-talents" style="background: linear-gradient(180deg, #ffd700, #b8860b); border-color: #ffd700; color: #000; font-weight: bold;">üåü Career Talents</button>
            <button class="prestige-button" id="m-btn-history" style="background: linear-gradient(180deg, #6b4e31, #4a341e); border-color: #8e6d3f;">üìú Season History</button>
            <button class="prestige-button" id="m-btn-settings" style="background: linear-gradient(180deg, #555, #333); border-color: #888;">‚öôÔ∏è Settings</button>
            <button class="forfeit-button" id="m-btn-forfeit">üè≥Ô∏è Forfeit Round</button>
            
            <div style="margin-top: 10px; border-top: 1px solid #4a3a25; padding-top: 15px;">
                <button class="prestige-button disabled" id="m-btn-prestige" style="width: 100%; font-size: 14px;">
                    Start New Season (2400 Rating)
                </button>
            </div>
        </div>
    </div>

    <!-- Mobile Menu Trigger -->
    <div id="mobile-menu-trigger" style="display: none; position: fixed; bottom: 80px; left: 20px; z-index: 150; background: #8e6d3f; border: 2px solid #ffd700; color: #fff; width: 50px; height: 50px; border-radius: 50%; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; box-shadow: 0 0 15px rgba(0,0,0,0.8); pointer-events: auto;">
        üè∞
    </div>
    <div id="roster-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 200; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 900px;">
            <div class="shop-header">
                <div class="shop-title" style="color: #00ffff;">üë• Team Management</div>
                <button class="shop-close" id="roster-close-btn">√ó</button>
            </div>
            
            <div style="background: rgba(0, 150, 255, 0.1); border: 1px solid #4a90e2; border-radius: 4px; padding: 15px; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 16px; color: #fff; margin-bottom: 8px; font-family: 'Cinzel', serif;">
                    Current Active Team
                </div>
                <div id="active-roster-display" style="display: flex; justify-content: center; gap: 20px;">
                    <!-- Slots will be populated here -->
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 15px; color: #ffd700; font-family: 'Cinzel', serif; font-size: 18px; border-bottom: 1px solid #8e6d3f; padding-bottom: 8px;">
                Available Heroes (Unlocks by Rating)
            </div>
            
            <div id="roster-items-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; max-height: 400px; overflow-y: auto; padding: 10px;">
                <!-- Hero cards will be populated here -->
            </div>
            
            <div style="margin-top: 20px; text-align: center; font-size: 12px; color: #888;">
                Click an active slot above to select it, then click an available hero to swap.
            </div>
        </div>
    </div>

    <!-- Upgrades Modal (Mobile) -->
    <div id="upgrades-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 200; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 600px;">
            <div class="shop-header">
                <div class="shop-title">‚ö° Upgrades</div>
                <button class="shop-close" id="upgrades-close-btn">√ó</button>
            </div>
            <div id="mobile-upgrades-container" style="padding: 10px; max-height: 70vh; overflow-y: auto;"></div>
        </div>
    </div>

    <!-- Conquest Shop Modal -->
    <div id="conquest-shop-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 200; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 900px;">
            <div class="shop-header">
                <div class="shop-title" style="color: #ff00ff;">‚öîÔ∏è Conquest Vendor</div>
                <button class="shop-close" id="conquest-shop-close-btn">√ó</button>
            </div>
            
            <div style="background: rgba(100, 50, 150, 0.3); border: 1px solid #9966ff; border-radius: 4px; padding: 15px; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 14px; color: #ff88ff; margin-bottom: 8px;">
                    <strong>Conquest Capacity:</strong> <span id="conquest-shop-amount">0</span> / <span id="conquest-shop-cap">1000</span>
                </div>
                <div style="font-size: 18px; color: #ffd700; margin-bottom: 8px; font-family: 'Cinzel', serif;">
                    Current Balance: <span id="conquest-shop-balance">0</span> ‚öîÔ∏è
                </div>
                <div style="font-size: 11px; color: #aaa;">
                    Prestigious upgrades with permanent bonuses. Earn conquest by winning matches!
                </div>
            </div>
            
            <div id="conquest-items-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px;"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 200; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 600px;">
            <div class="shop-header">
                <div class="shop-title">‚öôÔ∏è Settings</div>
                <button class="shop-close" id="settings-close-btn">√ó</button>
            </div>
            
            <div style="padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                <!-- Audio Section -->
                <div style="background: rgba(0, 150, 255, 0.1); border: 1px solid #00aaff; border-radius: 4px; padding: 15px;">
                    <h4 style="color: #00aaff; margin-bottom: 10px; font-family: 'Cinzel', serif;">üîä Audio Settings</h4>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span id="settings-mute-btn" style="cursor: pointer; font-size: 24px;">üîä</span>
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 11px;">Master Volume</label>
                            <input type="range" id="master-volume-slider" min="0" max="1" step="0.01" value="0.5" style="width: 100%;">
                        </div>
                    </div>
                </div>

                <!-- Save/Load Section -->
                <div style="background: rgba(0, 100, 0, 0.2); border: 1px solid #4CAF50; border-radius: 4px; padding: 15px;">
                    <h4 style="color: #4CAF50; margin-bottom: 10px; font-family: 'Cinzel', serif;">üíæ Save & Load</h4>
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 8px;">
                        Game auto-saves every 30 seconds and before closing
                    </div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 12px;" id="last-save-time">
                        Last saved: Never
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="buy-button" id="settings-manual-save" style="flex: 1; min-width: 140px;">
                            üíæ Manual Save
                        </button>
                        <button class="buy-button" id="settings-export-save" style="flex: 1; min-width: 140px; background: linear-gradient(180deg, #2196F3, #1565C0);">
                            üì• Export Save
                        </button>
                        <button class="buy-button" id="settings-import-save" style="flex: 1; min-width: 140px; background: linear-gradient(180deg, #2196F3, #1565C0);">
                            üì§ Import Save
                        </button>
                    </div>
                    <div style="margin-top: 10px; font-size: 11px; color: #888; font-style: italic;">
                        Ctrl+S or Cmd+S for quick save
                    </div>
                </div>
                
                <!-- Stats Section -->
                <div style="background: rgba(100, 100, 0, 0.2); border: 1px solid #FFD700; border-radius: 4px; padding: 15px;">
                    <h4 style="color: #FFD700; margin-bottom: 10px; font-family: 'Cinzel', serif;">üìä Progress</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                        <div style="color: #aaa;">Total Honor Earned:</div>
                        <div style="color: #ffd700; text-align: right;" id="total-honor-display">0</div>
                        
                        <div style="color: #aaa;">Games Played:</div>
                        <div style="color: #ffd700; text-align: right;" id="total-games-display">0</div>
                        
                        <div style="color: #aaa;">Win Rate:</div>
                        <div style="color: #ffd700; text-align: right;" id="total-winrate-display">0%</div>
                        
                        <div style="color: #aaa;">Current Conquest:</div>
                        <div style="color: #ff88ff; text-align: right;" id="total-conquest-display">0</div>
                    </div>
                </div>
                
                <!-- Danger Zone -->
                <div style="background: rgba(150, 0, 0, 0.2); border: 1px solid #f44336; border-radius: 4px; padding: 15px;">
                    <h4 style="color: #f44336; margin-bottom: 10px; font-family: 'Cinzel', serif;">‚ö†Ô∏è Danger Zone</h4>
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 12px;">
                        This action is permanent and cannot be undone!
                    </div>
                    <div id="settings-reset-container" style="width: 100%;">
                        <button class="buy-button" id="settings-reset-all" style="width: 100%; background: linear-gradient(180deg, #f44336, #c62828); position: relative; z-index: 1000; cursor: pointer; pointer-events: auto !important;">
                            üóëÔ∏è RESET ALL PROGRESS
                        </button>
                    </div>
                </div>
                
                <!-- Info Section -->
                <div style="background: rgba(50, 50, 50, 0.5); border: 1px solid #666; border-radius: 4px; padding: 12px;">
                    <div style="font-size: 11px; color: #888; text-align: center;">
                        <div style="margin-bottom: 6px;">
                            <strong style="color: #ffd700;">Arena Legends: Idle Champion</strong>
                        </div>
                        <div>
                            A high-fidelity 3D idle game inspired by WoW Arena
                        </div>
                        <div style="margin-top: 6px; color: #555;">
                            Built with Three.js ‚Ä¢ ESM Modules ‚Ä¢ Zero Build
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Match Review Modal -->
    <div id="match-review-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 250; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 700px;">
            <div class="shop-header">
                <div class="shop-title">üìä Match Review</div>
                <button class="shop-close" id="match-review-close-btn">√ó</button>
            </div>
            
            <div id="match-review-content" style="padding: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                    <div id="review-result" style="font-size: 32px; font-family: 'Cinzel', serif; font-weight: bold;">VICTORY</div>
                    <div id="review-timer" style="font-size: 24px; color: #aaa;">Time: 24.5s</div>
                </div>

                <div style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 4px; border: 1px solid #8e6d3f; margin-bottom: 20px;">
                    <h4 style="color: #ffd700; font-family: 'Cinzel', serif; margin-bottom: 10px; border-bottom: 1px solid #4a3a25; padding-bottom: 5px;">Advanced Stats</h4>
                    <div class="advanced-stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div>Damage Dealt: <span id="review-damage-dealt" style="color: #ff6666; float: right;">0</span></div>
                        <div>Healing Done: <span id="review-healing-done" style="color: #66ff66; float: right;">0</span></div>
                        <div>CC Chains: <span id="review-cc-chains" style="color: #ffaa00; float: right;">0</span></div>
                        <div>Damage while in LoS: <span id="review-los-damage" style="color: #aaa; float: right;">0</span></div>
                        <div>Mana Efficiency: <span id="review-mana-eff" style="color: #4a90e2; float: right;">0%</span></div>
                        <div>Damage Absorbed: <span id="review-absorbed" style="color: #ffffff; float: right;">0</span></div>
                        <div>Avg Response Time: <span id="review-response" style="color: #aaa; float: right;">0.4s</span></div>
                        <div>Buff Uptime: <span id="review-buff-uptime" style="color: #ffd700; float: right;">0%</span></div>
                    </div>
                    <div id="review-pet-stats" style="display: none; margin-top: 10px; padding-top: 8px; border-top: 1px solid #4a3a25;">
                        <div style="font-size: 12px; color: #abd473; margin-bottom: 4px;">üê∫ Pet Contribution</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 13px;">
                            <div>Pet Damage: <span id="review-pet-damage" style="color: #ff9966; float: right;">0</span></div>
                            <div>Pet Kills: <span id="review-pet-kills" style="color: #ff6666; float: right;">0</span></div>
                            <div>Dmg Avoided: <span id="review-pet-avoided" style="color: #66ccff; float: right;">0</span></div>
                            <div>Dmg Blocked: <span id="review-pet-blocked" style="color: #aaaaaa; float: right;">0</span></div>
                            <div id="review-pet-redirect-row" style="display:none;">Soul Link Shared: <span id="review-pet-redirected" style="color: #b070dd; float: right;">0</span></div>
                            <div>Highest Hit: <span id="review-pet-highest" style="color: #ffcc00; float: right;">0</span></div>
                        </div>
                    </div>
                </div>

                <div id="review-prestige-container" style="display: none; text-align: center; margin-bottom: 15px;">
                    <button class="prestige-button" id="review-prestige-btn" style="width: 100%; background: linear-gradient(180deg, #ffd700, #b8860b); color: #000; font-size: 18px; padding: 14px 20px; border: 2px solid #fff; animation: shopPulse 2s ease-in-out infinite;">
                        üèÜ Start New Season (Gladiator Prestige!)
                    </button>
                    <div style="font-size: 11px; color: #ffd700; margin-top: 8px;">
                        Earn a Talent Point + 500 Conquest. Rating & Upgrades reset. Career Talents persist!
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="prestige-button" id="match-review-continue-btn" style="width: 200px;">Continue</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Honor Shop Modal -->
    <div id="honor-shop-modal">
        <div class="shop-container">
            <div class="shop-header">
                <div class="shop-title">‚öîÔ∏è Honor Vendor</div>
                <button class="shop-close" id="shop-close-btn">√ó</button>
            </div>
            
            <div class="shop-tabs">
                <button class="shop-tab active" data-tab="weapons">Weapons</button>
                <button class="shop-tab" data-tab="armor">Armor</button>
                <button class="shop-tab" data-tab="trinkets">Trinkets</button>
                <button class="shop-tab" data-tab="enchants">Enchants</button>
            </div>
            
            <div id="gear-stats-summary" style="background: rgba(0,0,0,0.5); border: 1px solid #8e6d3f; border-radius: 4px; padding: 15px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; font-size: 13px;"></div>
            
            <div id="shop-items-container" class="shop-items-grid"></div>
        </div>
    </div>

    <!-- Season History Modal -->
    <div id="history-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 250; justify-content: center; align-items: center;">
        <div class="shop-container" style="max-width: 700px; width: 90%;">
            <div class="shop-header">
                <div class="shop-title">üìú Career & History</div>
                <button class="shop-close" id="history-close-btn">√ó</button>
            </div>
            
            <div style="padding: 20px;">
                <!-- Career Summary Section -->
                <div id="career-summary" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; background: rgba(255, 215, 0, 0.1); border: 1px solid #8e6d3f; border-radius: 4px; padding: 15px; text-align: center;">
                    <div>
                        <div style="font-size: 10px; color: #888; text-transform: uppercase;">Lifetime Wins</div>
                        <div id="career-wins" style="font-size: 24px; color: #ffd700; font-family: 'Cinzel', serif;">0</div>
                    </div>
                    <div>
                        <div style="font-size: 10px; color: #888; text-transform: uppercase;">Peak Rating</div>
                        <div id="career-peak" style="font-size: 24px; color: #00ffff; font-family: 'Cinzel', serif;">0</div>
                    </div>
                    <div>
                        <div style="font-size: 10px; color: #888; text-transform: uppercase;">Total Matches</div>
                        <div id="career-total" style="font-size: 24px; color: #ffffff; font-family: 'Cinzel', serif;">0</div>
                    </div>
                </div>

                <h4 style="color: #ffd700; font-family: 'Cinzel', serif; margin-bottom: 10px; border-bottom: 1px solid #4a3a25; padding-bottom: 5px;">Recent Match History</h4>
                <div id="history-container" style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto; padding-right: 5px;">
                    <!-- History entries -->
                </div>
            </div>
        </div>
    </div>

    <!-- Career Talent Modal -->
    <div id="talent-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 250; justify-content: center; align-items: center;">
        <div class="ui-panel" style="width: 90%; max-width: 700px; max-height: 90%; overflow-y: auto; background: #1a1a1a; border: 3px solid #ffd700; padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ffd700; padding-bottom: 10px; flex-wrap: wrap; gap: 10px;">
                <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                    <h2 style="margin: 0; color: #ffd700; font-family: 'Cinzel', serif; font-size: 1.5rem;">üåü Career Talent Tree</h2>
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 5px 15px; border-radius: 20px; border: 1px solid #ffd700; color: #ffd700; font-weight: bold; font-size: 0.9rem;">
                        Points Available: <span id="talent-points-available">0</span>
                    </div>
                </div>
                <button id="talent-close-btn" style="background: none; border: none; color: #ffd700; font-size: 28px; cursor: pointer;">&times;</button>
            </div>
            
            <p style="color: #aaa; font-style: italic; margin-bottom: 25px; font-size: 12px;">
                * Talent points are earned by Prestiging after reaching Gladiator rank (2400+ Rating). Bonuses apply to your entire team across all seasons.
            </p>

            <div id="talent-tree-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                <!-- Talent categories will be injected here -->
            </div>

            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #333; text-align: center;">
                <div style="color: #888; font-size: 12px; margin-bottom: 10px;">Current Prestige Level: <span id="talent-prestige-level" style="color: #ffd700;">0</span></div>
            </div>
        </div>
    </div>

    <div id="ui-overlay">
        <!-- Top Resource Bar -->
        <div id="top-bar" class="ui-panel">
            <div class="resource" style="cursor: pointer; border: 1px solid #8e6d3f; padding: 2px 8px; border-radius: 4px;" id="camera-toggle-btn">
                üìπ Cam: Standard
            </div>
            <div class="resource" style="cursor: pointer; border: 1px solid #8e6d3f; padding: 2px 8px; border-radius: 4px; display: none;" id="camera-next-btn">
                ‚è≠Ô∏è Next
            </div>
            <div class="resource" style="cursor: pointer;" id="mute-toggle-btn">
                üîä
            </div>
            <div class="resource">
                <img src="https://rosebud.ai/assets/honor-token.webp?Aozw" class="resource-icon-img" alt="Honor">
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <span style="font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px;">Honor</span>
                    <span id="honor-amount">0</span>
                </div>
            </div>
            <div class="resource" style="border: 1px solid #9966ff; padding: 0 8px; border-radius: 3px;">
                <span style="color: #ff00ff;">‚öîÔ∏è</span>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <span style="font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px;">Conquest</span>
                    <div>
                        <span id="conquest-amount" style="color: #ff88ff;">0</span>
                        <span style="color: #888; font-size: 11px;">/ <span id="conquest-cap">1000</span></span>
                    </div>
                </div>
            </div>
            <div class="resource">
                <img src="https://rosebud.ai/assets/arena-rating-icon.webp?oDg7" class="resource-icon-img" alt="Arena Rating">
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <span style="font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px;">Arena Rating</span>
                    <span id="arena-rating-amount">0</span>
                </div>
            </div>
            <div class="resource" style="border: 2px solid #ffd700; background: rgba(255, 215, 0, 0.1);">
                <span style="font-size: 20px;">üèÜ</span>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <span style="font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px;">Title</span>
                    <span id="arena-title" style="color: #ffd700; font-weight: bold;">Combatant</span>
                </div>
            </div>
        </div>

        <!-- Middle Section -->
        <div id="side-panels">
            <!-- Stats Panel -->
            <div id="stats-panel" class="ui-panel">
                <h3>‚öîÔ∏è Season Stats</h3>
                <div class="stat-row">
                    <span class="stat-label">Wins</span>
                    <span class="stat-value" id="wins">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Losses</span>
                    <span class="stat-value" id="losses">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Win Rate</span>
                    <span class="stat-value" id="winrate">0%</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #4a3a25; padding-top: 8px; margin-top: 8px;">
                    <span class="stat-label">üî• Win Streak</span>
                    <span class="stat-value" id="win-streak" style="color: #ff8800;">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üèÖ Best Streak</span>
                    <span class="stat-value" id="best-streak">0</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #4a3a25; padding-top: 8px; margin-top: 8px;">
                    <span class="stat-label">Honor/Win</span>
                    <span class="stat-value" id="honor-per-win">250</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Match Speed</span>
                    <span class="stat-value" id="match-speed">1.0x</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #4a3a25; padding-top: 8px; margin-top: 8px;">
                    <span class="stat-label">‚öîÔ∏è Gear Equipped</span>
                    <span class="stat-value" id="gear-count" style="color: #888;">0/9</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #4a3a25; padding-top: 8px;">
                    <span class="stat-label">üìú Team Doctrine</span>
                    <select id="strategy-preset" style="background: #221a11; color: #ffd700; border: 1px solid #8e6d3f; font-family: 'Cinzel', serif; font-size: 11px; padding: 2px 5px; border-radius: 3px; cursor: pointer; outline: none;">
                        <option value="balanced">Balanced</option>
                        <option value="tunnel_healer">Tunnel Healer</option>
                        <option value="tunnel_dps">Tunnel DPS</option>
                        <option value="split_pressure">Split Pressure</option>
                    </select>
                </div>
                <button class="prestige-button" id="honor-shop-btn" style="width: 100%; margin-top: 15px; padding: 10px; font-size: 14px;">
                    üõ°Ô∏è Honor Shop
                </button>
                <button class="prestige-button" id="roster-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: linear-gradient(180deg, #4a90e2, #2a70c2); border-color: #00ffff;">
                    üë• Manage Roster
                </button>
                <button class="prestige-button" id="conquest-shop-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: linear-gradient(180deg, #9966ff, #6633cc); border-color: #ff00ff;">
                    ‚öîÔ∏è Conquest Vendor
                </button>
                <button class="prestige-button" id="talent-tree-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: linear-gradient(180deg, #ffd700, #b8860b); border-color: #ffd700; color: #000; font-weight: bold;">
                    üåü Career Talents
                </button>
                <button class="prestige-button" id="settings-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: linear-gradient(180deg, #555, #333); border-color: #888;">
                    ‚öôÔ∏è Settings
                </button>
                <button class="prestige-button" id="history-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: linear-gradient(180deg, #6b4e31, #4a341e); border-color: #8e6d3f;">
                    üìú Season History
                </button>
                <button class="prestige-button" id="prestige-btn" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px; background: #444;">
                    Start New Season (Reach 2400 Rating)
                </button>
                <button class="forfeit-button" id="forfeit-btn">
                    üè≥Ô∏è Forfeit Round
                </button>
            </div>

            <!-- Upgrades Panel -->
            <div id="upgrades-panel" class="ui-panel">
                <h3>‚ö° Upgrades</h3>
                <div style="font-size: 11px; color: #888; margin-bottom: 8px; text-align: center;">Purchase with Honor</div>
                <div id="upgrades-container"></div>
            </div>
        </div>

        <!-- Bottom Area -->
        <div id="bottom-area">
            <div class="ui-panel match-summary-panel" id="match-hud-panel">
                <div id="mobile-toggle-hud">‚ñº MINIMIZE HUD</div>
                <div class="match-status-header">Match <span id="match-number">1</span></div>
                <div id="match-timer-container" style="text-align: center; color: #bfa07a; margin-bottom: 15px; font-size: 14px;">
                    Time: <span id="match-timer">0.0</span>s
                </div>
                <div class="team-health-container">
                    <div class="team-box">
                        <div class="team-name" style="color: #4a90e2;">Allies</div>
                        <div class="team-health" id="team-health"></div>
                    </div>
                    <div class="team-box">
                        <div class="team-name" style="color: #e24a4a;">Enemies</div>
                        <div class="team-health" id="enemy-health"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.169.0",
            "three/addons/": "https://esm.sh/three@0.169.0/examples/jsm/",
            "tone": "https://esm.sh/tone@14.7.77"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as Tone from 'tone';

        // ============================================
        // AUDIO SYSTEM (Tone.js)
        // ============================================
        const soundManager = {
            initialized: false,
            isMuted: false, // Start unmuted to match hearing sound
            masterVolume: 0.5,
            
            // Synths
            meleeSynth: null,
            magicSynth: null,
            healSynth: null,
            ccSynth: null,
            uiSynth: null,

            lastScheduledTimes: {},

            getSafeTime(synthKey, offset = 0.05) {
                const now = Tone.now() + offset;
                const lastTime = this.lastScheduledTimes[synthKey] || 0;
                // Ensure time is strictly increasing
                const safeTime = Math.max(now, lastTime + 0.001);
                this.lastScheduledTimes[synthKey] = safeTime;
                return safeTime;
            },

            async init() {
                if (this.initialized) return;
                try {
                    await Tone.start();
                    
                    // Create all synths first
                    // Melee Synth - Crunchy noise burst
                    this.meleeSynth = new Tone.NoiseSynth({
                        noise: { type: 'white' },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
                    }).toDestination();
                    this.meleeSynth.volume.value = -12;

                    // Magic Synth - PolySynth for shimmering sounds
                    this.magicSynth = new Tone.PolySynth(Tone.FMSynth, {
                        harmonicity: 3,
                        modulationIndex: 10,
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                    this.magicSynth.volume.value = -18;

                    // Heal Synth - PolySynth for soft chords
                    this.healSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.2, decay: 0.1, sustain: 1, release: 0.8 }
                    }).toDestination();
                    this.healSynth.volume.value = -20;

                    // CC Synth - PolySynth with MonoSynth parameters for safety
                    this.ccSynth = new Tone.PolySynth(Tone.MonoSynth, {
                        oscillator: { type: 'sawtooth' },
                        filter: { Q: 6, type: 'lowpass', rolloff: -24 },
                        envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 0.8 },
                        filterEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.7, baseFrequency: 200, octaves: 4 }
                    }).toDestination();
                    this.ccSynth.volume.value = -15;

                    // UI Synth - MembraneSynth for clicks
                    this.uiSynth = new Tone.MembraneSynth().toDestination();
                    this.uiSynth.volume.value = -15;

                    this.initialized = true;
                    
                    // FORCE initial mute/volume state after initialization
                    this.setMute(this.isMuted);
                    this.setVolume(this.masterVolume);
                    
                    console.log('üîä Audio System Initialized. Muted:', this.isMuted);
                } catch (e) {
                    console.error('Audio initialization failed:', e);
                }
            },

            setMute(muted) {
                this.isMuted = muted;
                if (this.initialized) {
                    Tone.Destination.mute = muted;
                    // Fallback: also set volume to -Infinity if muted to be absolutely sure
                    if (muted) {
                        Tone.Destination.volume.value = -Infinity;
                    } else {
                        Tone.Destination.volume.value = Tone.gainToDb(this.masterVolume);
                    }
                }
                const muteBtn = document.getElementById('mute-toggle-btn');
                const settingsMuteBtn = document.getElementById('settings-mute-btn');
                if (muteBtn) {
                    muteBtn.textContent = muted ? 'üîá' : 'üîä';
                }
                if (settingsMuteBtn) {
                    settingsMuteBtn.textContent = muted ? 'üîá' : 'üîä';
                }
            },

            toggleMute() {
                if (!this.initialized) {
                    this.init().then(() => {
                        this.setMute(!this.isMuted);
                    });
                } else {
                    this.setMute(!this.isMuted);
                }
            },

            setVolume(value) {
                this.masterVolume = value;
                if (this.initialized) {
                    Tone.Destination.volume.value = Tone.gainToDb(value);
                }
            },

            playMelee() {
                if (!this.initialized) return;
                this.meleeSynth.triggerAttackRelease('16n', this.getSafeTime('melee'));
            },

            playMagic(note = 'C4') {
                if (!this.initialized) return;
                this.magicSynth.triggerAttackRelease(note, '8n', this.getSafeTime('magic'));
            },

            playHeal() {
                if (!this.initialized) return;
                this.healSynth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n', this.getSafeTime('heal'));
            },

            playCC() {
                if (!this.initialized) return;
                this.ccSynth.triggerAttackRelease('G2', '4n', this.getSafeTime('cc'));
            },

            playClick() {
                if (!this.initialized) return;
                this.uiSynth.triggerAttackRelease('C2', '32n', this.getSafeTime('ui'));
            },

            playWin() {
                if (!this.initialized) return;
                const startTime = this.getSafeTime('win', 0);
                this.healSynth.triggerAttackRelease('C4', '8n', startTime);
                this.healSynth.triggerAttackRelease('E4', '8n', startTime + 0.1);
                this.healSynth.triggerAttackRelease('G4', '8n', startTime + 0.2);
                this.healSynth.triggerAttackRelease('C5', '4n', startTime + 0.3);
                this.lastScheduledTimes['win'] = startTime + 0.3;
            },

            playLoss() {
                if (!this.initialized) return;
                const startTime = this.getSafeTime('loss', 0);
                this.ccSynth.triggerAttackRelease('C2', '4n', startTime);
                this.ccSynth.triggerAttackRelease('G1', '2n', startTime + 0.2);
                this.lastScheduledTimes['loss'] = startTime + 0.2;
            },

            playAbility(ability) {
                if (!this.initialized || !ability) return;
                
                if (ability.type === 'heal') {
                    this.playHeal();
                } else if (ability.type === 'cc') {
                    this.playCC();
                } else if (ability.type === 'damage') {
                    // Decide based on melee vs ranged (role)
                    if (ability.castTime || ability.name.includes('bolt') || ability.name.includes('Shot')) {
                        this.playMagic('E4');
                    } else {
                        this.playMelee();
                    }
                } else if (ability.type === 'defensive' || ability.type === 'offensive') {
                    this.playMagic('G3');
                }
            }
        };

        // Initialize audio on first click
        window.addEventListener('mousedown', () => soundManager.init(), { once: true });
        window.addEventListener('keydown', () => soundManager.init(), { once: true });

        // ============================================
        // GLTF MODEL LOADER SYSTEM
        // ============================================
        /*
         * üéÆ GLTF MODEL LOADING GUIDE
         * 
         * This game now supports external 3D models! Here's how to use them:
         * 
         * 1Ô∏è‚É£ PREPARE YOUR MODEL:
         *    - Export as .glb (recommended) or .gltf format
         *    - Optimize geometry (keep poly count reasonable)
         *    - Bake textures into the file
         *    - Name animations clearly: 'idle', 'walk', 'attack', 'cast', etc.
         * 
         * 2Ô∏è‚É£ UPLOAD TO ROSEBUD:
         *    - Drag & drop your .glb file into the asset panel
         *    - Copy the URL (e.g., https://rosebud.ai/assets/model.glb?xxxxx)
         * 
         * 3Ô∏è‚É£ ADD TO MODEL_URLS:
         *    - Find the MODEL_URLS object below
         *    - Add your model: modelName: 'your-url-here'
         * 
         * 4Ô∏è‚É£ USE IN CODE:
         *    - Basic: await loadGLTFModel(MODEL_URLS.modelName)
         *    - Advanced: await replaceCharacterWithGLTF(character, MODEL_URLS.modelName)
         *    - Test: testLoadModel('modelName') in console
         * 
         * üé¨ ANIMATION SUPPORT:
         *    - Animations are automatically detected and set up
         *    - Use standard names for auto-play: 'idle', 'walk', 'attack'
         *    - Access via: character.userData.mixer and character.userData.animations
         * 
         * üì¶ FEATURES:
         *    ‚úÖ Automatic caching for performance
         *    ‚úÖ Shadow support (cast & receive)
         *    ‚úÖ Animation mixer integration
         *    ‚úÖ Progress logging
         *    ‚úÖ Error handling
         * 
         * üí° CONSOLE COMMANDS:
         *    - testLoadModel('modelName') - Load and display a model
         *    - modelCache - View cached models
         *    - MODEL_URLS - View available model URLs
         */
        const gltfLoader = new GLTFLoader();
        const modelCache = new Map(); // Cache loaded models for reuse

        /**
         * Load a GLTF/GLB model from a URL
         * @param {string} url - The URL of the .glb or .gltf file
         * @param {Object} options - Loading options
         * @param {number} options.scale - Scale factor (default: 1)
         * @param {boolean} options.cache - Whether to cache the model (default: true)
         * @param {THREE.Vector3} options.position - Initial position
         * @param {THREE.Euler} options.rotation - Initial rotation
         * @returns {Promise<THREE.Group>} The loaded model group
         */
        async function loadGLTFModel(url, options = {}) {
            const {
                scale = 1,
                cache = true,
                position = new THREE.Vector3(0, 0, 0),
                rotation = new THREE.Euler(0, 0, 0)
            } = options;

            // Check cache first
            if (cache && modelCache.has(url)) {
                console.log(`‚úÖ Loading model from cache: ${url}`);
                const cachedModel = modelCache.get(url);
                const clone = cachedModel.scene.clone();
                clone.scale.set(scale, scale, scale);
                clone.position.copy(position);
                clone.rotation.copy(rotation);
                return clone;
            }

            return new Promise((resolve, reject) => {
                console.log(`üì¶ Loading GLTF model: ${url}`);
                
                gltfLoader.load(
                    url,
                    (gltf) => {
                        console.log(`‚úÖ Model loaded successfully: ${url}`);
                        
                        // Cache the original
                        if (cache) {
                            modelCache.set(url, gltf);
                        }

                        // Clone for use
                        const model = gltf.scene.clone();
                        model.scale.set(scale, scale, scale);
                        model.position.copy(position);
                        model.rotation.copy(rotation);

                        // Traverse and setup materials
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Ensure materials are properly set up
                                if (child.material) {
                                    child.material.side = THREE.FrontSide;
                                }
                            }
                        });

                        // Store animations if present
                        if (gltf.animations && gltf.animations.length > 0) {
                            model.userData.animations = gltf.animations;
                            model.userData.mixer = new THREE.AnimationMixer(model);
                            console.log(`üé¨ Found ${gltf.animations.length} animation(s) in model`);
                        }

                        resolve(model);
                    },
                    (progress) => {
                        const percentComplete = (progress.loaded / progress.total) * 100;
                        console.log(`‚è≥ Loading model: ${percentComplete.toFixed(0)}%`);
                    },
                    (error) => {
                        console.error(`‚ùå Error loading model: ${url}`, error);
                        reject(error);
                    }
                );
            });
        }

        /**
         * Replace a character's procedural model with a GLTF model
         * @param {THREE.Group} character - The character object to replace
         * @param {string} modelUrl - URL to the GLTF/GLB file
         * @param {Object} options - Replacement options
         */
        async function loadCharacterWithAnimations(modelUrl, animUrls, options = {}) {
            const { scale = 2.2, yOffset = 0 } = options;
            
            try {
                const animUrlArray = Array.isArray(animUrls) ? animUrls : [animUrls];
                
                // Helper to load with internal caching
                const loadWithCache = async (url) => {
                    if (modelCache.has(url)) return modelCache.get(url);
                    return new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => {
                            modelCache.set(url, gltf);
                            resolve(gltf);
                        }, undefined, reject);
                    });
                };

                const [modelGltf, ...animGltfs] = await Promise.all([
                    loadWithCache(modelUrl),
                    ...animUrlArray.map(url => loadWithCache(url))
                ]);

                // We MUST clone the scene so we can have multiple instances
                const model = modelGltf.scene.clone();
                model.scale.set(scale, scale, scale);
                
                // Find the skeleton root for animation retargeting
                let skeletonRoot = null;
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.side = THREE.FrontSide;
                            child.material.needsUpdate = true;
                        }
                        
                        // Try to identify weapon mesh
                        const name = child.name.toLowerCase();
                        if (name.includes('weapon') || name.includes('sword') || name.includes('axe') || 
                            name.includes('staff') || name.includes('hammer') || name.includes('mace') || 
                            name.includes('blade') || name.includes('spear') || name.includes('glaive') || 
                            name.includes('dagger') || name.includes('bow') || name.includes('shield')) {
                            child.userData.isWeapon = true;
                            console.log(`üó°Ô∏è Identified weapon mesh: ${child.name}`);
                        }
                    }
                    if (child.isBone && !skeletonRoot) {
                        skeletonRoot = child;
                    }
                });

                // Positioning logic
                const box = new THREE.Box3().setFromObject(model);
                model.position.y = -box.min.y + yOffset;

                // Create mixer on the model scene
                const mixer = new THREE.AnimationMixer(model);
                
                // Collect all animations from the model file and all animation files
                const allClips = [
                    ...(modelGltf.animations || [])
                ];
                
                animGltfs.forEach((gltf, gltfIndex) => {
                    if (gltf.animations) {
                        // Tag animations with their source file for better detection
                        gltf.animations.forEach(clip => {
                            clip.userData = clip.userData || {};
                            clip.userData.sourceFileIndex = gltfIndex;
                            clip.userData.isRunningFile = animUrlArray[gltfIndex].includes('Running');
                        });
                        allClips.push(...gltf.animations);
                    }
                });
                
                console.log(`üé¨ Found ${allClips.length} animation clips total`);
                console.log(`üìã Animation names: ${allClips.map(c => c.name).join(', ')}`);
                const actions = {};
                
                // Create action for each clip
                allClips.forEach((clip, index) => {
                    console.log(`  üìº Clip #${index}: "${clip.name}"`);
                    
                    // SMART RETARGETING: Strip prefixes from tracks
                    let retargetCount = 0;
                    clip.tracks.forEach(track => {
                        const parts = track.name.split('.');
                        const bonePath = parts[0];
                        const property = parts.slice(1).join('.');
                        
                        if (bonePath.includes(':')) {
                            track.name = bonePath.split(':').pop() + '.' + property;
                            retargetCount++;
                        } else if (bonePath.includes('|')) {
                            track.name = bonePath.split('|').pop() + '.' + property;
                            retargetCount++;
                        }
                    });
                    if (retargetCount > 0) {
                        console.log(`     üîß Retargeted ${retargetCount} tracks`);
                    }

                    const name = clip.name.toLowerCase();
                    const action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    
                    // Map ALL animations with priority - check multiple patterns
                    if (name.includes('idle') || name.includes('stand') || name === 'animation') {
                        actions['idle'] = action;
                        console.log(`     ‚úÖ Mapped as IDLE`);
                    }
                    if (name.includes('walk')) {
                        actions['walk'] = action;
                        console.log(`     ‚úÖ Mapped as WALK`);
                    }
                    // Check for running animation - be aggressive with pattern matching
                    if (name.includes('run') || name.includes('jog') || name.includes('sprint') || 
                        name.includes('running') || clip.name.toLowerCase().includes('running')) {
                        actions['run'] = action;
                        console.log(`     ‚úÖ Mapped as RUN`);
                    }
                    
                    // CRITICAL: If this clip came from the "Running" animation file, it's the run animation!
                    if (clip.userData && clip.userData.isRunningFile) {
                        actions['run'] = action;
                        console.log(`     ‚ö° MAPPED as RUN (from Running animation file)`);
                    }
                    
                    if (name.includes('cast') || name.includes('spell')) {
                        actions['cast'] = action;
                        console.log(`     ‚úÖ Mapped as CAST`);
                    }
                    if (name.includes('spin') || name.includes('360') || name.includes('power') || name.includes('attack') || name.includes('melee')) {
                        actions['attack'] = action;
                        console.log(`     ‚úÖ Mapped as ATTACK`);
                    }
                    
                    // Store ALL clips by their original name
                    actions[clip.name] = action;
                    actions[name] = action;
                });
                
                // Special handling: If we have 3+ animations but no 'run', assume the 3rd one is run
                if (!actions['run'] && allClips.length >= 3) {
                    const runClip = allClips[2];
                    actions['run'] = mixer.clipAction(runClip);
                    console.log(`  ‚ö° Auto-assigning clip #3 "${runClip.name}" as RUN animation`);
                }

                // SIMPLE SOLUTION: Just use whatever animation we loaded as the run animation
                // The file is called "Running_Animation" so whatever is in it IS the run animation
                if (!actions['run'] && allClips.length > 0) {
                    // Use the LAST animation loaded (which will be from the running file)
                    actions['run'] = mixer.clipAction(allClips[allClips.length - 1]);
                    console.log(`  üî• FORCING last clip "${allClips[allClips.length - 1].name}" as RUN`);
                }
                
                // Fallbacks for other animations
                if (!actions['idle'] && allClips.length > 0) {
                    actions['idle'] = mixer.clipAction(allClips[0]);
                }
                if (!actions['walk']) {
                    actions['walk'] = actions['run'] || actions['idle'];
                }
                if (!actions['cast']) {
                    actions['cast'] = actions['idle'];
                }
                if (!actions['attack']) {
                    actions['attack'] = actions['idle'];
                }

                // Explicitly start idle
                if (actions['idle']) {
                    actions['idle'].play();
                }

                model.userData.mixer = mixer;
                model.userData.actions = actions;
                model.userData.allClipNames = allClips.map(c => c.name); // Store for debugging
                
                return model;
            } catch (error) {
                console.error('‚ùå Failed to load character model:', error);
                throw error;
            }
        }

        async function replaceCharacterWithGLTF(character, modelUrl, options = {}) {
            try {
                const model = await loadGLTFModel(modelUrl, {
                    scale: options.scale || 1,
                    cache: true
                });

                // Clear existing character mesh (keep userData)
                const userData = character.userData;
                character.clear();
                character.userData = userData;

                // Add the loaded model
                character.add(model);

                // Setup animations if available
                if (model.userData.mixer) {
                    character.userData.mixer = model.userData.mixer;
                    character.userData.animations = model.userData.animations;
                    
                    // Play idle animation by default if exists
                    const idleAnim = model.userData.animations.find(a => 
                        a.name.toLowerCase().includes('idle')
                    );
                    if (idleAnim) {
                        const action = character.userData.mixer.clipAction(idleAnim);
                        action.play();
                    }
                }

                console.log(`‚úÖ Replaced character with GLTF model: ${modelUrl}`);
                return model;
            } catch (error) {
                console.error('Failed to replace character with GLTF:', error);
                throw error;
            }
        }

        /**
         * Model URL registry - Add your uploaded model URLs here
         * 
         * üìñ COMPLETE WORKFLOW EXAMPLE:
         * 
         * 1Ô∏è‚É£ CREATE/GET MODEL:
         *    - Use Blender, Maya, or download from Sketchfab/TurboSquid
         *    - Export as .glb (File > Export > glTF 2.0 > Format: glTF Binary)
         *    - Make sure model is facing forward (Z-axis)
         * 
         * 2Ô∏è‚É£ UPLOAD TO ROSEBUD:
         *    - Open the Assets panel (right side of editor)
         *    - Drag & drop your .glb file
         *    - Copy the URL: https://rosebud.ai/assets/warrior.glb?abc123
         * 
         * 3Ô∏è‚É£ ADD TO MODEL_URLS:
         *    const MODEL_URLS = {
         *        myWarrior: 'https://rosebud.ai/assets/warrior.glb?abc123',
         *    };
         * 
         * 4Ô∏è‚É£ TEST IN CONSOLE:
         *    gameDebug.testLoadModel('myWarrior')
         *    // Check if it loads, scale, position, animations
         * 
         * 5Ô∏è‚É£ USE IN GAME:
         *    Option A: Replace all warriors:
         *      gameDebug.replaceClassWithGLTF('warrior', 'myWarrior', { scale: 1.5 })
         *    
         *    Option B: Replace specific character:
         *      const char = gameState.team[0];
         *      await replaceCharacterWithGLTF(char, MODEL_URLS.myWarrior, { scale: 1.5 })
         * 
         * üí° TIPS:
         * - Optimize models: < 1MB for characters, < 5MB for environments
         * - Include animations with clear names: 'idle', 'walk', 'attack', 'cast', 'death'
         * - Test scale: models might be too big/small (adjust with scale option)
         * - Check orientation: model should face forward initially
         * - Models auto-cache on first load for instant reuse
         * 
         * üé¨ ANIMATION TIPS:
         * - Animations are auto-detected and set up
         * - 'idle' animation plays automatically if found
         * - Access all animations: character.userData.animations
         * - Animation mixer updates automatically in game loop
         */
        const MODEL_URLS = {
            warrior: 'https://rosebud.ai/assets/Warrior - LOW.glb?4j9H',
            death_knight: 'https://rosebud.ai/assets/Death Knight - LOW.glb?1CWY',
            priest: 'https://rosebud.ai/assets/Troll Priest - LOW.glb?rP0O',
            shaman: 'https://rosebud.ai/assets/Taruen Shaman - LOW.glb?tRv9',
            warlock: 'https://rosebud.ai/assets/Undead Warlock - LOW.glb?bNcA',
            druid: 'https://rosebud.ai/assets/Druid - LOW.glb?l3cR',
            mage: 'https://rosebud.ai/assets/Mage - LOW.glb?F4YI',
            rogue: 'https://rosebud.ai/assets/Rogue - LOW.glb?0tRn',
            paladin: 'https://rosebud.ai/assets/Blood Elf Paladin - LOW.glb?Zbnq',
            hunter: 'https://rosebud.ai/assets/Troll Hunter - LOW.glb?uW0H',
            demon_hunter: 'https://rosebud.ai/assets/Demon Hunter - LOW.glb?bYkl',
            monk: 'https://rosebud.ai/assets/Monk - LOW.glb?R7Pa',
            pillar: 'https://rosebud.ai/assets/Small Pillar - LOW.glb?TRCM',
            pillarLarge: 'https://rosebud.ai/assets/Large Pillar - LOW.glb?Lt7T',
            raptor: 'https://rosebud.ai/assets/Raptor - LOW.glb?pRbf',
            felhunter: 'https://rosebud.ai/assets/Felhunter - LOW.glb?XtfR'
        };

        /**
         * Example usage function - Load and add a model to the scene
         * Call this to test your uploaded models
         * 
         * @example
         * // In browser console:
         * gameDebug.testLoadModel('warrior')
         */
        async function testLoadModel(modelKey) {
            const url = MODEL_URLS[modelKey];
            if (!url) {
                console.error(`Model key "${modelKey}" not found in MODEL_URLS`);
                console.log('Available models:', Object.keys(MODEL_URLS));
                return;
            }

            try {
                const model = await loadGLTFModel(url, {
                    scale: 1,
                    position: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Euler(0, 0, 0)
                });

                scene.add(model);
                console.log(`‚úÖ Test model added to scene: ${modelKey}`);
                
                // If it has animations, play them
                if (model.userData.mixer && model.userData.animations.length > 0) {
                    console.log(`üé¨ Available animations:`, model.userData.animations.map(a => a.name).join(', '));
                    
                    // Auto-play first animation
                    const firstAnim = model.userData.animations[0];
                    const action = model.userData.mixer.clipAction(firstAnim);
                    action.play();
                    console.log(`‚ñ∂Ô∏è Playing animation: ${firstAnim.name}`);
                }

                return model;
            } catch (error) {
                console.error(`Failed to load test model: ${modelKey}`, error);
            }
        }

        /**
         * Replace all characters of a specific class with a GLTF model
         * 
         * @example
         * // Replace all warriors with your custom warrior model
         * gameDebug.replaceClassWithGLTF('warrior', 'warrior', { scale: 1.5 })
         */
        async function replaceClassWithGLTF(className, modelKey, options = {}) {
            const url = MODEL_URLS[modelKey];
            if (!url) {
                console.error(`Model key "${modelKey}" not found in MODEL_URLS`);
                return;
            }

            const allCharacters = [...gameState.team, ...gameState.enemies];
            const matchingChars = allCharacters.filter(char => 
                char.userData.classType === className
            );

            if (matchingChars.length === 0) {
                console.warn(`No characters of class "${className}" found in current match`);
                return;
            }

            console.log(`üîÑ Replacing ${matchingChars.length} ${className}(s) with GLTF model...`);

            for (const char of matchingChars) {
                try {
                    await replaceCharacterWithGLTF(char, url, options);
                    console.log(`‚úÖ Replaced ${char.userData.name}`);
                } catch (error) {
                    console.error(`Failed to replace ${char.userData.name}:`, error);
                }
            }

            console.log(`‚ú® Replacement complete!`);
        }

        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            baseHealth: 1000,
            baseDamage: 50,
            baseHonorPerWin: 250,
            baseHonorPerLoss: 80,
            matchDuration: 15,
            prestigeRequirement: 2400 // Gladiator rating requirement
        };

        // Arena terrain config
        const TERRAIN = {
            groundLevel: 0,
            platformHeight: 0.6,
            platformRadius: 4,
            bridgeHeight: 5,
            bridgeWidth: 6,
            bridgeLength: 30,
            rampWidth: 6,
            rampLength: 12
        };

        const arenaObstacles = [];
        const collisionObjects = []; // For collision detection {x, z, radius}
        const floorMeshes = []; 
        const groundingRaycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        function getGroundHeight(x, z, currentCharY = 0) {
            if (floorMeshes.length > 0) {
                groundingRaycaster.set(new THREE.Vector3(x, 20, z), downVector);
                const intersects = groundingRaycaster.intersectObjects(floorMeshes, true);
                if (intersects.length > 0) return intersects[0].point.y;
            }
            const distFromCenter = Math.sqrt(x * x + z * z);
            if (distFromCenter <= TERRAIN.platformRadius) return TERRAIN.platformHeight;
            return TERRAIN.groundLevel;
        }


        // Level change logic for AI navigation
        function needsLevelChange(from, to) {
            const fromH = getGroundHeight(from.x, from.z);
            const toH = getGroundHeight(to.x, to.z);
            
            // If they are on different levels, AI might need to navigate
            return Math.abs(fromH - toH) > 0.4;
        }

        function getRampEntryPoint(fromPos, targetPos) {
            // In Nagrand, the platform is small and accessible from any side
            // We can just target the point on the edge of the platform
            const dir = new THREE.Vector3().subVectors(targetPos, fromPos).normalize();
            const edgePoint = dir.multiplyScalar(TERRAIN.platformRadius);
            return new THREE.Vector3(edgePoint.x, getGroundHeight(edgePoint.x, edgePoint.z), edgePoint.z);
        }

        // ============================================
        // GAME STATE
        // ============================================
        const CLASS_ICONS = {
            warrior: 'https://rosebud.ai/assets/warrior-icon.webp?kmKp',
            mage: 'https://rosebud.ai/assets/mage-icon.webp?fpHL',
            priest: 'https://rosebud.ai/assets/priest-icon.webp?zrd6',
            druid: 'https://rosebud.ai/assets/druid-icon.webp?IrUR',
            hunter: 'https://rosebud.ai/assets/hunter-icon.webp?GEAN',
            death_knight: 'https://rosebud.ai/assets/death-knight-icon.png.webp?rINu',
            paladin: 'https://rosebud.ai/assets/paladin-icon.png.webp?muEK',
            rogue: 'https://rosebud.ai/assets/rogue-icon.png.webp?kkGi',
            shaman: 'https://rosebud.ai/assets/shaman-icon.png.webp?eVOu',
            warlock: 'https://rosebud.ai/assets/warlock-icon.png.webp?DLmi',
            demon_hunter: 'https://rosebud.ai/assets/demon-hunter-icon.png.webp?BcV3',
            monk: 'https://rosebud.ai/assets/monk-icon.png.webp?ds4b'
        };

        const gameState = {
            honor: 0,
            conquestPoints: 0, // New currency for prestige items
            arenaRating: 0, // Start at 0 rating (like WoW)
            wins: 0,
            losses: 0,
            matchNumber: 0,
            matchTime: 0,
            inMatch: false,
            matchState: 'waiting', // 'waiting' or 'fighting'
            countdown: 5,
            
            // Progression systems
            conquestCap: 1000,
            arenaTitle: 'Combatant', // Title progression
            winStreak: 0,
            longestWinStreak: 0,
            totalKills: 0,
            lifetimeWins: 0,
            lifetimeLosses: 0,
            peakRating: 0,
            
            // Roster Management
            activeRoster: ['rogue', 'mage', 'priest'],
            unlockedClasses: [], // Will be populated from CLASSES on init
            teamDoctrine: 'balanced', // Strategy Preset
            
            // Arena features
            gateState: 'closed', // 'closed', 'opening', 'open'
            gateTimer: 0,
            
            // Upgrades
            upgrades: {
                damage: 0,
                health: 0,
                resilience: 0,
                healingPower: 0,
                ccDuration: 0,
                cooldownReduction: 0,
                critChance: 0,
                manaRegen: 0,
                honorBonus: 0,
                matchSpeed: 0
            },
            
            // PvP Gear System (WoW-style)
            equippedGear: {
                weapon: null,
                head: null,
                shoulders: null,
                chest: null,
                hands: null,
                legs: null,
                trinket1: null,
                trinket2: null,
                enchant: null // Added weapon enchantment slot
            },

            // Conquest Upgrades (Permanent bonuses)
            conquestUpgrades: {
                conquest_weapon_upgrade: 0,
                conquest_armor_upgrade: 0,
                conquest_versatility: 0,
                conquest_mastery: 0,
                conquest_tenacity: 0,
                conquest_swiftness: 0,
                conquest_honor_boost: 0,
                conquest_rating_protection: 0
            },

            // Prestige & Talent System
            prestigeLevel: 0,
            talentPoints: 0,
            talents: {}, // { talentId: level }
            
            // Current match
            team: [],
            enemies: [],
            
            // Performance Throttling (Heartbeats)
            PERF_STREAMS: {
                aiTick: 0,
                uiTick: 0,
                aiHeartbeat: 0.1,  // 10Hz for Strategic AI
                uiHeartbeat: 0.033, // 30Hz for Nameplate UI
            },
            
            // Match Tracking (for Match Review)
            matchStats: {
                damageDealt: 0,
                healingDone: 0,
                ccChains: 0,
                losDamage: 0,
                manaUsed: 0,
                responseTimes: [],
                lastCombatActionTime: 0 // Track last time any damage/heal occurred
            },
            seasonHistory: []
        };
        
        // ============================================
        // PVP GEAR SHOP (WoW Arena Gear Progression)
        // ============================================
        const PVP_GEAR = {
            // WEAPONS (Massive stat boost)
            weapons: [
                {
                    id: 'weapon_combatant',
                    name: 'Combatant\'s Blade',
                    slot: 'weapon',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 1500,
                    stats: { damage: 8, critChance: 2 },
                    ratingRequired: 0,
                    description: 'Basic honor weapon'
                },
                {
                    id: 'weapon_challenger',
                    name: 'Challenger\'s Greataxe',
                    slot: 'weapon',
                    tier: 'Challenger',
                    itemLevel: 392,
                    cost: 3500,
                    stats: { damage: 15, critChance: 3, ccDuration: 5 },
                    ratingRequired: 1600,
                    description: 'Requires 1600 rating'
                },
                {
                    id: 'weapon_rival',
                    name: 'Rival\'s War Glaive',
                    slot: 'weapon',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 6000,
                    stats: { damage: 25, critChance: 5, ccDuration: 8 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                },
                {
                    id: 'weapon_duelist',
                    name: 'Duelist\'s Warglaive',
                    slot: 'weapon',
                    tier: 'Duelist',
                    itemLevel: 418,
                    cost: 10000,
                    stats: { damage: 35, critChance: 7, ccDuration: 10, cooldownReduction: 5 },
                    ratingRequired: 2200,
                    description: 'Requires 2200 rating'
                },
                {
                    id: 'weapon_gladiator',
                    name: 'Gladiator\'s Redemption',
                    slot: 'weapon',
                    tier: 'Gladiator',
                    itemLevel: 431,
                    cost: 20000,
                    stats: { damage: 50, critChance: 10, ccDuration: 15, cooldownReduction: 10 },
                    ratingRequired: 2400,
                    description: 'Requires 2400 rating (Gladiator)'
                }
            ],
            
            // ARMOR PIECES
            armor: [
                // HEAD
                {
                    id: 'head_combatant',
                    name: 'Combatant\'s Helm',
                    slot: 'head',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 1000,
                    stats: { health: 5, resilience: 3 },
                    ratingRequired: 0,
                    description: 'Basic honor helm'
                },
                {
                    id: 'head_rival',
                    name: 'Rival\'s Greathelm',
                    slot: 'head',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 4000,
                    stats: { health: 12, resilience: 8, manaRegen: 5 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                },
                {
                    id: 'head_gladiator',
                    name: 'Gladiator\'s Crown',
                    slot: 'head',
                    tier: 'Gladiator',
                    itemLevel: 431,
                    cost: 12000,
                    stats: { health: 20, resilience: 15, manaRegen: 10, damage: 8 },
                    ratingRequired: 2400,
                    description: 'Requires 2400 rating (Gladiator)'
                },
                
                // SHOULDERS
                {
                    id: 'shoulders_combatant',
                    name: 'Combatant\'s Spaulders',
                    slot: 'shoulders',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 800,
                    stats: { health: 4, resilience: 2 },
                    ratingRequired: 0,
                    description: 'Basic honor shoulders'
                },
                {
                    id: 'shoulders_rival',
                    name: 'Rival\'s Mantle',
                    slot: 'shoulders',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 3500,
                    stats: { health: 10, resilience: 6, healingPower: 5 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                },
                
                // CHEST
                {
                    id: 'chest_combatant',
                    name: 'Combatant\'s Chestguard',
                    slot: 'chest',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 1250,
                    stats: { health: 8, resilience: 4 },
                    ratingRequired: 0,
                    description: 'Basic honor chest'
                },
                {
                    id: 'chest_rival',
                    name: 'Rival\'s Battleplate',
                    slot: 'chest',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 5000,
                    stats: { health: 18, resilience: 10, damage: 5 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                },
                {
                    id: 'chest_gladiator',
                    name: 'Gladiator\'s Warplate',
                    slot: 'chest',
                    tier: 'Gladiator',
                    itemLevel: 431,
                    cost: 15000,
                    stats: { health: 30, resilience: 18, damage: 12, healingPower: 8 },
                    ratingRequired: 2400,
                    description: 'Requires 2400 rating (Gladiator)'
                },
                
                // HANDS
                {
                    id: 'hands_combatant',
                    name: 'Combatant\'s Gauntlets',
                    slot: 'hands',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 800,
                    stats: { health: 3, critChance: 2 },
                    ratingRequired: 0,
                    description: 'Basic honor gloves'
                },
                {
                    id: 'hands_rival',
                    name: 'Rival\'s Grips',
                    slot: 'hands',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 3500,
                    stats: { health: 8, critChance: 5, damage: 4 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                },
                
                // LEGS
                {
                    id: 'legs_combatant',
                    name: 'Combatant\'s Legguards',
                    slot: 'legs',
                    tier: 'Combatant',
                    itemLevel: 379,
                    cost: 1000,
                    stats: { health: 6, resilience: 3 },
                    ratingRequired: 0,
                    description: 'Basic honor legs'
                },
                {
                    id: 'legs_rival',
                    name: 'Rival\'s Legplates',
                    slot: 'legs',
                    tier: 'Rival',
                    itemLevel: 405,
                    cost: 4500,
                    stats: { health: 15, resilience: 8, manaRegen: 4 },
                    ratingRequired: 2000,
                    description: 'Requires 2000 rating'
                }
            ],
            
            // TRINKETS (Special effects)
            trinkets: [
                {
                    id: 'trinket_medallion',
                    name: 'Medallion of Cruelty',
                    slot: 'trinket1', // Can go in either trinket slot
                    tier: 'Epic',
                    itemLevel: 392,
                    cost: 2500,
                    stats: { damage: 10, critChance: 4 },
                    ratingRequired: 1400,
                    description: 'Increases burst damage'
                },
                {
                    id: 'trinket_insignia',
                    name: 'Insignia of Victory',
                    slot: 'trinket1', // Can go in either trinket slot
                    tier: 'Epic',
                    itemLevel: 405,
                    cost: 4000,
                    stats: { resilience: 10, health: 10 },
                    ratingRequired: 1800,
                    description: 'Increases survivability'
                },
                {
                    id: 'trinket_gladiator',
                    name: 'Gladiator\'s Medallion',
                    slot: 'trinket1', // Can go in either trinket slot
                    tier: 'Gladiator',
                    itemLevel: 431,
                    cost: 15000,
                    stats: { damage: 20, critChance: 8, cooldownReduction: 8 },
                    ratingRequired: 2400,
                    description: 'Ultimate PvP trinket'
                }
            ]
        };

        // ============================================
        // CONQUEST VENDOR (Premium Upgrades)
        // ============================================
        // High-value permanent upgrades purchased with weekly-capped Conquest
        const CONQUEST_UPGRADES = [
            {
                id: 'conquest_weapon_upgrade',
                name: 'Weapon Upgrade',
                desc: '+5 Item Levels to equipped weapon',
                cost: 500,
                maxLevel: 5,
                icon: '‚öîÔ∏è',
                effect: 'weaponIlvl',
                bonus: 5
            },
            {
                id: 'conquest_armor_upgrade',
                name: 'Armor Upgrade',
                desc: '+5 Item Levels to all armor pieces',
                cost: 800,
                maxLevel: 5,
                icon: 'üõ°Ô∏è',
                effect: 'armorIlvl',
                bonus: 5
            },
            {
                id: 'conquest_versatility',
                name: 'Versatility',
                desc: '+3% damage dealt and -3% damage taken',
                cost: 600,
                maxLevel: 10,
                icon: '‚ú®',
                effect: 'versatility',
                bonus: 0.03
            },
            {
                id: 'conquest_mastery',
                name: 'Mastery',
                desc: '+5% to all healing and damage',
                cost: 700,
                maxLevel: 8,
                icon: 'üéØ',
                effect: 'mastery',
                bonus: 0.05
            },
            {
                id: 'conquest_tenacity',
                name: 'Tenacity',
                desc: '+10% max health for entire team',
                cost: 900,
                maxLevel: 5,
                icon: '‚ù§Ô∏è',
                effect: 'tenacity',
                bonus: 0.1
            },
            {
                id: 'conquest_swiftness',
                name: 'Swiftness',
                desc: '+15% movement speed for team',
                cost: 500,
                maxLevel: 3,
                icon: 'üí®',
                effect: 'swiftness',
                bonus: 0.15
            },
            {
                id: 'conquest_honor_boost',
                name: 'Elite Status',
                desc: '+25% Honor gains from all sources',
                cost: 1000,
                maxLevel: 4,
                icon: 'üèÜ',
                effect: 'eliteHonor',
                bonus: 0.25
            },
            {
                id: 'conquest_rating_protection',
                name: 'Rating Protection',
                desc: 'Reduce rating loss on defeat by 20%',
                cost: 1000,
                maxLevel: 3,
                icon: 'üõ°Ô∏è',
                effect: 'ratingProtection',
                bonus: 0.2
            }
        ];

        // ============================================
        // CHARACTER CLASSES (WoW Arena Style)
        // ============================================
        // ============================================
        // ENCHANTMENT DEFINITIONS
        // ============================================
        const ENCHANTS = {
            mongoose: {
                id: 'mongoose',
                name: 'Mongoose',
                desc: 'Increases Haste by 15% and adds Lightning visuals.',
                cost: 5000,
                ratingRequired: 1600,
                color: 0x00ffff, // Cyan/Lightning
                stats: { haste: 15 },
                particleType: 'lightning'
            },
            executioner: {
                id: 'executioner',
                name: 'Executioner',
                desc: 'Increases Crit Chance by 10% and adds Shadow visuals.',
                cost: 7500,
                ratingRequired: 1800,
                color: 0xff00ff, // Purple/Shadow
                stats: { critChance: 10 },
                particleType: 'shadow'
            },
            berserking: {
                id: 'berserking',
                name: 'Berserking',
                desc: 'Increases Damage by 12% but reduces Resilience by 5%. Adds Fire visuals.',
                cost: 10000,
                ratingRequired: 2000,
                color: 0xff4400, // Orange/Fire
                stats: { damage: 12, resilience: -5 },
                particleType: 'fire'
            },
            spellsurge: {
                id: 'spellsurge',
                name: 'Spellsurge',
                desc: 'Increases Mana Regen by 20%. Adds Arcane visuals.',
                cost: 6000,
                ratingRequired: 1700,
                color: 0xaa00ff, // Violet/Arcane
                stats: { manaRegen: 20 },
                particleType: 'arcane'
            }
        };

        const DR_CATEGORIES = {
            STUN: 'stun',
            INCAPACITATE: 'incapacitate',
            FEAR: 'fear',
            CYCLONE: 'cyclone',
            ROOT: 'root'
        };

        const AURA_ICONS = {
            'Mortal Strike': 'https://rosebud.ai/assets/warrior-icon.webp?kmKp',
            'Fear': 'https://rosebud.ai/assets/priest-icon.webp?zrd6',
            'Psychic Scream': 'https://rosebud.ai/assets/priest-icon.webp?zrd6',
            'Polymorph': 'https://rosebud.ai/assets/mage-icon.webp?fpHL',
            'Freezing Trap': 'https://rosebud.ai/assets/hunter-icon.webp?GEAN',
            'Kidney Shot': 'https://rosebud.ai/assets/rogue-icon.png.webp?kkGi',
            'Hammer of Justice': 'https://rosebud.ai/assets/paladin-icon.png.webp?muEK',
            'Cyclone': 'https://rosebud.ai/assets/druid-icon.webp?IrUR',
            'Asphyxiate': 'https://rosebud.ai/assets/death-knight-icon.png.webp?rINu',
            'Hex': 'https://rosebud.ai/assets/shaman-icon.png.webp?eVOu',
            'Blind': 'https://rosebud.ai/assets/rogue-icon.png.webp?kkGi',
            'Stun': 'https://rosebud.ai/assets/charge-icon.webp?gjRC',
            'Pain Suppression': 'https://rosebud.ai/assets/priest-icon.webp?zrd6',
            'Ice Block': 'https://rosebud.ai/assets/mage-icon.webp?fpHL',
            'Divine Shield': 'https://rosebud.ai/assets/paladin-icon.png.webp?muEK',
            'Die by the Sword': 'https://rosebud.ai/assets/warrior-icon.webp?kmKp',
            'Barkskin': 'https://rosebud.ai/assets/druid-icon.webp?IrUR',
            'Anti-Magic Shell': 'https://rosebud.ai/assets/death-knight-icon.png.webp?rINu',
            'Cloak of Shadows': 'https://rosebud.ai/assets/rogue-icon.png.webp?kkGi',
            'Metamorphosis': 'https://rosebud.ai/assets/demon-hunter-icon.png.webp?BcV3',
            'Bestial Wrath': 'https://rosebud.ai/assets/hunter-icon.webp?GEAN',
            'Fortifying Brew': 'https://rosebud.ai/assets/monk-icon.png.webp?ds4b',
            'Power Word: Shield': 'https://rosebud.ai/assets/priest-icon.webp?zrd6',
            'Blink': 'https://rosebud.ai/assets/blink-icon.webp?VQu8',
            'School Lock': 'https://rosebud.ai/assets/magical-rune-ring.webp?Kz5k',
            'Healing Reduction': 'https://rosebud.ai/assets/warrior-icon.webp?kmKp',
            'PvP Trinket': 'https://rosebud.ai/assets/arena-rating-icon.webp?oDg7'
        };

        const CLASSES = {
            warrior: {
                name: 'Warrior',
                color: 0xc79c6e,
                role: 'melee',
                health: 45000,
                abilities: [
                    { name: 'Mortal Strike', damage: 8000, cooldown: 6, type: 'damage', healingReduction: 0.5, rageCost: 30 },
                    { name: 'Charge', type: 'utility', cooldown: 20, stun: 1.5, drCategory: DR_CATEGORIES.STUN, rageGen: 20 },
                    { name: 'Pummel', type: 'interrupt', cooldown: 15, duration: 4 },
                    { name: 'Intimidating Shout', type: 'cc', cooldown: 90, fear: 6, drCategory: DR_CATEGORIES.FEAR, rageCost: 10 },
                    { name: 'Die by the Sword', type: 'defensive', cooldown: 180, duration: 8, damageReduction: 1, rageCost: 10 },
                    { name: 'Bladestorm', type: 'damage', cooldown: 60, damage: 15000, aoe: true, duration: 4, rageCost: 30 },
                    { name: 'Storm Bolt', type: 'cc', cooldown: 30, stun: 4, drCategory: DR_CATEGORIES.STUN, rageCost: 20 },
                    { name: 'Avatar', type: 'offensive', cooldown: 90, duration: 20, damageBuff: 0.2 },
                    { name: 'Shattering Throw', damage: 6000, cooldown: 180, type: 'damage', rageCost: 25, shatterImmunity: true, castTime: 1.5 },
                    { name: 'Rallying Cry', type: 'defensive', cooldown: 180, duration: 10, damageReduction: 0.15, target: 'ally' }
                ]
            },
            hunter: {
                name: 'Hunter',
                color: 0xabd473,
                role: 'ranged',
                health: 40000,
                abilities: [
                    { name: 'Aimed Shot', damage: 9000, cooldown: 3, type: 'damage', castTime: 2.0 },
                    { name: 'Kill Shot', damage: 15000, cooldown: 10, type: 'damage', execute: 0.2 },
                    { name: 'High Explosive Trap', type: 'utility', cooldown: 30, knockback: 8 },
                    { name: 'Freezing Trap', type: 'cc', cooldown: 30, freeze: 8, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Counter Shot', type: 'interrupt', cooldown: 24, duration: 3 },
                    { name: 'Feign Death', type: 'defensive', cooldown: 30, duration: 6, invulnerable: true },
                    { name: 'Bestial Wrath', type: 'offensive', cooldown: 90, duration: 15, damageBuff: 0.4 },
                    { name: 'Intimidation', type: 'cc', cooldown: 60, stun: 5, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Rapid Fire', damage: 12000, cooldown: 20, type: 'damage' },
                    { name: 'Scatter Shot', type: 'cc', cooldown: 30, disorient: 4, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Binding Shot', type: 'cc', cooldown: 45, root: 5, drCategory: DR_CATEGORIES.ROOT }
                ]
            },
            priest: {
                name: 'Priest',
                color: 0xffffff,
                role: 'healer',
                health: 38000,
                abilities: [
                    { name: 'Flash Heal', heal: 15000, cooldown: 1.5, type: 'heal', mana: 1800, castTime: 1.5 },
                    { name: 'Power Word: Shield', type: 'defensive', cooldown: 6, absorb: 8000, duration: 15 },
                    { name: 'Psychic Scream', type: 'cc', cooldown: 60, fear: 8, drCategory: DR_CATEGORIES.FEAR },
                    { name: 'Pain Suppression', type: 'defensive', cooldown: 180, duration: 8, damageReduction: 0.4, target: 'ally' },
                    { name: 'Holy Fire', damage: 7000, cooldown: 10, type: 'damage', castTime: 1.5 },
                    { name: 'Smite', damage: 4500, cooldown: 1.5, type: 'damage', castTime: 1.5 },
                    { name: 'Greater Fade', type: 'defensive', cooldown: 45, duration: 4, damageReduction: 0.8 },
                    { name: 'Mind Control', type: 'cc', cooldown: 45, sheep: 4, castTime: 1.8, drCategory: DR_CATEGORIES.INCAPACITATE, mana: 2000 },
                    { name: 'Holy Word: Chastise', type: 'cc', cooldown: 60, stun: 4, drCategory: DR_CATEGORIES.STUN, mana: 1000 },
                    { name: 'Desperate Prayer', type: 'defensive', cooldown: 90, duration: 10, selfHealOnUse: 0.25 }
                ]
            },
            druid: {
                name: 'Druid',
                color: 0xff7d0a,
                role: 'healer',
                health: 40000,
                abilities: [
                    { name: 'Regrowth', heal: 14000, cooldown: 1.5, type: 'heal', mana: 1600, hot: 3000, castTime: 1.5 },
                    { name: 'Rejuvenation', heal: 5000, cooldown: 0, type: 'heal', mana: 1200, hot: 8000, duration: 12 },
                    { name: 'Typhoon', type: 'utility', cooldown: 30, knockback: 7, aoe: true },
                    { name: 'Cyclone', type: 'cc', cooldown: 20, banish: 6, castTime: 1.7, drCategory: DR_CATEGORIES.CYCLONE },
                    { name: 'Barkskin', type: 'defensive', cooldown: 60, duration: 12, damageReduction: 0.2 },
                    { name: 'Swiftmend', heal: 18000, cooldown: 15, type: 'heal', mana: 2000 },
                    { name: 'Wrath', damage: 5000, cooldown: 1.5, type: 'damage', castTime: 1.5 },
                    { name: 'Ironbark', type: 'defensive', cooldown: 60, duration: 12, damageReduction: 0.2, target: 'ally' },
                    { name: 'Mighty Bash', type: 'cc', cooldown: 50, stun: 4, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Entangling Roots', type: 'cc', cooldown: 20, root: 8, castTime: 1.7, drCategory: DR_CATEGORIES.ROOT, mana: 1000 },
                    { name: 'Incapacitating Roar', type: 'cc', cooldown: 30, disorient: 3, aoe: true, drCategory: DR_CATEGORIES.INCAPACITATE }
                ]
            },
            mage: {
                name: 'Mage',
                color: 0x69ccf0,
                role: 'ranged',
                health: 36000,
                abilities: [
                    { name: 'Frostbolt', damage: 8500, cooldown: 2, type: 'damage', castTime: 2.0 },
                    { name: 'Counterspell', type: 'interrupt', cooldown: 24, duration: 6 },
                    { name: 'Polymorph', type: 'cc', cooldown: 30, sheep: 8, castTime: 1.7, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Ice Block', type: 'defensive', cooldown: 240, duration: 10, invulnerable: true },
                    { name: 'Blink', type: 'utility', cooldown: 15, teleport: 10 },
                    { name: 'Combustion', type: 'offensive', cooldown: 120, duration: 12, damageBuff: 0.5 },
                    { name: 'Dragon\'s Breath', type: 'cc', cooldown: 20, disorient: 4, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Ring of Frost', type: 'cc', cooldown: 45, freeze: 6, aoe: true, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Frost Nova', type: 'cc', cooldown: 25, root: 6, aoe: true, drCategory: DR_CATEGORIES.ROOT }
                ]
            },
            death_knight: {
                name: 'Death Knight',
                color: 0xc41e3a,
                role: 'melee',
                health: 50000,
                abilities: [
                    { name: 'Death Coil', damage: 7000, cooldown: 8, type: 'damage', selfHeal: 3000 },
                    { name: 'Death Grip', type: 'utility', cooldown: 25, pull: true },
                    { name: 'Mind Freeze', type: 'interrupt', cooldown: 15, duration: 4 },
                    { name: 'Asphyxiate', type: 'cc', cooldown: 45, stun: 5, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Anti-Magic Shell', type: 'defensive', cooldown: 60, duration: 10, damageReduction: 0.5 },
                    { name: 'Chains of Ice', damage: 1000, cooldown: 8, type: 'damage', slow: 0.5, slowDuration: 8 },
                    { name: 'Icebound Fortitude', type: 'defensive', cooldown: 180, duration: 8, damageReduction: 0.3 },
                    { name: 'Strangulate', damage: 500, cooldown: 60, type: 'damage', applySilence: 4 },
                    { name: 'Remorseless Winter', type: 'cc', cooldown: 20, stun: 4, aoe: true, drCategory: DR_CATEGORIES.STUN }
                ]
            },
            paladin: {
                name: 'Paladin',
                color: 0xf58cba,
                role: 'melee',
                health: 48000,
                abilities: [
                    { name: 'Templar\'s Verdict', damage: 9500, cooldown: 5, type: 'damage' },
                    { name: 'Hammer of Justice', type: 'cc', cooldown: 60, stun: 6, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Rebuke', type: 'interrupt', cooldown: 15, duration: 4 },
                    { name: 'Divine Shield', type: 'defensive', cooldown: 300, duration: 8, invulnerable: true },
                    { name: 'Flash of Light', heal: 10000, cooldown: 8, type: 'heal', mana: 1500, castTime: 1.5 },
                    { name: 'Blessing of Protection', type: 'defensive', cooldown: 180, duration: 10, damageReduction: 0.7, target: 'ally' },
                    { name: 'Avenging Wrath', type: 'offensive', cooldown: 120, duration: 20, damageBuff: 0.3 },
                    { name: 'Repentance', type: 'cc', cooldown: 60, sheep: 6, castTime: 1.7, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Blinding Light', type: 'cc', cooldown: 90, disorient: 4, aoe: true, drCategory: DR_CATEGORIES.INCAPACITATE }
                ]
            },
            rogue: {
                name: 'Rogue',
                color: 0xfff569,
                role: 'melee',
                health: 38000,
                abilities: [
                    { name: 'Mutilate', damage: 7500, cooldown: 3, type: 'damage', energyCost: 40, generatesComboPoint: 2 },
                    { name: 'Eviscerate', damage: 6000, cooldown: 0, type: 'damage', spendsComboPoint: true, energyCost: 35 },
                    { name: 'Kidney Shot', type: 'cc', cooldown: 20, stun: 1.5, drCategory: DR_CATEGORIES.STUN, spendsComboPoint: true, energyCost: 25 },
                    { name: 'Kick', type: 'interrupt', cooldown: 15, duration: 5 },
                    { name: 'Cloak of Shadows', type: 'defensive', cooldown: 90, duration: 5, damageReduction: 0.7 },
                    { name: 'Blind', type: 'cc', cooldown: 120, disorient: 6, drCategory: DR_CATEGORIES.FEAR, energyCost: 30 },
                    { name: 'Evasion', type: 'defensive', cooldown: 120, duration: 10, damageReduction: 0.5 },
                    { name: 'Shadow Dance', type: 'offensive', cooldown: 60, duration: 8, damageBuff: 0.3 },
                    { name: 'Garrote', damage: 3000, cooldown: 15, type: 'damage', energyCost: 45, generatesComboPoint: 1, applySilence: 3, dot: true, dotDamage: 1500, dotDuration: 12 },
                    { name: 'Smoke Bomb', type: 'defensive', cooldown: 180, duration: 5, damageReduction: 0.6, energyCost: 40 }
                ]
            },
            shaman: {
                name: 'Shaman',
                color: 0x0070de,
                role: 'healer',
                health: 42000,
                abilities: [
                    { name: 'Healing Wave', heal: 16000, cooldown: 2, type: 'heal', mana: 1500, castTime: 2.0 },
                    { name: 'Thunderstorm', type: 'utility', cooldown: 30, knockback: 10, aoe: true },
                    { name: 'Wind Shear', type: 'interrupt', cooldown: 12, duration: 3 },
                    { name: 'Hex', type: 'cc', cooldown: 45, sheep: 6, castTime: 1.7, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Spirit Link', type: 'defensive', cooldown: 180, duration: 6, damageReduction: 0.3 },
                    { name: 'Lava Burst', damage: 8000, cooldown: 8, type: 'damage', castTime: 2.0 },
                    { name: 'Lightning Bolt', damage: 4000, cooldown: 1.5, type: 'damage', castTime: 1.5 },
                    { name: 'Riptide', heal: 8000, cooldown: 6, type: 'heal', mana: 1000, hot: 6000, duration: 18 },
                    { name: 'Capacitor Totem', type: 'cc', cooldown: 60, stun: 3, aoe: true, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Earthgrab Totem', type: 'cc', cooldown: 30, root: 5, aoe: true, drCategory: DR_CATEGORIES.ROOT },
                    { name: 'Ancestral Protection Totem', type: 'defensive', cooldown: 300, duration: 15, damageReduction: 0.2, target: 'ally', mana: 2000 }
                ]
            },
            warlock: {
                name: 'Warlock',
                color: 0x8787ed,
                role: 'ranged',
                health: 44000,
                abilities: [
                    { name: 'Chaos Bolt', damage: 12000, cooldown: 12, type: 'damage', castTime: 3.0 },
                    { name: 'Fear', type: 'cc', cooldown: 1.5, fear: 6, castTime: 1.7, drCategory: DR_CATEGORIES.FEAR },
                    { name: 'Spell Lock', type: 'interrupt', cooldown: 24, duration: 6 },
                    { name: 'Unending Resolve', type: 'defensive', cooldown: 180, duration: 8, damageReduction: 0.4 },
                    { name: 'Mortal Coil', type: 'cc', cooldown: 45, fear: 3, drCategory: DR_CATEGORIES.FEAR, selfHealPercent: 0.2 },
                    { name: 'Dark Pact', type: 'defensive', cooldown: 60, duration: 20, absorb: 10000 },
                    { name: 'Howl of Terror', type: 'cc', cooldown: 40, fear: 5, aoe: true, drCategory: DR_CATEGORIES.FEAR },
                    { name: 'Shadowfury', type: 'cc', cooldown: 30, stun: 3, aoe: true, drCategory: DR_CATEGORIES.STUN, castTime: 1.5 }
                ]
            },
            demon_hunter: {
                name: 'Demon Hunter',
                color: 0xa330c9,
                role: 'melee',
                health: 42000,
                abilities: [
                    { name: 'Chaos Strike', damage: 8500, cooldown: 4, type: 'damage' },
                    { name: 'Fel Rush', type: 'utility', cooldown: 15, damage: 3000, dash: true },
                    { name: 'Disrupt', type: 'interrupt', cooldown: 15, duration: 3 },
                    { name: 'Chaos Nova', type: 'cc', cooldown: 45, stun: 3, aoe: true, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Metamorphosis', type: 'offensive', cooldown: 180, duration: 15, damageBuff: 0.5, healthBuff: 0.25 },
                    { name: 'Blur', type: 'defensive', cooldown: 60, duration: 10, damageReduction: 0.5 },
                    { name: 'Imprison', type: 'cc', cooldown: 45, sheep: 4, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Sigil of Misery', type: 'cc', cooldown: 60, fear: 4, aoe: true, drCategory: DR_CATEGORIES.FEAR },
                    { name: 'Fel Eruption', type: 'cc', cooldown: 30, stun: 4, drCategory: DR_CATEGORIES.STUN }
                ]
            },
            monk: {
                name: 'Monk',
                color: 0x00ff96,
                role: 'melee',
                health: 41000,
                abilities: [
                    { name: 'Rising Sun Kick', damage: 9500, cooldown: 8, type: 'damage', mortalWound: 0.25 },
                    { name: 'Spear Hand Strike', type: 'interrupt', cooldown: 15, duration: 4 },
                    { name: 'Leg Sweep', type: 'cc', cooldown: 45, stun: 4, aoe: true, drCategory: DR_CATEGORIES.STUN },
                    { name: 'Fortifying Brew', type: 'defensive', cooldown: 120, duration: 15, damageReduction: 0.2, healthBuff: 0.2 },
                    { name: 'Paralysis', type: 'cc', cooldown: 45, sheep: 4, drCategory: DR_CATEGORIES.INCAPACITATE },
                    { name: 'Touch of Karma', type: 'defensive', cooldown: 90, duration: 10, damageReduction: 0.5, absorb: 12000 },
                    { name: 'Ring of Peace', type: 'utility', cooldown: 45, knockback: 6, aoe: true },
                    { name: 'Disable', type: 'cc', cooldown: 15, root: 4, drCategory: DR_CATEGORIES.ROOT }
                ]
            }
        };



        // ============================================
        // UPGRADE DEFINITIONS (Gear/Rating Progression)
        // ============================================
        // ============================================
        // PRESTIGE TALENT SYSTEM (Career Mastery)
        // ============================================
        const TALENTS = [
            // --- ASSAULT PATH ---
            {
                id: 'tal_damage',
                name: 'Cruel Intent',
                desc: 'Increases all damage dealt by 5% per point.',
                maxLevel: 5,
                icon: 'üí•',
                category: 'Assault'
            },
            {
                id: 'tal_crit',
                name: 'Lethal Precision',
                desc: 'Increases critical strike damage by 15% per point.',
                maxLevel: 3,
                icon: 'üéØ',
                category: 'Assault'
            },
            {
                id: 'tal_execution',
                name: 'Executioner',
                desc: 'Increases damage against targets below 35% health by 10% per point.',
                maxLevel: 3,
                icon: '‚öîÔ∏è',
                category: 'Assault'
            },
            // --- IRONCLAD PATH ---
            {
                id: 'tal_defense',
                name: 'Unyielding Wall',
                desc: 'Reduces all damage taken by 3% per point.',
                maxLevel: 5,
                icon: 'üõ°Ô∏è',
                category: 'Ironclad'
            },
            {
                id: 'tal_cc_res',
                name: 'Relentless Spirit',
                desc: 'Reduces duration of CC effects by 10% per point.',
                maxLevel: 3,
                icon: '‚õìÔ∏è',
                category: 'Ironclad'
            },
            {
                id: 'tal_recovery',
                name: 'Second Wind',
                desc: 'Heal for 5% of max health when dropping below 30% health. (30s CD)',
                maxLevel: 3,
                icon: 'üå¨Ô∏è',
                category: 'Ironclad'
            },
            // --- ASCENDANCE PATH ---
            {
                id: 'tal_mana',
                name: 'Arcane Flow',
                desc: 'Increases healer mana regeneration by 10% per point.',
                maxLevel: 5,
                icon: 'üíß',
                category: 'Ascendance'
            },
            {
                id: 'tal_cdr',
                name: 'Quick Recovery',
                desc: 'Reduces all cooldowns by 5% per point.',
                maxLevel: 3,
                icon: '‚è≥',
                category: 'Ascendance'
            },
            {
                id: 'tal_efficiency',
                name: 'Inner Focus',
                desc: 'Reduces mana cost of all spells by 8% per point.',
                maxLevel: 3,
                icon: 'üß†',
                category: 'Ascendance'
            }
        ];

        const UPGRADES = [
            {
                id: 'damage',
                name: 'Attack Power',
                desc: 'Increase all damage by 8%',
                baseCost: 100,
                costMultiplier: 1.4,
                icon: 'https://rosebud.ai/assets/combat-rating-icon.webp?Eb7v'
            },
            {
                id: 'health',
                name: 'Stamina',
                desc: 'Increase all health by 10%',
                baseCost: 100,
                costMultiplier: 1.4,
                icon: 'https://rosebud.ai/assets/warrior-icon.webp?kmKp'
            },
            {
                id: 'resilience',
                name: 'Resilience',
                desc: 'Reduce damage taken by 5%',
                baseCost: 150,
                costMultiplier: 1.5,
                icon: 'https://rosebud.ai/assets/priest-icon.webp?zrd6'
            },
            {
                id: 'healingPower',
                name: 'Healing Power',
                desc: 'Increase healing by 12%',
                baseCost: 120,
                costMultiplier: 1.4,
                icon: 'https://rosebud.ai/assets/flash-heal-icon.webp?Cy6J'
            },
            {
                id: 'ccDuration',
                name: 'CC Duration',
                desc: 'Crowd control lasts 10% longer',
                baseCost: 200,
                costMultiplier: 1.6,
                icon: 'https://rosebud.ai/assets/blink-icon.webp?VQu8'
            },
            {
                id: 'cooldownReduction',
                name: 'Haste',
                desc: 'Reduce all cooldowns by 5%',
                baseCost: 250,
                costMultiplier: 1.7,
                icon: 'https://rosebud.ai/assets/charge-icon.webp?gjRC'
            },
            {
                id: 'critChance',
                name: 'Critical Strike',
                desc: 'Increase crit chance by 3%',
                baseCost: 180,
                costMultiplier: 1.5,
                icon: 'https://rosebud.ai/assets/frostbolt-icon.webp?BS8W'
            },
            {
                id: 'manaRegen',
                name: 'Spirit',
                desc: 'Increase healer mana regen by 15%',
                baseCost: 140,
                costMultiplier: 1.5,
                icon: 'https://rosebud.ai/assets/mage-icon.webp?fpHL'
            },
            {
                id: 'honorBonus',
                name: 'Honor Bonus',
                desc: 'Increase Honor per win by 15%',
                baseCost: 300,
                costMultiplier: 1.8,
                icon: 'https://rosebud.ai/assets/honor-token.webp?Aozw'
            },
            {
                id: 'matchSpeed',
                name: 'Match Speed',
                desc: 'Matches complete 8% faster',
                baseCost: 400,
                costMultiplier: 2.0,
                icon: 'https://rosebud.ai/assets/arena-rating-icon.webp?oDg7'
            }
        ];

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 14, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap; // Performance: Faster than PCFSoft
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(10, 20, 10);
        mainLight.castShadow = true;
        mainLight.shadow.camera.left = -20;
        mainLight.shadow.camera.right = 20;
        mainLight.shadow.camera.top = 20;
        mainLight.shadow.camera.bottom = -20;
        mainLight.shadow.mapSize.width = 512; // Performance: Downscaled from 1024
        mainLight.shadow.mapSize.height = 512; // Performance: Downscaled from 1024
        scene.add(mainLight);

        const rimLight = new THREE.DirectionalLight(0x4a90e2, 0.5);
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // ============================================
        // CAMERA CONTROLS (OrbitControls)
        // ============================================
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 5;
        controls.maxDistance = 40;
        controls.maxPolarAngle = Math.PI / 2.1; // Prevent going below floor
        controls.target.set(0, 0, 0);

        // Notify spectator camera when user interacts
        controls.addEventListener('start', () => {
            if (spectatorCamera) spectatorCamera.userInteracting = true;
        });

        function resetCamera() {
            if (spectatorCamera) {
                spectatorCamera.enabled = false;
                spectatorCamera.target = null;
            }
            
            // Standard centered view
            const defaultPos = new THREE.Vector3(0, 14, 25);
            const defaultTarget = new THREE.Vector3(0, 0, 0);
            
            camera.position.copy(defaultPos);
            controls.target.copy(defaultTarget);
            controls.update();
            
            showArenaAnnouncement("Camera: Manual Mode", 1000);
            addCombatLog("Camera mode set to manual (Standard).", "buff");
        }

        function toggleCameraMode(forceMode = null) {
            if (!spectatorCamera) return;
            
            const newEnabled = forceMode !== null ? forceMode : !spectatorCamera.enabled;
            spectatorCamera.enabled = newEnabled;
            
            const btn = document.getElementById('camera-toggle-btn');
            const nextBtn = document.getElementById('camera-next-btn');
            
            if (newEnabled) {
                if (btn) btn.textContent = "üìπ Cam: Spectator";
                if (nextBtn) nextBtn.style.display = 'flex';
                showArenaAnnouncement("Camera: Spectator Mode", 1000);
                addCombatLog("Spectator Camera enabled. Press 'Q' or 'E' to cycle targets!", "buff");
            } else {
                if (btn) btn.textContent = "üìπ Cam: Standard";
                if (nextBtn) nextBtn.style.display = 'none';
                resetCamera();
            }
        }

        // Hotkeys
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            // C - Dynamic Follow / Spectator Toggle
            if (key === 'c') {
                toggleCameraMode();
            }
            // V - Reset to Standard Camera
            if (key === 'v') {
                toggleCameraMode(false);
            }
            // Q/E - Cycle Follow Targets
            if (key === 'q') {
                if (spectatorCamera) spectatorCamera.cycleTarget(-1);
            }
            if (key === 'e') {
                if (spectatorCamera) spectatorCamera.cycleTarget(1);
            }
        });

        // ============================================
        // DYNAMIC SPECTATOR CAMERA
        // ============================================
        const spectatorCamera = {
            enabled: false, // Default to manual mode as requested
            target: null,
            offset: new THREE.Vector3(0, 8, 14),
            lerpSpeed: 1.5,
            mode: 'smart', 
            lastTargetChange: 0,
            userInteracting: false,
            interactionTimer: 0,
            
            update(deltaTime) {
                if (!this.enabled || !gameState.inMatch || gameState.matchState === 'waiting') return;
                
                // If user is interacting, pause auto-follow
                if (this.userInteracting) {
                    this.interactionTimer = 5; // Pause for 5 seconds after interaction
                    this.userInteracting = false;
                }
                
                if (this.interactionTimer > 0) {
                    this.interactionTimer -= deltaTime;
                    return;
                }

                const now = performance.now();
                
                // Find a target if we don't have one or if current target is dead
                // Also periodically re-evaluate to follow action
                if (!this.target || !this.target.visible || this.target.userData.health <= 0 || (now - this.lastTargetChange > 5000)) {
                    const newTarget = this.findBestTarget();
                    if (newTarget !== this.target) {
                        this.target = newTarget;
                        this.lastTargetChange = now;
                    }
                }
                
                if (this.target) {
                    // Calculate desired position
                    // We want to stay "behind" the target or at a fixed angle
                    const desiredPosition = this.target.position.clone().add(this.offset);
                    
                    // Smoothly move camera
                    camera.position.lerp(desiredPosition, this.lerpSpeed * deltaTime);
                    
                    // Smoothly move controls target (lookAt point)
                    const targetLookAt = this.target.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                    controls.target.lerp(targetLookAt, this.lerpSpeed * deltaTime);
                } else {
                    // Default view if no targets
                    controls.target.lerp(new THREE.Vector3(0, 0, 0), this.lerpSpeed * deltaTime);
                }
            },
            
            findBestTarget() {
                const allAlive = [...gameState.team, ...gameState.enemies].filter(c => c.visible && c.userData.health > 0);
                if (allAlive.length === 0) return null;
                
                // Priority 1: Target with lowest health % (critical action)
                const lowHealthUnits = allAlive.filter(c => (c.userData.health / c.userData.maxHealth) < 0.35);
                if (lowHealthUnits.length > 0) {
                    return lowHealthUnits.sort((a, b) => (a.userData.health / a.userData.maxHealth) - (b.userData.health / b.userData.maxHealth))[0];
                }
                
                // Priority 2: Anyone casting a big spell
                const casters = allAlive.filter(c => c.userData.isCasting);
                if (casters.length > 0) return casters[0];
                
                // Priority 3: Unit with highest burst damage (simulated by checking if they have offensive buffs)
                const burstUnits = allAlive.filter(c => c.userData.auras && c.userData.auras.some(a => a.type === 'buff' && (a.name.includes('Power') || a.name.includes('Wings'))));
                if (burstUnits.length > 0) return burstUnits[0];

                // Priority 4: Random active unit
                return allAlive[Math.floor(Math.random() * allAlive.length)];
            },

            cycleTarget(direction) {
                const allAlive = [...gameState.team, ...gameState.enemies].filter(c => c.visible && c.userData.health > 0 && !c.userData.isPet);
                if (allAlive.length === 0) return;

                let currentIndex = allAlive.indexOf(this.target);
                let nextIndex;

                if (currentIndex === -1) {
                    nextIndex = direction > 0 ? 0 : allAlive.length - 1;
                } else {
                    nextIndex = (currentIndex + direction + allAlive.length) % allAlive.length;
                }

                this.target = allAlive[nextIndex];
                this.lastTargetChange = performance.now(); // Reset timer so it stays on this target for a bit
                this.interactionTimer = 0; // Allow camera to update immediately
                this.enabled = true; // Ensure camera mode is on

                if (this.target.userData && this.target.userData.classData) {
                    const name = this.target.userData.classData.name;
                    const team = this.target.userData.isEnemy ? "Enemy" : "Ally";
                    showArenaAnnouncement(`Following: ${team} ${name}`, 800);
                }
            }
        };

        // ============================================
        // ARENA GEOMETRY (Blade's Edge Style)
        // ============================================
        async function createBladesEdgeArena() {
            // Clear grounding targets
            floorMeshes.length = 0;
            
            // Blade's Edge Sky Color (TBC Outland Style)
            scene.background = new THREE.Color(0x2a1a3a); // Deep purple
            scene.fog = new THREE.Fog(0x2a1a3a, 40, 150);

            // Floor - Rocky abyss style
            const floorRadius = 40;
            const floorGeo = new THREE.CircleGeometry(floorRadius, 32);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.1,
                roughness: 0.9
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -5; // Below the main bridge
            scene.add(floor);
            floorMeshes.push(floor);

            // Main Bridge (The central spine)
            const bridgeGeo = new THREE.BoxGeometry(TERRAIN.bridgeLength, 1, TERRAIN.bridgeWidth);
            const bridgeMat = new THREE.MeshStandardMaterial({
                color: 0x4a4035,
                metalness: 0.2,
                roughness: 0.8
            });
            const bridge = new THREE.Mesh(bridgeGeo, bridgeMat);
            bridge.position.y = TERRAIN.bridgeHeight - 0.5;
            bridge.receiveShadow = true;
            bridge.castShadow = true;
            scene.add(bridge);
            floorMeshes.push(bridge);

            // Ramps
            const rampGeo = new THREE.BoxGeometry(TERRAIN.rampLength, 1, TERRAIN.rampWidth);
            
            // Left Ramp
            const leftRamp = new THREE.Mesh(rampGeo, bridgeMat);
            leftRamp.position.set(-(TERRAIN.bridgeLength / 2 + TERRAIN.rampLength / 2), TERRAIN.bridgeHeight / 2 - 0.5, 0);
            leftRamp.rotation.z = Math.atan2(TERRAIN.bridgeHeight, TERRAIN.rampLength);
            leftRamp.receiveShadow = true;
            leftRamp.castShadow = true;
            scene.add(leftRamp);
            floorMeshes.push(leftRamp);

            // Right Ramp
            const rightRamp = new THREE.Mesh(rampGeo, bridgeMat);
            rightRamp.position.set((TERRAIN.bridgeLength / 2 + TERRAIN.rampLength / 2), TERRAIN.bridgeHeight / 2 - 0.5, 0);
            rightRamp.rotation.z = -Math.atan2(TERRAIN.bridgeHeight, TERRAIN.rampLength);
            rightRamp.receiveShadow = true;
            rightRamp.castShadow = true;
            scene.add(rightRamp);
            floorMeshes.push(rightRamp);

            // Pillars on the bridge
            const pillarPositions = [
                { x: -8, z: 2 }, { x: -8, z: -2 },
                { x: 8, z: 2 }, { x: 8, z: -2 }
            ];

            arenaObstacles.length = 0;

            // Load custom pillar
            let pillarBase = null;
            try {
                pillarBase = await loadGLTFModel(MODEL_URLS.pillar);
            } catch (e) {
                console.warn("Could not load pillar model:", e);
            }

            pillarPositions.forEach(pos => {
                if (pillarBase) {
                    const pillar = pillarBase.clone();
                    pillar.scale.set(6, 6, 6); // Scaled for Blade's Edge
                    // Adjust Y so the base of the pillar (center-origin) sits on the bridge
                    // 6 units scale * roughly 0.5 offset to bring bottom to center
                    pillar.position.set(pos.x, TERRAIN.bridgeHeight + 2.5, pos.z);
                    pillar.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(pillar);
                    arenaObstacles.push(pillar);
                } else {
                    const pillarGeo = new THREE.CylinderGeometry(1.2, 1.5, 8, 8);
                    const pillarMat = new THREE.MeshStandardMaterial({ color: 0x332a22 });
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(pos.x, TERRAIN.bridgeHeight + 3.5, pos.z);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    scene.add(pillar);
                    arenaObstacles.push(pillar);
                }
            });

            window.arenaObstacles = arenaObstacles;

            // Add some "spikes" common to Blade's Edge
            for (let i = 0; i < 20; i++) {
                const spikeGeo = new THREE.ConeGeometry(0.5, 10, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = 25 + Math.random() * 10;
                spike.position.set(Math.cos(angle) * dist, -5, Math.sin(angle) * dist);
                spike.rotation.x = (Math.random() - 0.5) * 0.5;
                spike.rotation.z = (Math.random() - 0.5) * 0.5;
                scene.add(spike);
            }
        }

        async function createNagrandArena() {
            // Clear grounding targets
            floorMeshes.length = 0;
            
            // Clear obstacles if switching
            arenaObstacles.length = 0;
            
            // Nagrand Sky Color
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 40, 100);

            // Flat arena floor - Nagrand style grass/dirt mix
            const floorRadius = 20;
            const floorGeo = new THREE.CircleGeometry(floorRadius, 64);
            
            const textureLoader = new THREE.TextureLoader();
            const floorTexture = textureLoader.load('https://rosebud.ai/assets/nagrand-arena-floor.webp.webp?rKI9');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(4, 4); // Tiling for detail
            
            const floorMat = new THREE.MeshStandardMaterial({
                map: floorTexture,
                metalness: 0.1,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            floorMeshes.push(floor);

            // Floating rocks in the distance
            const spectators = [];
            for (let i = 0; i < 12; i++) {
                const rockGroup = new THREE.Group();
                const rockSize = 2 + Math.random() * 5;
                const rockGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 1 });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rockGroup.add(rock);

                // Grass on top of rock
                const grassGeo = new THREE.CircleGeometry(rockSize, 8);
                const grassMat = new THREE.MeshStandardMaterial({ 
                    map: floorTexture,
                    roughness: 0.8
                });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = rockSize * 0.6;
                rockGroup.add(grass);

                // Add spectators on the rock
                const spectatorCount = Math.floor(Math.random() * 5) + 3;
                for(let j=0; j<spectatorCount; j++) {
                    const spectator = new THREE.Group();
                    const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 6);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    body.position.y = 0.3;
                    spectator.add(body);
                    
                    const headGeo = new THREE.SphereGeometry(0.15, 8, 8);
                    const head = new THREE.Mesh(headGeo, bodyMat);
                    head.position.y = 0.7;
                    spectator.add(head);
                    
                    // Position randomly on the grass
                    const r = Math.random() * (rockSize - 0.5);
                    const theta = Math.random() * Math.PI * 2;
                    spectator.position.set(Math.cos(theta) * r, rockSize * 0.6, Math.sin(theta) * r);
                    rockGroup.add(spectator);
                    
                    spectators.push({
                        mesh: spectator,
                        baseY: spectator.position.y,
                        cheering: 0
                    });
                }

                const angle = (i / 12) * Math.PI * 2;
                const dist = 50 + Math.random() * 30;
                rockGroup.position.set(Math.cos(angle) * dist, 5 + Math.random() * 15, Math.sin(angle) * dist);
                rockGroup.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(rockGroup);
            }

            // Global access for cheering
            window.crowdSpectators = spectators;

            // Crowd animation loop
            const animateCrowd = () => {
                const time = performance.now() * 0.001;
                spectators.forEach(s => {
                    if (s.cheering > 0) {
                        s.mesh.position.y = s.baseY + Math.abs(Math.sin(time * 20)) * 0.5;
                        s.cheering -= 0.016;
                    } else {
                        // Idly swaying
                        s.mesh.position.y = s.baseY + Math.sin(time * 2 + s.mesh.id) * 0.05;
                    }
                });
                requestAnimationFrame(animateCrowd);
            };
            animateCrowd();

            // Function to trigger cheer
            window.triggerCrowdCheer = (intensity = 1.0) => {
                spectators.forEach(s => {
                    if (Math.random() < 0.7) s.cheering = intensity;
                });
            };

            // Floor detail rings (Nagrand style stone patterns)
            for (let i = 0; i < 3; i++) {
                const ringRadius = 5 + i * 4;
                const ringGeo = new THREE.RingGeometry(ringRadius, ringRadius + 0.3, 64);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x6a5f5a,
                    metalness: 0.1,
                    roughness: 0.95
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.02;
                scene.add(ring);
            }

            // Center platform (Nagrand stone slab)
            const platformHeight = 0.6;
            const platformRadius = 4;
            const platformGeo = new THREE.CylinderGeometry(platformRadius, platformRadius + 0.3, platformHeight, 8);
            const platformMat = new THREE.MeshStandardMaterial({
                color: 0x6a5f5a,
                metalness: 0.1,
                roughness: 0.9
            });
            const centerPlatform = new THREE.Mesh(platformGeo, platformMat);
            centerPlatform.position.set(0, platformHeight / 2, 0);
            centerPlatform.castShadow = true;
            centerPlatform.receiveShadow = true;
            scene.add(centerPlatform);
            floorMeshes.push(centerPlatform);

            // Platform edge
            const platformEdgeGeo = new THREE.TorusGeometry(platformRadius, 0.1, 8, 8);
            const platformEdgeMat = new THREE.MeshStandardMaterial({
                color: 0x8e6d3f,
                metalness: 0.6,
                roughness: 0.4
            });
            const platformEdge = new THREE.Mesh(platformEdgeGeo, platformEdgeMat);
            platformEdge.rotation.x = -Math.PI / 2;
            platformEdge.position.y = platformHeight + 0.05;
            scene.add(platformEdge);

            // Main pillars (WoW Arena classic formation)
            const pillarPositions = [
                { x: 10, z: 10 }, { x: -10, z: 10 },
                { x: 10, z: -10 }, { x: -10, z: -10 }
            ];

            arenaObstacles.length = 0;
            collisionObjects.length = 0;

            // Load custom pillar
            let pillarBase = null;
            let pillarLargeBase = null;
            try {
                const [pSmall, pLarge] = await Promise.all([
                    loadGLTFModel(MODEL_URLS.pillar).catch(() => null),
                    loadGLTFModel(MODEL_URLS.pillarLarge).catch(() => null)
                ]);
                pillarBase = pSmall;
                pillarLargeBase = pLarge;
            } catch (e) {
                console.warn("Could not load pillar models:", e);
            }

            pillarPositions.forEach((pos, idx) => {
                if (pillarBase) {
                    const pillar = pillarBase.clone();
                    pillar.scale.set(10, 10, 10); // Scaled to replace smaller arena pillars
                    // Adjust Y so the base sits on the ground (approx 4-5 units for this scale)
                    pillar.position.set(pos.x, 4.2, pos.z);
                    pillar.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(pillar);
                    
                    // Add to LOS obstacles
                    arenaObstacles.push(pillar);
                    
                    // Add collision data
                    collisionObjects.push({
                        x: pos.x,
                        z: pos.z,
                        radius: 2.5
                    });
                } else {
                    const pillarGroup = new THREE.Group();
                    
                    // Base
                    const baseGeo = new THREE.CylinderGeometry(2.5, 2.8, 1.2, 12);
                    const baseMat = new THREE.MeshStandardMaterial({
                        color: 0x4a4035,
                        metalness: 0.2,
                        roughness: 0.8
                    });
                    const base = new THREE.Mesh(baseGeo, baseMat);
                    base.position.y = 0.6;
                    base.castShadow = true;
                    pillarGroup.add(base);

                    // Column (The actual LOS blocker)
                    const columnGeo = new THREE.CylinderGeometry(2.0, 2.2, 12, 16);
                    const columnMat = new THREE.MeshStandardMaterial({
                        color: 0x5a5045,
                        metalness: 0.1,
                        roughness: 0.9
                    });
                    const column = new THREE.Mesh(columnGeo, columnMat);
                    column.position.y = 6;
                    column.castShadow = true;
                    column.receiveShadow = true;
                    pillarGroup.add(column);

                    // Add Banners to Pillars
                    const bannerGeo = new THREE.PlaneGeometry(2, 5);
                    const bannerMat = new THREE.MeshStandardMaterial({
                        color: idx % 2 === 0 ? 0x4444ff : 0xff4444, // Team colors
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    const banner = new THREE.Mesh(bannerGeo, bannerMat);
                    banner.position.set(0, 8, 2.1);
                    pillarGroup.add(banner);

                    // Capital
                    const capitalGeo = new THREE.CylinderGeometry(2.8, 2.2, 1.5, 12);
                    const capitalMat = new THREE.MeshStandardMaterial({
                        color: 0x4a4035,
                        metalness: 0.4,
                        roughness: 0.6
                    });
                    const capital = new THREE.Mesh(capitalGeo, capitalMat);
                    capital.position.y = 12;
                    capital.castShadow = true;
                    pillarGroup.add(capital);

                    pillarGroup.position.set(pos.x, 0, pos.z);
                    scene.add(pillarGroup);
                    
                    // Add to LOS obstacles
                    arenaObstacles.push(column);
                    
                    // Add collision data
                    collisionObjects.push({
                        x: pos.x,
                        z: pos.z,
                        radius: 2.5
                    });
                }
            });

            // Secondary LoS breaks (Small rubble/boxes)
            const smallObstacles = [
                { x: 0, z: 12 }, { x: 0, z: -12 },
                { x: 12, z: 0 }, { x: -12, z: 0 }
            ];

            smallObstacles.forEach(pos => {
                if (pillarLargeBase) {
                    const pillar = pillarLargeBase.clone();
                    pillar.scale.set(6, 6, 6); // Smaller than main pillars but substantial
                    pillar.position.set(pos.x, 2.8, pos.z);
                    pillar.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(pillar);
                    arenaObstacles.push(pillar);
                } else {
                    const boxGeo = new THREE.BoxGeometry(2, 3, 2);
                    const boxMat = new THREE.MeshStandardMaterial({ color: 0x3a3530 });
                    const box = new THREE.Mesh(boxGeo, boxMat);
                    box.position.set(pos.x, 1.5, pos.z);
                    box.castShadow = true;
                    box.receiveShadow = true;
                    scene.add(box);
                    arenaObstacles.push(box);
                }
                collisionObjects.push({ x: pos.x, z: pos.z, radius: 1.5 });
            });

            // Corner braziers
            const brazierPositions = [
                { x: 15, z: 15 }, { x: -15, z: 15 },
                { x: 15, z: -15 }, { x: -15, z: -15 }
            ];

            brazierPositions.forEach(pos => {
                const standGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
                const standMat = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const stand = new THREE.Mesh(standGeo, standMat);
                stand.position.set(pos.x, 1, pos.z);
                stand.castShadow = true;
                scene.add(stand);

                const bowlGeo = new THREE.SphereGeometry(0.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const bowlMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    metalness: 0.7,
                    roughness: 0.4
                });
                const bowl = new THREE.Mesh(bowlGeo, bowlMat);
                bowl.position.set(pos.x, 2.2, pos.z);
                bowl.castShadow = true;
                scene.add(bowl);

                const fireGeo = new THREE.SphereGeometry(0.4, 16, 16);
                const fireMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.7
                });
                const fire = new THREE.Mesh(fireGeo, fireMat);
                fire.position.set(pos.x, 2.5, pos.z);
                scene.add(fire);

                const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xff8800,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(pos.x, 2.5, pos.z);
                scene.add(glow);
            });

            // Boundary ring
            const ringGeo = new THREE.TorusGeometry(floorRadius, 0.5, 12, 64);
            const ringMat = new THREE.MeshStandardMaterial({
                color: 0x4a90e2,
                emissive: 0x2a70c2,
                emissiveIntensity: 0.6,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const outerRing = new THREE.Mesh(ringGeo, ringMat);
            outerRing.rotation.x = -Math.PI / 2;
            outerRing.position.y = 0.2;
            scene.add(outerRing);
            window.arenaRing = outerRing;
        }
            
        async function createArenaGates() {
            // Arena Gates (starting positions)
            const gatePositions = [
                { x: 0, z: 18, team: 'ally' },
                { x: 0, z: -18, team: 'enemy' }
            ];
            
            window.arenaGates = [];
            
            for (const pos of gatePositions) {
                const gateGroup = new THREE.Group();
                
                // Use Pillar models for gate frame to match Nagrand/Blade's Edge fidelity
                try {
                    // Pillar models have center-origin, so we need a Y offset to sit on the ground
                    // At scale 4, bumped to 2.5 (base was still clipping through ground at 1.7)
                    const pillarYOffset = 2.5;

                    // LEFT PILLAR
                    const frameLeft = await loadGLTFModel(MODEL_URLS.pillar, {
                        scale: 4,
                        position: new THREE.Vector3(-2.2, pillarYOffset, 0)
                    });
                    gateGroup.add(frameLeft);

                    // RIGHT PILLAR
                    const frameRight = await loadGLTFModel(MODEL_URLS.pillar, {
                        scale: 4,
                        position: new THREE.Vector3(2.2, pillarYOffset, 0)
                    });
                    gateGroup.add(frameRight);

                    // TOP BEAM (Procedural but matching style)
                    const frameTop = new THREE.Mesh(
                        new THREE.BoxGeometry(5, 0.5, 0.5),
                        new THREE.MeshStandardMaterial({ color: 0x2a2520, metalness: 0.7, roughness: 0.3 })
                    );
                    frameTop.position.set(0, 8.3, 0);
                    gateGroup.add(frameTop);
                } catch (e) {
                    console.error("Failed to load gate pillars, using procedural fallback", e);
                    // Fallback frames
                    const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5, 7.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x2a2520 }));
                    frameLeft.position.set(-2, 3.75, 0);
                    gateGroup.add(frameLeft);
                    const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.5, 7.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x2a2520 }));
                    frameRight.position.set(2, 3.75, 0);
                    gateGroup.add(frameRight);
                }
                
                // Energy barrier (Tall enough for Orcs/Taurens)
                const barrierGeo = new THREE.PlaneGeometry(4, 7.5);
                const barrierColor = pos.team === 'ally' ? 0x4a90e2 : 0xe24a4a;
                const barrierMat = new THREE.MeshBasicMaterial({
                    color: barrierColor,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const barrier = new THREE.Mesh(barrierGeo, barrierMat);
                barrier.position.set(0, 3.75, 0);
                gateGroup.add(barrier);
                
                // Barrier glow
                const glowGeo = new THREE.PlaneGeometry(4.5, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: barrierColor,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(0, 3.75, 0.1);
                gateGroup.add(glow);
                
                gateGroup.position.set(pos.x, 0, pos.z);
                gateGroup.rotation.y = pos.z > 0 ? 0 : Math.PI;
                scene.add(gateGroup);
                
                window.arenaGates.push({
                    group: gateGroup,
                    barrier: barrier,
                    glow: glow,
                    team: pos.team
                });
            }
        }

        // ============================================
        // GEAR VISUALS
        // ============================================

        /**
         * Apply visual gear to a character group based on equipped items.
         */
        function applyVisualGear(character) {
            if (character.userData.isEnemy) return; // For now only player team gets visuals
            
            // Remove existing gear attachments
            const toRemove = [];
            character.traverse(child => {
                if (child.userData.isGearAttachment) toRemove.push(child);
            });
            toRemove.forEach(child => child.parent.remove(child));

            const gear = gameState.equippedGear;
            
            // Check if we have a GLTF model with its own weapons
            let hasModelWeapon = false;
            character.traverse(child => {
                if (child.userData.isWeapon && !child.userData.isGearAttachment) hasModelWeapon = true;
            });

            // HEAD (Helmet)
            if (gear.head) {
                const helmGeo = new THREE.BoxGeometry(0.45, 0.55, 0.45);
                const helmMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700, metalness: 0.8, roughness: 0.2 
                });
                const helm = new THREE.Mesh(helmGeo, helmMat);
                helm.position.y = 2.05;
                helm.userData.isGearAttachment = true;
                character.add(helm);
            }

            // SHOULDERS (Pauldrons)
            if (gear.shoulders) {
                const shoulderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const shoulderMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700, metalness: 0.8, roughness: 0.2 
                });
                
                const leftP = new THREE.Mesh(shoulderGeo, shoulderMat);
                leftP.position.set(-0.55, 1.8, 0);
                leftP.userData.isGearAttachment = true;
                character.add(leftP);

                const rightP = new THREE.Mesh(shoulderGeo, shoulderMat);
                rightP.position.set(0.55, 1.8, 0);
                rightP.userData.isGearAttachment = true;
                character.add(rightP);
            }

            // WEAPON (Only if no model weapon exists, e.g. fallback)
            if (gear.weapon && !hasModelWeapon) {
                const weaponGeo = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                const weaponMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700, metalness: 0.9, roughness: 0.1 
                });
                const weapon = new THREE.Mesh(weaponGeo, weaponMat);
                weapon.position.set(0.6, 1.2, 0);
                weapon.rotation.x = Math.PI / 4;
                weapon.userData.isGearAttachment = true;
                weapon.userData.isWeapon = true; // Mark as weapon for enchants
                character.add(weapon);
            }
            
            // Always apply enchant to whatever weapons are found (model or gear)
            if (gear.enchant) {
                applyWeaponEnchant(character);
            }
        }

        function applyWeaponEnchant(character) {
            // Enemies don't get team enchants for now, but could be added for elite enemies
            const gear = character.userData.isEnemy ? { enchant: null } : gameState.equippedGear;
            const enchantId = gear.enchant;
            
            // Find weapon mesh(es) in the character hierarchy
            let weaponsFound = 0;
            character.traverse(child => {
                // IMPORTANT: Skip already processed enchant visuals to avoid infinite recursion when cloning
                if (child.userData.isEnchantVisual) return;

                if (child.userData.isWeapon) {
                    weaponsFound++;
                    // Remove existing enchant effects
                    const toRemove = [];
                    child.traverse(grandChild => {
                        if (grandChild.userData.isEnchantVisual) toRemove.push(grandChild);
                    });
                    toRemove.forEach(gc => {
                        if (gc.parent) gc.parent.remove(gc);
                        if (gc.geometry) gc.geometry.dispose();
                        if (gc.material) gc.material.dispose();
                    });

                    if (enchantId) {
                        const enchant = ENCHANTS[enchantId];
                        if (enchant) {
                            // 1. Add subtle outer glow (slightly larger than original mesh)
                            // We clone the mesh, make it slightly larger and transparent
                            const glow = child.clone();
                            glow.scale.set(1.15, 1.15, 1.15); // Slightly larger
                            glow.traverse(c => {
                                if (c.isMesh) {
                                    c.material = new THREE.MeshBasicMaterial({
                                        color: enchant.color,
                                        transparent: true,
                                        opacity: 0.2,
                                        blending: THREE.AdditiveBlending
                                    });
                                }
                                c.userData.isEnchantVisual = true;
                                c.userData.isWeapon = false; // CRITICAL: Stop infinite recursion during traverse!
                            });
                            glow.userData.isEnchantVisual = true;
                            glow.userData.isWeapon = false; // CRITICAL: Stop infinite recursion during traverse!
                            child.add(glow);

                            // 2. Add an inner core glow or particles
                            for (let i = 0; i < 8; i++) {
                                const sparkGeo = new THREE.SphereGeometry(0.04, 4, 4);
                                const sparkMat = new THREE.MeshBasicMaterial({ 
                                    color: enchant.color, 
                                    transparent: true,
                                    opacity: 0.8,
                                    blending: THREE.AdditiveBlending 
                                });
                                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                                spark.userData.isEnchantVisual = true;
                                spark.userData.isEnchantParticle = true;
                                spark.userData.isWeapon = false;
                                spark.userData.pSpeed = 0.01 + Math.random() * 0.03;
                                spark.userData.pDir = Math.random() > 0.5 ? 1 : -1;
                                
                                // Position randomly along the "length" of the weapon
                                spark.position.y = (Math.random() - 0.5) * 1.6;
                                spark.position.x = (Math.random() - 0.5) * 0.15;
                                spark.position.z = (Math.random() - 0.5) * 0.15;
                                
                                child.add(spark);
                            }
                        }
                    }
                }
            });
        }

        // ============================================
        // CHARACTER CREATION (AAA Quality WoW-Style)
        // ============================================
        async function createCharacter(classType, isEnemy) {
            const classData = CLASSES[classType];
            const group = new THREE.Group();

            if (classType === 'warrior') {
                await createWarriorModel(group, classData, isEnemy);
            } else if (classType === 'death_knight') {
                await createDeathKnightModel(group, classData, isEnemy);
            } else if (classType === 'demon_hunter') {
                await createDemonHunterModel(group, classData, isEnemy);
            } else if (classType === 'hunter') {
                await createHunterModel(group, classData, isEnemy);
            } else if (classType === 'priest') {
                await createPriestModel(group, classData, isEnemy);
            } else if (classType === 'druid') {
                await createDruidModel(group, classData, isEnemy);
            } else if (classType === 'mage') {
                await createMageModel(group, classData, isEnemy);
            } else if (classType === 'paladin') {
                await createPaladinModel(group, classData, isEnemy);
            } else if (classType === 'rogue') {
                await createRogueModel(group, classData, isEnemy);
            } else if (classType === 'shaman') {
                await createShamanModel(group, classData, isEnemy);
            } else if (classType === 'warlock') {
                await createWarlockModel(group, classData, isEnemy);
            } else if (classType === 'monk') {
                await createMonkModel(group, classData, isEnemy);
            }

            // Team indicator ring at feet
            const ringGeo = new THREE.TorusGeometry(0.7, 0.06, 16, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: isEnemy ? 0xff4444 : 0x4444ff,
                transparent: true,
                opacity: 0.8
            });
            const indicatorRing = new THREE.Mesh(ringGeo, ringMat);
            indicatorRing.rotation.x = -Math.PI / 2;
            indicatorRing.position.y = 0.05;
            group.add(indicatorRing);

            // Preserve existing userData (like pets added in createWarlockModel/createHunterModel)
            const existingUserData = group.userData;
            group.userData = {
                ...existingUserData,
                classType,
                classData,
                health: classData.health,
                maxHealth: classData.health,
                damage: classData.damage,
                abilities: classData.abilities.map(a => ({...a, currentCooldown: 0})),
                isEnemy,
                target: null,
                ccUntil: 0,
                ccType: null,
                drStacks: 0,
                drResetTimer: 0,
                mana: 0,
                maxMana: 0,
                manaRegen: 0,
                resilience: 0,
                healingReduction: 0,
                buffUntil: 0,
                buffType: null,
                nameplateId: Math.random().toString(36).substr(2, 9),
                // Movement - Velocity-based system (conquest swiftness applied later)
                baseMoveSpeed: classData.role === 'melee' ? 4 : 2.5,
                moveSpeed: classData.role === 'melee' ? 4 : 2.5,
                velocity: new THREE.Vector3(0, 0, 0),
                desiredVelocity: new THREE.Vector3(0, 0, 0),
                currentWaypoint: null, // For multi-level navigation
                stuckTimer: 0,
                lastPosition: new THREE.Vector3(0, 0, 0),
                // Animation state machine
                animState: 'idle', // idle, walk, run, sprint
                animStateTime: 0,
                prevAnimState: 'idle',
                stateTransitionProgress: 1.0, // 0-1 for blending
                walkCyclePhase: 0,
                leanAmount: 0, // For turning lean
                targetLean: 0,
                // Foot placement for IK
                leftFootPhase: 0,
                rightFootPhase: Math.PI,
                leftFootHeight: 0,
                rightFootHeight: 0,
                // Animation state
                animationTime: Math.random() * Math.PI * 2,
                animationSpeed: 1 + Math.random() * 0.5,
                bodyBob: 0,
                breathingPhase: Math.random() * Math.PI * 2,
                // Global Cooldown
                gcdUntil: 0,
                // Animation triggers
                castingUntil: 0,
                castingType: null,
                attackingUntil: 0,
                attackType: null, // 'melee', 'bow', 'cast'
                attackProgress: 0,
                // PvP Trinket
                trinketCooldown: 0,
                trinketAvailable: true,
                // Aura system (Buffs/Debuffs)
                auras: [],
                comboPoints: 0
            };

            // Create nameplate
            createNameplate(group.userData.nameplateId, classData.name, isEnemy, classType);

            return group;
        }

        // ============================================
        // WARRIOR MODEL (Heavy Plate Armor)
        // ============================================
        async function createDemonHunterModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.demon_hunter, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Demon Hunter model loaded');
            } catch (e) {
                console.error('Failed to load Demon Hunter model, falling back to procedural:', e);
                const leatherColor = 0x1a1a1a; // Dark leather
                const felColor = 0x32ff00; // Bright Fel Green
                
                // Materials
                const leatherMaterial = new THREE.MeshStandardMaterial({ color: leatherColor, metalness: 0.1, roughness: 0.8 });
                const felMaterial = new THREE.MeshStandardMaterial({ 
                    color: felColor, 
                    emissive: felColor, 
                    emissiveIntensity: 0.8 
                });

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.16, 0.2, 0.9, 8);
                const leftLeg = new THREE.Mesh(legGeo, leatherMaterial);
                leftLeg.position.set(-0.2, 0.45, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, leatherMaterial);
                rightLeg.position.set(0.2, 0.45, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                // Torso (exposed chest with glowing tattoos)
                const torsoGeo = new THREE.BoxGeometry(0.6, 0.9, 0.35);
                const torso = new THREE.Mesh(torsoGeo, new THREE.MeshStandardMaterial({ color: 0x4d3228 })); // Skin tone
                torso.position.y = 1.35;
                torso.castShadow = true;
                group.add(torso);

                // Tattoos
                const tattoo1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.05), felMaterial);
                tattoo1.position.set(0, 1.5, 0.18);
                group.add(tattoo1);
                const tattoo2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.05), felMaterial);
                tattoo2.position.set(0, 1.3, 0.18);
                group.add(tattoo2);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.12, 0.14, 0.7, 8);
                const leftArm = new THREE.Mesh(armGeo, leatherMaterial);
                leftArm.position.set(-0.4, 1.2, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeo, leatherMaterial);
                rightArm.position.set(0.4, 1.2, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                // Head (with blindfold and horns)
                const headGeo = new THREE.BoxGeometry(0.35, 0.45, 0.35);
                const head = new THREE.Mesh(headGeo, new THREE.MeshStandardMaterial({ color: 0x4d3228 }));
                head.position.y = 2.0;
                group.add(head);

                // Blindfold
                const blindfold = new THREE.Mesh(new THREE.BoxGeometry(0.36, 0.1, 0.36), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                blindfold.position.y = 2.05;
                group.add(blindfold);

                // Horns
                const hornGeo = new THREE.CylinderGeometry(0.02, 0.05, 0.4, 8);
                const leftHorn = new THREE.Mesh(hornGeo, new THREE.MeshStandardMaterial({ color: 0x222222 }));
                leftHorn.position.set(-0.15, 2.3, 0.05);
                leftHorn.rotation.z = -Math.PI / 6;
                group.add(leftHorn);

                const rightHorn = new THREE.Mesh(hornGeo, new THREE.MeshStandardMaterial({ color: 0x222222 }));
                rightHorn.position.set(0.15, 2.3, 0.05);
                rightHorn.rotation.z = Math.PI / 6;
                group.add(rightHorn);

                // Warglaives
                const glaiveGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16, Math.PI);
                const glaiveMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.1 });
                
                const leftGlaive = new THREE.Mesh(glaiveGeo, glaiveMaterial);
                leftGlaive.position.set(-0.6, 1.2, 0);
                leftGlaive.rotation.y = Math.PI / 2;
                group.add(leftGlaive);

                const rightGlaive = new THREE.Mesh(glaiveGeo, glaiveMaterial);
                rightGlaive.position.set(0.6, 1.2, 0);
                rightGlaive.rotation.y = Math.PI / 2;
                group.add(rightGlaive);
            }
        }

        async function createPaladinModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.paladin, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Human Paladin model loaded');
            } catch (e) {
                console.error('Failed to load Human Paladin model, falling back to procedural:', e);
                const plateColor = 0xffd700; // Gold
                const holyColor = 0xffffaa; // Pale Yellow
                
                // Materials
                const plateMaterial = new THREE.MeshStandardMaterial({
                    color: plateColor,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                const holyMaterial = new THREE.MeshStandardMaterial({
                    color: holyColor,
                    emissive: holyColor,
                    emissiveIntensity: 0.6
                });

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
                const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
                
                const leftLeg = new THREE.Mesh(legGeo, armorMaterial);
                leftLeg.position.set(-0.2, 0.45, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, armorMaterial);
                rightLeg.position.set(0.2, 0.45, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                // Torso (gold breastplate)
                const torsoGeo = new THREE.BoxGeometry(0.7, 0.9, 0.45);
                const torso = new THREE.Mesh(torsoGeo, plateMaterial);
                torso.position.y = 1.35;
                torso.castShadow = true;
                group.add(torso);

                // Cross emblem on chest
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.05), holyMaterial);
                crossH.position.set(0, 1.45, 0.23);
                group.add(crossH);
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.05), holyMaterial);
                crossV.position.set(0, 1.45, 0.23);
                group.add(crossV);

                // Shoulders
                const shoulderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const leftShoulder = new THREE.Mesh(shoulderGeo, plateMaterial);
                leftShoulder.position.set(-0.5, 1.8, 0);
                leftShoulder.castShadow = true;
                group.add(leftShoulder);

                const rightShoulder = new THREE.Mesh(shoulderGeo, plateMaterial);
                rightShoulder.position.set(0.5, 1.8, 0);
                rightShoulder.castShadow = true;
                group.add(rightShoulder);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.14, 0.16, 0.7, 8);
                const leftArm = new THREE.Mesh(armGeo, armorMaterial);
                leftArm.position.set(-0.45, 1.2, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeo, armorMaterial);
                rightArm.position.set(0.45, 1.2, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                // Head (Knight helmet)
                const helmetGeo = new THREE.BoxGeometry(0.4, 0.5, 0.4);
                const helmet = new THREE.Mesh(helmetGeo, plateMaterial);
                helmet.position.y = 2.05;
                helmet.castShadow = true;
                group.add(helmet);

                // Mace/Hammer
                const handleGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8);
                const handle = new THREE.Mesh(handleGeo, new THREE.MeshStandardMaterial({ color: 0x4a3a25 }));
                handle.position.set(0.6, 1.4, 0);
                group.add(handle);
                
                const headGeo = new THREE.BoxGeometry(0.3, 0.4, 0.3);
                const head = new THREE.Mesh(headGeo, plateMaterial);
                head.position.set(0.6, 2.0, 0);
                group.add(head);
            }
        }

        async function createRogueModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.rogue, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Undead Rogue model loaded');
            } catch (e) {
                console.error('Failed to load Undead Rogue model, falling back to procedural:', e);
                const leatherColor = 0x221100; // Deep Brown
                const metalColor = 0x555555; // Steel
                
                // Materials
                const leatherMaterial = new THREE.MeshStandardMaterial({
                    color: leatherColor,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                const steelMaterial = new THREE.MeshStandardMaterial({
                    color: metalColor,
                    metalness: 0.9,
                    roughness: 0.2
                });

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.9, 8);
                const leftLeg = new THREE.Mesh(legGeo, leatherMaterial);
                leftLeg.position.set(-0.2, 0.45, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, leatherMaterial);
                rightLeg.position.set(0.2, 0.45, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                // Torso (sleek leather)
                const torsoGeo = new THREE.BoxGeometry(0.5, 0.9, 0.35);
                const torso = new THREE.Mesh(torsoGeo, leatherMaterial);
                torso.position.y = 1.35;
                torso.castShadow = true;
                group.add(torso);

                // Hood
                const hoodGeo = new THREE.SphereGeometry(0.3, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                const hood = new THREE.Mesh(hoodGeo, leatherMaterial);
                hood.position.y = 1.95;
                group.add(hood);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.12, 0.14, 0.7, 8);
                const leftArm = new THREE.Mesh(armGeo, leatherMaterial);
                leftArm.position.set(-0.4, 1.2, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeo, leatherMaterial);
                rightArm.position.set(0.4, 1.2, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                // Head (masked)
                const headGeo = new THREE.BoxGeometry(0.35, 0.45, 0.35);
                const head = new THREE.Mesh(headGeo, new THREE.MeshStandardMaterial({ color: 0x000000 }));
                head.position.y = 2.0;
                group.add(head);

                // Dual Daggers
                const daggerGeo = new THREE.BoxGeometry(0.05, 0.6, 0.02);
                const leftDagger = new THREE.Mesh(daggerGeo, steelMaterial);
                leftDagger.position.set(-0.5, 0.8, 0.2);
                leftDagger.rotation.x = Math.PI / 4;
                group.add(leftDagger);

                const rightDagger = new THREE.Mesh(daggerGeo, steelMaterial);
                rightDagger.position.set(0.5, 0.8, 0.2);
                rightDagger.rotation.x = Math.PI / 4;
                group.add(rightDagger);
            }
        }

        /**
         * Normalizes a model so its bottom-most point is at Y=0
         */
        function normalizeModelGrounding(model) {
            const box = new THREE.Box3().setFromObject(model);
            const height = box.max.y - box.min.y;
            // Move the internal model so its bottom is at 0 relative to its parent
            model.position.y = -box.min.y;
            return model;
        }

        // ============================================
        // WARLOCK MODEL & PET (Demonology/Shadow)
        // ============================================
        async function createHunterPet(isEnemy) {
            const petGroup = new THREE.Group();
            
            try {
                const model = await loadGLTFModel(MODEL_URLS.raptor, {
                    scale: 1.0
                });
                normalizeModelGrounding(model);
                petGroup.add(model);
                petGroup.userData.model = model;
                petGroup.userData.mixer = model.userData.mixer;
            } catch (e) {
                console.error('Failed to load Raptor model, falling back to procedural:', e);
                // Pet body
                const petBodyGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.7);
                const petMaterial = new THREE.MeshStandardMaterial({
                    color: isEnemy ? 0x8b0000 : 0x8b4513, 
                    metalness: 0.2,
                    roughness: 0.8
                });
                const petBody = new THREE.Mesh(petBodyGeometry, petMaterial);
                petBody.position.y = 0.3;
                petBody.castShadow = true;
                petGroup.add(petBody);

                const petHeadGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.3);
                const petHead = new THREE.Mesh(petHeadGeometry, petMaterial);
                petHead.position.set(0, 0.45, 0.4);
                petHead.castShadow = true;
                petGroup.add(petHead);

                const snoutGeo = new THREE.BoxGeometry(0.15, 0.12, 0.2);
                const snout = new THREE.Mesh(snoutGeo, petMaterial);
                snout.position.set(0, 0.4, 0.6);
                petGroup.add(snout);

                const earGeo = new THREE.BoxGeometry(0.05, 0.15, 0.05);
                const leftEar = new THREE.Mesh(earGeo, petMaterial);
                leftEar.position.set(-0.08, 0.6, 0.4);
                leftEar.rotation.x = -0.2;
                petGroup.add(leftEar);

                const rightEar = new THREE.Mesh(earGeo, petMaterial);
                rightEar.position.set(0.08, 0.6, 0.4);
                rightEar.rotation.x = -0.2;
                petGroup.add(rightEar);

                const petLegGeometry = new THREE.CylinderGeometry(0.06, 0.04, 0.3, 6);
                const legPositions = [
                    [-0.15, 0.15, 0.25],
                    [0.15, 0.15, 0.25],
                    [-0.15, 0.15, -0.2],
                    [0.15, 0.15, -0.2]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(petLegGeometry, petMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    petGroup.add(leg);
                });
            }

            // Initialize pet userData for independent AI
            petGroup.userData = {
                isPet: true,
                petType: 'hunter_pet',
                petName: 'Raptor',
                ownerRef: null,
                health: 20000,
                maxHealth: 20000,
                baseDamage: 2800,
                damage: 2800,
                moveSpeed: 5.0,
                velocity: new THREE.Vector3(0, 0, 0),
                desiredVelocity: new THREE.Vector3(0, 0, 0),
                target: null,
                lastAttackTime: 0,
                attackCooldown: 2.0,
                resilience: 0.15,
                // Realistic armor system: flat value converted via diminishing formula
                armor: 0.08,
                armorRating: 3200, // Raw armor rating (diminishing returns formula at match start)
                // Avoidance stats (hunter pets are physical ‚Äî dodge/parry)
                dodgeChance: 0.08, // 8% base dodge
                parryChance: 0.04, // 4% base parry (only vs melee)
                spellResist: 0.0,  // Hunters don't get magic resist
                // Resource: Focus (100 max, regenerates, spent on abilities)
                focus: 100,
                maxFocus: 100,
                focusRegen: 5.0, // per second
                healingReduction: 0,
                absorb: 0,
                ccUntil: 0,
                ccType: null,
                drState: {},
                // Crit stats (overwritten at match start by scaling)
                critChance: 0.15,
                critMult: 1.8,
                // Damage type: physical (affected by armor, can be dodged/parried)
                damageType: 'physical',
                // Stamina-derived HP bonus (set at match start)
                staminaBonus: 0,
                // Combat tracking (enhanced)
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                totalDamageAvoided: 0, // Tracks dodged/parried damage
                totalDamageBlocked: 0, // Tracks armor-mitigated damage
                killCount: 0,
                highestHit: 0,
                // Pet special abilities with cooldowns + focus costs
                abilities: {
                    claw: { cooldown: 0, maxCooldown: 3.0, damage: 3500, focusCost: 25, name: 'Claw', damageType: 'physical' },
                    bite: { cooldown: 0, maxCooldown: 10.0, damage: 6000, focusCost: 30, name: 'Kill Command', damageType: 'physical' },
                    dash: { cooldown: 0, maxCooldown: 25.0, duration: 4.0, focusCost: 0, name: 'Dash' },
                    roarOfSacrifice: { cooldown: 0, maxCooldown: 60.0, duration: 6.0, damageReduction: 0.2, focusCost: 0, name: 'Roar of Sacrifice' },
                    mend: { cooldown: 0, maxCooldown: 10.0, healPercent: 0.25, focusCost: 0, name: 'Mend Pet' }
                },
                dashUntil: 0,
                lastPosition: new THREE.Vector3(0, 0, 0),
                stuckTimer: 0,
                isEnemy,
                nameplateId: 'pet-' + Math.random().toString(36).substr(2, 9),
                auras: [],
                buffUntil: 0,
                buffType: null,
                // Passive regen when not in combat for 5s
                lastDamageTakenTime: 0,
                oocRegenRate: 0.03, // 3% max HP per second when OOC
                // Frenzy stacks (hunter pet mechanic: stacking attack speed buff)
                frenzyStacks: 0,
                frenzyUntil: 0,
                // Animation
                walkCyclePhase: 0,
                animState: 'idle',
                leftFootPhase: 0,
                rightFootPhase: Math.PI
            };
            
            return petGroup;
        }

        async function createWarlockPet(isEnemy) {
            const petGroup = new THREE.Group();
            
            try {
                const model = await loadGLTFModel(MODEL_URLS.felhunter, {
                    scale: 1.0
                });
                normalizeModelGrounding(model);
                petGroup.add(model);
                petGroup.userData.model = model;
                petGroup.userData.mixer = model.userData.mixer;
            } catch (e) {
                console.error('Failed to load Felhunter model, falling back to procedural:', e);
                // Pet body (slightly more sleek than wolf)
                const petBodyGeometry = new THREE.BoxGeometry(0.35, 0.22, 0.65);
                const petMaterial = new THREE.MeshStandardMaterial({
                    color: isEnemy ? 0x6b0000 : 0x6b008b, // Deep Red or Purple
                    metalness: 0.3,
                    roughness: 0.7
                });
                const petBody = new THREE.Mesh(petBodyGeometry, petMaterial);
                petBody.position.y = 0.28;
                petBody.castShadow = true;
                petGroup.add(petBody);

                const petHeadGeometry = new THREE.ConeGeometry(0.12, 0.25, 6);
                const petHead = new THREE.Mesh(petHeadGeometry, petMaterial);
                petHead.position.set(0, 0.35, 0.4);
                petHead.rotation.x = Math.PI / 2;
                petHead.castShadow = true;
                petGroup.add(petHead);

                const spikeGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.4, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                for (let i = -1; i <= 1; i += 2) {
                    const spike = new THREE.Mesh(spikeGeo, spikeMat);
                    spike.position.set(i * 0.1, 0.5, -0.1);
                    spike.rotation.x = -Math.PI / 6;
                    spike.rotation.z = i * 0.3;
                    petGroup.add(spike);
                }

                const petEyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const petEyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x32ff00,
                    emissive: 0x32ff00,
                    emissiveIntensity: 1.0
                });
                const leftEye = new THREE.Mesh(petEyeGeometry, petEyeMaterial);
                leftEye.position.set(-0.06, 0.38, 0.48);
                petGroup.add(leftEye);

                const rightEye = new THREE.Mesh(petEyeGeometry, petEyeMaterial);
                rightEye.position.set(0.06, 0.38, 0.48);
                petGroup.add(rightEye);

                const petLegGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.28, 6);
                const legPositions = [
                    [-0.14, 0.14, 0.2],
                    [0.14, 0.14, 0.2],
                    [-0.14, 0.14, -0.15],
                    [0.14, 0.14, -0.15]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(petLegGeometry, petMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    petGroup.add(leg);
                });
            }

            // Initialize pet userData for independent AI
            petGroup.userData = {
                isPet: true,
                petType: 'warlock_pet',
                petName: 'Felhunter',
                ownerRef: null,
                health: 18000,
                maxHealth: 18000,
                baseDamage: 2200,
                damage: 2200,
                moveSpeed: 5.5,
                velocity: new THREE.Vector3(0, 0, 0),
                desiredVelocity: new THREE.Vector3(0, 0, 0),
                target: null,
                lastAttackTime: 0,
                attackCooldown: 2.0,
                resilience: 0.15,
                // Felhunter: lighter armor but high spell resist
                armor: 0.05,
                armorRating: 1800, // Lower physical armor than hunter pet
                // Avoidance: Felhunter avoids magic, not melee
                dodgeChance: 0.03, // Minimal physical dodge
                parryChance: 0.0,  // No parry
                spellResist: 0.12, // 12% base magic resist (Felhunter signature)
                // Resource: Shadow Energy (regenerates slower, bigger abilities)
                focus: 100,
                maxFocus: 100,
                focusRegen: 4.0, // slightly slower than hunter
                healingReduction: 0,
                absorb: 0,
                ccUntil: 0,
                ccType: null,
                drState: {},
                // Crit stats (overwritten at match start by scaling)
                critChance: 0.15,
                critMult: 1.8,
                // Damage type: shadow/magic (bypasses armor, resisted by spell resist)
                damageType: 'shadow',
                // Stamina-derived HP bonus
                staminaBonus: 0,
                // Combat tracking (enhanced)
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                totalDamageAvoided: 0,
                totalDamageBlocked: 0,
                totalDamageRedirected: 0, // Soul Link redirected damage
                killCount: 0,
                highestHit: 0,
                // Pet special abilities with cooldowns + focus costs
                abilities: {
                    shadowBite: { cooldown: 0, maxCooldown: 4.0, damage: 3000, focusCost: 25, name: 'Shadow Bite', damageType: 'shadow' },
                    spellLock: { cooldown: 0, maxCooldown: 24.0, duration: 6, focusCost: 20, name: 'Spell Lock' },
                    devourMagic: { cooldown: 0, maxCooldown: 15.0, name: 'Devour Magic', healPercent: 0.05, focusCost: 15 },
                    felIntelligence: { cooldown: 0, maxCooldown: 0, name: 'Fel Intelligence', passive: true },
                    soulLink: { cooldown: 0, maxCooldown: 0, name: 'Soul Link', passive: true, damageShared: 0.20 }
                },
                // Soul Link state tracking
                soulLinkActive: false,
                soulLinkDamagePool: 0, // Accumulates redirected damage to avoid feedback loops
                lastPosition: new THREE.Vector3(0, 0, 0),
                stuckTimer: 0,
                isEnemy,
                nameplateId: 'pet-' + Math.random().toString(36).substr(2, 9),
                auras: [],
                buffUntil: 0,
                buffType: null,
                // Passive regen when not in combat for 5s
                lastDamageTakenTime: 0,
                oocRegenRate: 0.02, // 2% max HP per second OOC (lower than hunter)
                // Animation
                walkCyclePhase: 0,
                animState: 'idle',
                leftFootPhase: 0,
                rightFootPhase: Math.PI
            };
            
            return petGroup;
        }

        async function createWarlockModel(group, classData, isEnemy) {
            try {
                // Spawn Warlock Pet
                const pet = await createWarlockPet(isEnemy);
                group.userData.pet = pet;
                
                const model = await loadCharacterWithAnimations(MODEL_URLS.warlock, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Warlock model loaded');
            } catch (e) {
                console.error('Failed to load Warlock model, falling back to procedural:', e);
                // ... rest of the procedural fallback
                const robeColor = 0x1a1a1a; // Dark Black/Grey
                const felColor = 0x32ff00; // Bright Fel Green
                const accentColor = isEnemy ? 0x8b0000 : 0x9932cc; // Deep Purple for allies
                
                const robeMaterial = new THREE.MeshStandardMaterial({
                    color: robeColor,
                    metalness: 0.2,
                    roughness: 0.7
                });

                // Legs (robe bottom)
                const robeBottomGeometry = new THREE.ConeGeometry(0.45, 0.9, 8);
                const robeBottom = new THREE.Mesh(robeBottomGeometry, robeMaterial);
                robeBottom.position.y = 0.45;
                robeBottom.castShadow = true;
                group.add(robeBottom);

                // Torso
                const torsoGeometry = new THREE.CylinderGeometry(0.32, 0.38, 0.75, 8);
                const torso = new THREE.Mesh(torsoGeometry, robeMaterial);
                torso.position.y = 1.3;
                torso.castShadow = true;
                group.add(torso);

                // Shadow runes on chest
                const runeGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.05);
                const runeMaterial = new THREE.MeshStandardMaterial({
                    color: felColor,
                    emissive: felColor,
                    emissiveIntensity: 0.8
                });
                const rune = new THREE.Mesh(runeGeometry, runeMaterial);
                rune.position.set(0, 1.4, 0.2);
                rune.rotation.z = Math.PI / 4;
                group.add(rune);

                // Shoulders (Spiky Dread-pauldrons)
                const shoulderGeometry = new THREE.BoxGeometry(0.35, 0.25, 0.35);
                const shoulderMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.2
                });

                const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                leftShoulder.position.set(-0.45, 1.6, 0);
                leftShoulder.rotation.z = 0.3;
                leftShoulder.castShadow = true;
                group.add(leftShoulder);

                const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                rightShoulder.position.set(0.45, 1.6, 0);
                rightShoulder.rotation.z = -0.3;
                rightShoulder.castShadow = true;
                group.add(rightShoulder);

                // Spikes on shoulders
                const spikeGeo = new THREE.ConeGeometry(0.05, 0.3, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9 });
                for (let i = -1; i <= 1; i++) {
                    const leftSpike = new THREE.Mesh(spikeGeo, spikeMat);
                    leftSpike.position.set(-0.45 + i * 0.1, 1.8, 0);
                    group.add(leftSpike);
                    
                    const rightSpike = new THREE.Mesh(spikeGeo, spikeMat);
                    rightSpike.position.set(0.45 + i * 0.1, 1.8, 0);
                    group.add(rightSpike);
                }

                // Head (masked/hooded)
                const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.9;
                group.add(head);

                // Glowing eyes
                const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: felColor });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.1, 1.95, 0.2);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.1, 1.95, 0.2);
                group.add(rightEye);

                // Hood
                const hoodGeometry = new THREE.ConeGeometry(0.35, 0.5, 8);
                const hood = new THREE.Mesh(hoodGeometry, robeMaterial);
                hood.position.y = 2.2;
                group.add(hood);

                // Scythe Staff (Gul'dan style)
                const staffHandleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 2.2, 8);
                const staffHandle = new THREE.Mesh(staffHandleGeometry, new THREE.MeshStandardMaterial({ color: 0x3d2b1f }));
                staffHandle.position.set(-0.5, 1.5, 0.2);
                staffHandle.rotation.x = 0.2;
                group.add(staffHandle);

                // Scythe blade
                const bladeGeo = new THREE.BoxGeometry(0.6, 0.1, 0.02);
                const bladeMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9, roughness: 0.1 });
                const blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.position.set(-0.7, 2.4, 0.2);
                blade.rotation.z = -0.5;
                group.add(blade);

                // Skull on staff
                const skullGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const skullMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
                const skull = new THREE.Mesh(skullGeo, skullMat);
                skull.position.set(-0.5, 2.5, 0.2);
                group.add(skull);
            }
        }

        async function createShamanModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.shaman, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Tauren Shaman model loaded');
            } catch (e) {
                console.error('Failed to load Tauren Shaman model, falling back to procedural:', e);
                const mainColor = 0x0070de; // Shaman Blue
                const armorColor = 0x4a4a4a; // Mail armor grey
                const elementalColor = isEnemy ? 0xff4400 : 0x00ffff; // Fire or Water
                
                const armorMaterial = new THREE.MeshStandardMaterial({
                    color: armorColor,
                    metalness: 0.5,
                    roughness: 0.4
                });

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
                const leftLeg = new THREE.Mesh(legGeo, armorMaterial);
                leftLeg.position.set(-0.25, 0.45, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, armorMaterial);
                rightLeg.position.set(0.25, 0.45, 0);
                group.add(rightLeg);

                // Torso
                const torsoGeo = new THREE.BoxGeometry(0.7, 0.9, 0.4);
                const torso = new THREE.Mesh(torsoGeo, armorMaterial);
                torso.position.y = 1.35;
                group.add(torso);

                // Totems on back
                const totemGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
                const totemMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                
                const leftTotem = new THREE.Mesh(totemGeo, totemMat);
                leftTotem.position.set(-0.3, 1.5, -0.3);
                leftTotem.rotation.x = -0.2;
                group.add(leftTotem);
                
                const rightTotem = new THREE.Mesh(totemGeo, totemMat);
                rightTotem.position.set(0.3, 1.5, -0.3);
                rightTotem.rotation.x = -0.2;
                group.add(rightTotem);

                // Elemental glow on totems
                const totemGlowGeo = new THREE.BoxGeometry(0.22, 0.1, 0.22);
                const totemGlowMat = new THREE.MeshBasicMaterial({ color: elementalColor });
                const totemGlow = new THREE.Mesh(totemGlowGeo, totemGlowMat);
                totemGlow.position.set(0, 0.2, 0);
                leftTotem.add(totemGlow.clone());
                rightTotem.add(totemGlow);

                // Shoulders (Wolf heads or large stone pauldrons)
                const shoulderGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const leftShoulder = new THREE.Mesh(shoulderGeo, armorMaterial);
                leftShoulder.position.set(-0.5, 1.6, 0);
                leftShoulder.scale.set(1.2, 0.8, 1);
                group.add(leftShoulder);
                
                const rightShoulder = new THREE.Mesh(shoulderGeo, armorMaterial);
                rightShoulder.position.set(0.5, 1.6, 0);
                rightShoulder.scale.set(1.2, 0.8, 1);
                group.add(rightShoulder);

                // Head (with wolf hood)
                const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const head = new THREE.Mesh(headGeo, new THREE.MeshStandardMaterial({ color: 0xffe0bd }));
                head.position.y = 2.0;
                group.add(head);

                const wolfHoodGeo = new THREE.BoxGeometry(0.45, 0.25, 0.5);
                const wolfHood = new THREE.Mesh(wolfHoodGeo, new THREE.MeshStandardMaterial({ color: 0x888888 }));
                wolfHood.position.y = 2.15;
                wolfHood.position.z = -0.05;
                group.add(wolfHood);

                // Weapons (Dual maces)
                const maceHandleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8);
                const maceHeadGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const maceMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.8 });
                
                const leftMace = new THREE.Group();
                const lHandle = new THREE.Mesh(maceHandleGeo, maceMat);
                const lHead = new THREE.Mesh(maceHeadGeo, maceMat);
                lHead.position.y = 0.4;
                leftMace.add(lHandle);
                leftMace.add(lHead);
                leftMace.position.set(-0.5, 1.0, 0.3);
                leftMace.rotation.x = Math.PI / 2;
                group.add(leftMace);

                const rightMace = leftMace.clone();
                rightMace.position.set(0.5, 1.0, 0.3);
                group.add(rightMace);
                
                // Lightning effect on maces
                const lightningGeo = new THREE.TorusGeometry(0.18, 0.01, 8, 16);
                const lightningMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const lightning = new THREE.Mesh(lightningGeo, lightningMat);
                lightning.position.y = 0.4;
                lHead.add(lightning);
            }
        }

        async function createMonkModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.monk, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Monk model loaded');
            } catch (e) {
                console.error('Failed to load Monk model, falling back to procedural:', e);
                const leatherColor = 0x2d5a27; // Dark jade leather
                const jadeColor = 0x00ff96; // Bright jade
                const strawColor = 0xd2b48c; // Tan for hat
                
                const leatherMat = new THREE.MeshStandardMaterial({ color: leatherColor, roughness: 0.8 });
                const jadeMat = new THREE.MeshStandardMaterial({ 
                    color: jadeColor, 
                    emissive: jadeColor, 
                    emissiveIntensity: 0.5 
                });

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
                const leftLeg = new THREE.Mesh(legGeo, leatherMat);
                leftLeg.position.set(-0.2, 0.45, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, leatherMat);
                rightLeg.position.set(0.2, 0.45, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                // Torso (Vest)
                const torsoGeo = new THREE.BoxGeometry(0.65, 0.85, 0.4);
                const torso = new THREE.Mesh(torsoGeo, leatherMat);
                torso.position.y = 1.3;
                torso.castShadow = true;
                group.add(torso);

                // Belt
                const beltGeo = new THREE.BoxGeometry(0.68, 0.15, 0.42);
                const belt = new THREE.Mesh(beltGeo, new THREE.MeshStandardMaterial({ color: 0x111111 }));
                belt.position.y = 0.95;
                group.add(belt);

                // Prayer Beads (Neck)
                const beadGeo = new THREE.SphereGeometry(0.06, 8, 8);
                const beadMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const bead = new THREE.Mesh(beadGeo, beadMat);
                    bead.position.set(Math.cos(angle) * 0.2, 1.7, Math.sin(angle) * 0.2 + 0.1);
                    group.add(bead);
                }

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.13, 0.13, 0.7, 8);
                const leftArm = new THREE.Mesh(armGeo, new THREE.MeshStandardMaterial({ color: 0x4d3228 })); // Skin
                leftArm.position.set(-0.4, 1.25, 0);
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeo, new THREE.MeshStandardMaterial({ color: 0x4d3228 }));
                rightArm.position.set(0.4, 1.25, 0);
                group.add(rightArm);

                // Glowing Fists (Jade energy)
                const fistGeo = new THREE.SphereGeometry(0.15, 12, 12);
                const leftFist = new THREE.Mesh(fistGeo, jadeMat);
                leftFist.position.set(-0.4, 0.9, 0);
                group.add(leftFist);
                
                const rightFist = new THREE.Mesh(fistGeo, jadeMat);
                rightFist.position.set(0.4, 0.9, 0);
                group.add(rightFist);

                // Head
                const headGeo = new THREE.SphereGeometry(0.24, 16, 16);
                const head = new THREE.Mesh(headGeo, new THREE.MeshStandardMaterial({ color: 0x4d3228 }));
                head.position.y = 1.85;
                group.add(head);

                // Straw Hat (Kasa)
                const hatGeo = new THREE.ConeGeometry(0.55, 0.2, 16);
                const hat = new THREE.Mesh(hatGeo, new THREE.MeshStandardMaterial({ color: strawColor }));
                hat.position.y = 2.05;
                group.add(hat);

                // Tassels from hat
                const tasselGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.4, 4);
                const tasselMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
                const leftTassel = new THREE.Mesh(tasselGeo, tasselMat);
                leftTassel.position.set(-0.4, 1.8, 0);
                group.add(leftTassel);
                const rightTassel = new THREE.Mesh(tasselGeo, tasselMat);
                rightTassel.position.set(0.4, 1.8, 0);
                group.add(rightTassel);
            }
        }

        async function createWarriorModel(group, classData, isEnemy) {
            try {
                // Use a larger scale for the Orc Warrior
                const model = await loadCharacterWithAnimations(MODEL_URLS.warrior, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                // Store the mixer and actions on the group for easy access
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Orc Warrior model loaded');
            } catch (e) {
                console.error('Failed to load Orc Warrior model, falling back to procedural:', e);
                const mainColor = classData.color;
                const accentColor = isEnemy ? 0x8b0000 : 0xffd700;

            // Legs (armored)
            const legGeometry = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
            const armorMaterial = new THREE.MeshStandardMaterial({
                color: mainColor,
                metalness: 0.7,
                roughness: 0.3,
                envMapIntensity: 1
            });

            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.2, 0.45, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.2, 0.45, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);

            // Torso (broad chest plate)
            const torsoGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.4);
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 1.35;
            torso.castShadow = true;
            group.add(torso);

            // Chest detail (emblem)
            const emblemGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.05);
            const emblemMaterial = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.9,
                roughness: 0.1,
                emissive: accentColor,
                emissiveIntensity: 0.3
            });
            const emblem = new THREE.Mesh(emblemGeometry, emblemMaterial);
            emblem.position.set(0, 1.4, 0.23);
            emblem.castShadow = true;
            group.add(emblem);

            // Shoulders (massive pauldrons)
            const shoulderGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const shoulderMaterial = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.8,
                roughness: 0.2
            });

            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(-0.5, 1.75, 0);
            leftShoulder.rotation.z = 0.3;
            leftShoulder.castShadow = true;
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(0.5, 1.75, 0);
            rightShoulder.rotation.z = -0.3;
            rightShoulder.castShadow = true;
            group.add(rightShoulder);

            // Shoulder spikes
            const spikeGeometry = new THREE.ConeGeometry(0.08, 0.3, 6);
            const leftSpike = new THREE.Mesh(spikeGeometry, shoulderMaterial);
            leftSpike.position.set(-0.5, 2, 0);
            leftSpike.castShadow = true;
            group.add(leftSpike);

            const rightSpike = new THREE.Mesh(spikeGeometry, shoulderMaterial);
            rightSpike.position.set(0.5, 2, 0);
            rightSpike.castShadow = true;
            group.add(rightSpike);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.14, 0.16, 0.7, 8);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.45, 1.2, 0);
            leftArm.castShadow = true;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.45, 1.2, 0);
            rightArm.castShadow = true;
            group.add(rightArm);

            // Head (helmet)
            const helmetGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.4);
            const helmet = new THREE.Mesh(helmetGeometry, armorMaterial);
            helmet.position.y = 2.05;
            helmet.castShadow = true;
            group.add(helmet);

            // Helmet horns
            const hornGeometry = new THREE.ConeGeometry(0.06, 0.4, 6);
            const leftHorn = new THREE.Mesh(hornGeometry, shoulderMaterial);
            leftHorn.position.set(-0.15, 2.35, 0);
            leftHorn.rotation.z = -0.3;
            leftHorn.castShadow = true;
            group.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, shoulderMaterial);
            rightHorn.position.set(0.15, 2.35, 0);
            rightHorn.rotation.z = 0.3;
            rightHorn.castShadow = true;
            group.add(rightHorn);

            // Two-handed sword
            const swordHandleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
            const swordMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                metalness: 0.9,
                roughness: 0.2
            });
            const swordHandle = new THREE.Mesh(swordHandleGeometry, swordMaterial);
            swordHandle.position.set(0.6, 1.2, 0);
            swordHandle.castShadow = true;
            group.add(swordHandle);

            const swordBladeGeometry = new THREE.BoxGeometry(0.15, 1.4, 0.05);
            const bladeMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 1,
                roughness: 0.1,
                emissive: isEnemy ? 0xff0000 : 0x00ffff,
                emissiveIntensity: 0.3
            });
            const swordBlade = new THREE.Mesh(swordBladeGeometry, bladeMaterial);
            swordBlade.position.set(0.6, 2.1, 0);
            swordBlade.castShadow = true;
            group.add(swordBlade);

            // Shield (on back)
            const shieldGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 8);
            const shieldMaterial = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.6,
                roughness: 0.4
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.set(-0.3, 1.3, -0.25);
            shield.rotation.x = Math.PI / 2;
            shield.castShadow = true;
            group.add(shield);

            // Store references for animation
            group.userData.animParts = {
                torso,
                leftArm,
                rightArm,
                leftLeg,
                rightLeg,
                swordBlade,
                swordHandle,
                leftShoulder,
                rightShoulder,
                helmet
            };
            }
        }

        // ============================================
        // DEATH KNIGHT MODEL (Dark Plate with Icy Accents)
        // ============================================
        async function createDeathKnightModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.death_knight, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Death Knight model loaded');
            } catch (e) {
                console.error('Failed to load Death Knight model, falling back to procedural:', e);
                const plateColor = 0x1a1a1a; // Almost black
                const icyColor = 0x00ffff; // Cyan/Icy Blue
                
                // Materials
                const plateMaterial = new THREE.MeshStandardMaterial({
                    color: plateColor,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                const icyMaterial = new THREE.MeshStandardMaterial({
                    color: icyColor,
                    emissive: icyColor,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });

            // Legs (dark armor)
            const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
            const leftLeg = new THREE.Mesh(legGeo, plateMaterial);
            leftLeg.position.set(-0.2, 0.45, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, plateMaterial);
            rightLeg.position.set(0.2, 0.45, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);

            // Torso (heavy plate)
            const torsoGeo = new THREE.BoxGeometry(0.7, 0.9, 0.45);
            const torso = new THREE.Mesh(torsoGeo, plateMaterial);
            torso.position.y = 1.35;
            torso.castShadow = true;
            group.add(torso);

            // Glowing runes on chest
            const runeGeo = new THREE.BoxGeometry(0.25, 0.4, 0.05);
            const rune = new THREE.Mesh(runeGeo, icyMaterial);
            rune.position.set(0, 1.4, 0.23);
            group.add(rune);

            // Shoulders (skull-shaped pauldrons)
            const shoulderGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const leftShoulder = new THREE.Mesh(shoulderGeo, plateMaterial);
            leftShoulder.position.set(-0.55, 1.8, 0);
            leftShoulder.castShadow = true;
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, plateMaterial);
            rightShoulder.position.set(0.55, 1.8, 0);
            rightShoulder.castShadow = true;
            group.add(rightShoulder);

            // Glowing eyes in shoulders
            const eyeGeo = new THREE.SphereGeometry(0.05, 4, 4);
            const leftEye1 = new THREE.Mesh(eyeGeo, icyMaterial);
            leftEye1.position.set(-0.55, 1.85, 0.2);
            group.add(leftEye1);
            
            const rightEye1 = new THREE.Mesh(eyeGeo, icyMaterial);
            rightEye1.position.set(0.55, 1.85, 0.2);
            group.add(rightEye1);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.14, 0.16, 0.7, 8);
            const leftArm = new THREE.Mesh(armGeo, plateMaterial);
            leftArm.position.set(-0.45, 1.2, 0);
            leftArm.castShadow = true;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, plateMaterial);
            rightArm.position.set(0.45, 1.2, 0);
            rightArm.castShadow = true;
            group.add(rightArm);

            // Head (skull helmet)
            const helmetGeo = new THREE.BoxGeometry(0.4, 0.5, 0.4);
            const helmet = new THREE.Mesh(helmetGeo, plateMaterial);
            helmet.position.y = 2.05;
            helmet.castShadow = true;
            group.add(helmet);

            // Glowing eyes
            const eyeGeoSmall = new THREE.SphereGeometry(0.04, 4, 4);
            const leftEye = new THREE.Mesh(eyeGeoSmall, icyMaterial);
            leftEye.position.set(-0.1, 2.1, 0.2);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeoSmall, icyMaterial);
            rightEye.position.set(0.1, 2.1, 0.2);
            group.add(rightEye);

            // Runeblade
            const bladeGeo = new THREE.BoxGeometry(0.12, 1.8, 0.03);
            const blade = new THREE.Mesh(bladeGeo, plateMaterial);
            blade.position.set(0.6, 2.1, 0);
            blade.castShadow = true;
            group.add(blade);

            // Glowing rune on blade
            const bladeRuneGeo = new THREE.BoxGeometry(0.04, 1.2, 0.04);
            const bladeRune = new THREE.Mesh(bladeRuneGeo, icyMaterial);
            bladeRune.position.set(0.6, 2.1, 0.01);
            group.add(bladeRune);

            // Store for animations
            group.userData.animParts = {
                leftLeg, rightLeg, torso, leftArm, rightArm, helmet, swordBlade: blade, leftShoulder, rightShoulder
            };
            }
        }

        // ============================================
        // HUNTER MODEL (Beast Master with Pet)
        // ============================================
        async function createHunterModel(group, classData, isEnemy) {
            try {
                // Spawn Hunter Pet
                const pet = await createHunterPet(isEnemy);
                group.userData.pet = pet;

                const model = await loadCharacterWithAnimations(MODEL_URLS.hunter, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                
                console.log('‚úÖ Troll Hunter model loaded');
            } catch (e) {
                console.error('Failed to load Troll Hunter model, falling back to procedural:', e);
                const mainColor = classData.color;
            const leatherColor = 0x8b6f47;
            const accentColor = isEnemy ? 0x8b0000 : 0x4a7c59;

            // Legs (leather armor)
            const legGeometry = new THREE.CylinderGeometry(0.16, 0.19, 0.9, 8);
            const leatherMaterial = new THREE.MeshStandardMaterial({
                color: leatherColor,
                metalness: 0.2,
                roughness: 0.7
            });

            const leftLeg = new THREE.Mesh(legGeometry, leatherMaterial);
            leftLeg.position.set(-0.18, 0.45, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, leatherMaterial);
            rightLeg.position.set(0.18, 0.45, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);

            // Torso (chainmail vest)
            const torsoGeometry = new THREE.BoxGeometry(0.6, 0.85, 0.35);
            const chainMaterial = new THREE.MeshStandardMaterial({
                color: mainColor,
                metalness: 0.5,
                roughness: 0.5
            });
            const torso = new THREE.Mesh(torsoGeometry, chainMaterial);
            torso.position.y = 1.32;
            torso.castShadow = true;
            group.add(torso);

            // Belt with pouches
            const beltGeometry = new THREE.BoxGeometry(0.62, 0.12, 0.36);
            const beltMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                metalness: 0.1,
                roughness: 0.9
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.92;
            group.add(belt);

            // Ammo pouches on belt
            const pouchGeometry = new THREE.BoxGeometry(0.12, 0.15, 0.1);
            const leftPouch = new THREE.Mesh(pouchGeometry, beltMaterial);
            leftPouch.position.set(-0.25, 0.85, 0.15);
            group.add(leftPouch);

            const rightPouch = new THREE.Mesh(pouchGeometry, beltMaterial);
            rightPouch.position.set(0.25, 0.85, 0.15);
            group.add(rightPouch);

            // Shoulders (spiked beast pauldrons)
            const shoulderGeometry = new THREE.BoxGeometry(0.3, 0.28, 0.28);
            const shoulderMaterial = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.4,
                roughness: 0.6
            });

            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(-0.45, 1.7, 0);
            leftShoulder.castShadow = true;
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(0.45, 1.7, 0);
            rightShoulder.castShadow = true;
            group.add(rightShoulder);

            // Animal teeth/spikes on shoulders
            const toothGeometry = new THREE.ConeGeometry(0.05, 0.2, 6);
            const toothMaterial = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                metalness: 0.3,
                roughness: 0.6
            });

            for (let i = 0; i < 3; i++) {
                const leftTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                leftTooth.position.set(-0.45 + (i - 1) * 0.08, 1.85, 0);
                leftTooth.rotation.z = 0.2;
                group.add(leftTooth);

                const rightTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                rightTooth.position.set(0.45 + (i - 1) * 0.08, 1.85, 0);
                rightTooth.rotation.z = -0.2;
                group.add(rightTooth);
            }

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.13, 0.14, 0.7, 8);
            const leftArm = new THREE.Mesh(armGeometry, leatherMaterial);
            leftArm.position.set(-0.4, 1.15, 0);
            leftArm.castShadow = true;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, leatherMaterial);
            rightArm.position.set(0.4, 1.15, 0);
            rightArm.castShadow = true;
            group.add(rightArm);

            // Head (hood with goggles)
            const headGeometry = new THREE.SphereGeometry(0.27, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffe0bd,
                metalness: 0.1,
                roughness: 0.9
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.92;
            head.castShadow = true;
            group.add(head);

            // Hood/cowl
            const hoodGeometry = new THREE.ConeGeometry(0.32, 0.4, 8);
            const hoodMaterial = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.1,
                roughness: 0.8
            });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.y = 2.25;
            hood.castShadow = true;
            group.add(hood);

            // Goggles
            const goggleGeometry = new THREE.TorusGeometry(0.1, 0.04, 8, 16);
            const goggleMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            });
            const leftGoggle = new THREE.Mesh(goggleGeometry, goggleMaterial);
            leftGoggle.position.set(-0.12, 1.95, 0.2);
            leftGoggle.rotation.y = Math.PI / 2;
            group.add(leftGoggle);

            const rightGoggle = new THREE.Mesh(goggleGeometry, goggleMaterial);
            rightGoggle.position.set(0.12, 1.95, 0.2);
            rightGoggle.rotation.y = Math.PI / 2;
            group.add(rightGoggle);

            // Bow (on back, vertical)
            const bowArcGeometry = new THREE.TorusGeometry(0.6, 0.04, 8, 16, Math.PI);
            const bowMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a2511,
                metalness: 0.3,
                roughness: 0.7
            });
            const bowArc = new THREE.Mesh(bowArcGeometry, bowMaterial);
            bowArc.position.set(0, 1.6, -0.25);
            bowArc.rotation.x = Math.PI / 2;
            bowArc.castShadow = true;
            group.add(bowArc);

            // Bow string
            const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1.2, 4);
            const stringMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 0.5,
                roughness: 0.3
            });
            const bowString = new THREE.Mesh(stringGeometry, stringMaterial);
            bowString.position.set(0, 1.6, -0.25);
            group.add(bowString);

            // Arrow in quiver
            const quiverGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.6, 8);
            const quiverMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                metalness: 0.1,
                roughness: 0.9
            });
            const quiver = new THREE.Mesh(quiverGeometry, quiverMaterial);
            quiver.position.set(-0.3, 1.2, -0.2);
            quiver.rotation.z = -0.3;
            quiver.castShadow = true;
            group.add(quiver);

            // Arrows sticking out of quiver
            const arrowShaftGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.5, 6);
            const arrowMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b6f47,
                metalness: 0.2,
                roughness: 0.7
            });

            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 0.5;
                const arrow = new THREE.Mesh(arrowShaftGeometry, arrowMaterial);
                arrow.position.set(-0.3 + Math.cos(angle) * 0.08, 1.6, -0.2 + Math.sin(angle) * 0.08);
                arrow.rotation.z = -0.3;
                group.add(arrow);

                // Arrow fletching
                const fletchGeometry = new THREE.BoxGeometry(0.08, 0.03, 0.01);
                const fletchMaterial = new THREE.MeshStandardMaterial({
                    color: isEnemy ? 0xff4444 : 0x44ff44,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const fletch = new THREE.Mesh(fletchGeometry, fletchMaterial);
                fletch.position.set(-0.3 + Math.cos(angle) * 0.08, 1.8, -0.2 + Math.sin(angle) * 0.08);
                group.add(fletch);
            }

            // Pet companion (wolf/cat)
            const petGroup = new THREE.Group();
            
            // Pet body
            const petBodyGeometry = new THREE.BoxGeometry(0.4, 0.25, 0.6);
            const petMaterial = new THREE.MeshStandardMaterial({
                color: isEnemy ? 0x660000 : 0x4a7c59,
                metalness: 0.2,
                roughness: 0.8
            });
            const petBody = new THREE.Mesh(petBodyGeometry, petMaterial);
            petBody.position.y = 0.3;
            petBody.castShadow = true;
            petGroup.add(petBody);

            // Pet head
            const petHeadGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.3);
            const petHead = new THREE.Mesh(petHeadGeometry, petMaterial);
            petHead.position.set(0, 0.3, 0.4);
            petHead.castShadow = true;
            petGroup.add(petHead);

            // Pet ears
            const petEarGeometry = new THREE.ConeGeometry(0.08, 0.2, 6);
            const leftEar = new THREE.Mesh(petEarGeometry, petMaterial);
            leftEar.position.set(-0.1, 0.5, 0.4);
            petGroup.add(leftEar);

            const rightEar = new THREE.Mesh(petEarGeometry, petMaterial);
            rightEar.position.set(0.1, 0.5, 0.4);
            petGroup.add(rightEar);

            // Pet eyes (glowing)
            const petEyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const petEyeMaterial = new THREE.MeshStandardMaterial({
                color: isEnemy ? 0xff0000 : 0xffff00,
                emissive: isEnemy ? 0xff0000 : 0xffff00,
                emissiveIntensity: 0.8
            });
            const leftEye = new THREE.Mesh(petEyeGeometry, petEyeMaterial);
            leftEye.position.set(-0.08, 0.35, 0.52);
            petGroup.add(leftEye);

            const rightEye = new THREE.Mesh(petEyeGeometry, petEyeMaterial);
            rightEye.position.set(0.08, 0.35, 0.52);
            petGroup.add(rightEye);

            // Pet legs
            const petLegGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.3, 6);
            const legPositions = [
                [-0.15, 0.15, 0.2],
                [0.15, 0.15, 0.2],
                [-0.15, 0.15, -0.1],
                [0.15, 0.15, -0.1]
            ];

            const petLegs = [];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(petLegGeometry, petMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                petGroup.add(leg);
                petLegs.push(leg);
            });

            // Pet tail
            const petTailGeometry = new THREE.CylinderGeometry(0.04, 0.06, 0.4, 6);
            const tail = new THREE.Mesh(petTailGeometry, petMaterial);
            tail.position.set(0, 0.35, -0.4);
            tail.rotation.x = Math.PI / 4;
            petGroup.add(tail);

            // DON'T add pet to hunter group - it needs to move independently
            // Instead, store reference and add to scene separately
            
            // Initialize pet userData for independent AI (fallback procedural pet)
            // Note: Stats here are placeholders ‚Äî overwritten by match scaling in startNewMatch
            petGroup.userData = {
                isPet: true,
                petType: 'hunter_pet',
                petName: 'Raptor',
                ownerRef: null,
                health: 20000,
                maxHealth: 20000,
                baseDamage: 2800,
                damage: 2800,
                moveSpeed: 5.0,
                velocity: new THREE.Vector3(0, 0, 0),
                desiredVelocity: new THREE.Vector3(0, 0, 0),
                target: null,
                lastAttackTime: 0,
                attackCooldown: 2.0,
                resilience: 0.15,
                armor: 0.08,
                healingReduction: 0,
                absorb: 0,
                ccUntil: 0,
                ccType: null,
                drState: {},
                critChance: 0.15,
                critMult: 1.8,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                killCount: 0,
                abilities: {
                    claw: { cooldown: 0, maxCooldown: 3.0, damage: 3500, name: 'Claw' },
                    bite: { cooldown: 0, maxCooldown: 10.0, damage: 6000, name: 'Kill Command' },
                    dash: { cooldown: 0, maxCooldown: 25.0, duration: 4.0, name: 'Dash' },
                    roarOfSacrifice: { cooldown: 0, maxCooldown: 60.0, duration: 6.0, damageReduction: 0.2, name: 'Roar of Sacrifice' },
                    mend: { cooldown: 0, maxCooldown: 10.0, healPercent: 0.25, name: 'Mend Pet' }
                },
                dashUntil: 0,
                lastPosition: new THREE.Vector3(0, 0, 0),
                stuckTimer: 0,
                isEnemy,
                nameplateId: 'pet-' + Math.random().toString(36).substr(2, 9),
                auras: [],
                buffUntil: 0,
                buffType: null,
                walkCyclePhase: 0,
                animState: 'idle',
                leftFootPhase: 0,
                rightFootPhase: Math.PI
            };
            
            // NOTE: Nameplate is created during startNewMatch() ‚Äî NOT here
            // to avoid duplicate/broken nameplates

            // Store pet reference in hunter's userData (not as child object)
            group.userData.pet = petGroup;
            
            // Store animation parts for pet itself
            petGroup.userData.animParts = {
                petBody,
                petHead,
                petLegs,
                tail
            };

            // Store references for hunter animation
            group.userData.animParts = {
                torso,
                leftArm,
                rightArm,
                leftLeg,
                rightLeg,
                bowArc,
                bowString,
                head,
                leftShoulder,
                rightShoulder
            };
        }
    }

        // ============================================
        // PRIEST MODEL (Troll Priest)
        // ============================================
        async function createPriestModel(group, classData, isEnemy) {
            try {
                // Use a larger scale and let loadCharacterWithAnimations handle the height
                const model = await loadCharacterWithAnimations(MODEL_URLS.priest, [], {
                    scale: 2.2
                });
                
                group.add(model);
                group.userData.model = model;
                
                // Store the mixer and actions on the group for easy access
                group.userData.mixer = model.userData.mixer;
                group.userData.actions = model.userData.actions;
                group.userData.currentActionName = model.userData.currentActionName || 'idle';
                
                console.log('‚úÖ Troll Priest model loaded with animations');
            } catch (e) {
                console.error('Failed to load Troll Priest model, falling back to procedural:', e);
                // Fallback to procedural if loading fails
                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.4, 1.8, 12);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: classData.color,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                body.castShadow = true;
                group.add(body);
            }
        }

        // ============================================
        // DRUID MODEL (Tauren Druid GLTF)
        // ============================================
        async function createDruidModel(group, classData, isEnemy) {
            try {
                // Tauren are large, so we use a good scale
                const model = await loadCharacterWithAnimations(MODEL_URLS.druid, [], {
                    scale: 2.8,
                    yOffset: 0
                });
                
                group.add(model);
                group.userData.model = model;
                
                // Store the mixer and actions on the group for easy access
                if (model.userData.mixer) {
                    group.userData.mixer = model.userData.mixer;
                    group.userData.actions = model.userData.actions;
                    group.userData.currentActionName = model.userData.currentActionName || 'idle';
                }
                
                console.log('‚úÖ Tauren Druid model loaded');
            } catch (e) {
                console.error('Failed to load Tauren Druid model, falling back to procedural:', e);
                // Fallback to procedural if loading fails
                const mainColor = classData.color; // Orange
                const leatherColor = 0x8b6f47;
                const natureGreen = 0x2d5016;
                const accentColor = isEnemy ? 0x8b0000 : 0x00ff00;

                // Simple fallback body
                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.4, 1.8, 12);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: mainColor,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                body.castShadow = true;
                group.add(body);
            }
        }

        // ============================================
        // MAGE MODEL (Undead Mage GLTF)
        // ============================================
        async function createMageModel(group, classData, isEnemy) {
            try {
                const model = await loadCharacterWithAnimations(MODEL_URLS.mage, [], {
                    scale: 2.2,
                    yOffset: 0
                });
                
                group.add(model);
                group.userData.model = model;
                
                // Store the mixer and actions on the group for easy access
                if (model.userData.mixer) {
                    group.userData.mixer = model.userData.mixer;
                    group.userData.actions = model.userData.actions;
                    group.userData.currentActionName = model.userData.currentActionName || 'idle';
                }
                
                console.log('‚úÖ Undead Mage model loaded');
            } catch (e) {
                console.error('Failed to load Undead Mage model, falling back to procedural:', e);
                // Fallback to procedural if loading fails
                const mainColor = classData.color; // Cyan
                const robeColor = 0x4169e1;
                const accentColor = isEnemy ? 0x8b0000 : 0x00ffff;

                // Simple fallback body
                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.4, 1.8, 12);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: robeColor,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                body.castShadow = true;
                group.add(body);
            }
        }

        function createNameplate(id, className, isEnemy, classType) {
            const nameplate = document.createElement('div');
            nameplate.id = `nameplate-${id}`;
            nameplate.className = 'nameplate';
            const resourceClass = classType === 'rogue' ? 'energy' : (classType === 'warrior' ? 'rage' : 'mana');
            nameplate.innerHTML = `
                <div class="nameplate-name">
                    <img src="${CLASS_ICONS[classType]}" class="class-icon-mini" alt="">
                    ${className}
                </div>
                ${classType === 'rogue' ? `
                <div class="nameplate-combo-points">
                    <div class="combo-pip"></div>
                    <div class="combo-pip"></div>
                    <div class="combo-pip"></div>
                    <div class="combo-pip"></div>
                    <div class="combo-pip"></div>
                </div>
                ` : ''}
                <div class="nameplate-cast-bar">
                    <div class="cast-bar-fill"></div>
                    <div class="cast-bar-text">Casting...</div>
                </div>
                <div class="nameplate-health">
                    <div class="nameplate-health-fill ${classType}" style="width: 100%"></div>
                </div>
                <div class="nameplate-mana" style="display: block;">
                    <div class="nameplate-mana-fill ${resourceClass}" style="width: 100%"></div>
                </div>
                <div class="nameplate-cc" style="display: none;"></div>
                <div class="nameplate-interrupts"></div>
                <div class="nameplate-buffs"></div>
                <div class="nameplate-dr">
                    <div class="dr-indicator stun" title="Stun DR">‚ö°</div>
                    <div class="dr-indicator incap" title="Incap DR">üêë</div>
                    <div class="dr-indicator fear" title="Fear DR">üò±</div>
                    <div class="dr-indicator root" title="Root DR">üåø</div>
                </div>
            `;
            document.getElementById('nameplates-container').appendChild(nameplate);
        }

        // Create pet nameplate (professional health bar with ability cooldown pips, ghost HP, resource bar, owner tag)
        function createPetNameplate(petId, isEnemy, petData) {
            const nameplate = document.createElement('div');
            nameplate.id = `nameplate-${petId}`;
            nameplate.className = 'nameplate pet-nameplate'; 
            const teamClass = isEnemy ? 'enemy' : 'ally';
            const nameColor = isEnemy ? '#ff8888' : '#88ff88';
            const petName = petData?.petName || 'Pet';
            const petType = petData?.petType || 'hunter_pet';
            const petIcon = petType === 'hunter_pet' ? 'üê∫' : 'üëπ';
            const ownerName = petData?.ownerRef?.userData?.classData?.name || '';
            const isSoulLinked = petType === 'warlock_pet';
            const resourceClass = petType === 'hunter_pet' ? 'focus' : 'shadow-energy';
            
            // Build ability pip HTML from pet abilities
            const abilities = petData?.abilities || {};
            const abilityKeys = Object.keys(abilities).filter(k => !abilities[k].passive);
            const abilityPipIcons = {
                claw: 'üêæ', bite: '‚öîÔ∏è', dash: 'üí®', roarOfSacrifice: 'üõ°Ô∏è', mend: 'üíö',
                shadowBite: 'üëÑ', spellLock: 'üîí', devourMagic: '‚ú®'
            };
            
            const pipsHTML = abilityKeys.map(key => {
                const ab = abilities[key];
                const icon = abilityPipIcons[key] || '‚¨•';
                return `<div class="pet-ability-pip ready" data-ability="${key}" title="${ab.name}${ab.focusCost ? ' (' + ab.focusCost + ' focus)' : ''}">
                    <span class="pip-icon">${icon}</span>
                    <div class="pip-cd-sweep"></div>
                </div>`;
            }).join('');
            
            nameplate.innerHTML = `
                <div class="pet-nameplate-header" style="color: ${nameColor};">
                    <span class="pet-type-icon">${petIcon}</span>
                    <span class="pet-name-label">${petName}</span>
                    ${ownerName ? `<span class="pet-owner-tag">(${ownerName})</span>` : ''}
                    ${isSoulLinked ? '<span class="soul-link-indicator active" title="Soul Link Active">üîó</span>' : ''}
                </div>
                <div class="pet-health-wrapper ${teamClass}-pet${isSoulLinked ? ' soul-linked' : ''}">
                    <div class="pet-health-ghost" style="width: 100%;"></div>
                    <div class="pet-health-fill ${teamClass}" style="width: 100%;"></div>
                    <span class="pet-hp-text">100%</span>
                </div>
                <div class="pet-resource-bar">
                    <div class="pet-resource-fill ${resourceClass}" style="width: 100%;"></div>
                </div>
                <div class="pet-ability-pips">${pipsHTML}</div>
                <div class="pet-cc-display"></div>
                <div class="nameplate-buffs"></div>
            `;
            document.getElementById('nameplates-container').appendChild(nameplate);
        }

        // Cache nameplate elements for performance
        const nameplateCaches = new Map();
        const tempVector = new THREE.Vector3(); // Reusable vector to reduce GC

        function updateNameplates() {
            [...gameState.team, ...gameState.enemies].forEach(char => {
                if (!char.visible || !char.userData || char.userData.health <= 0) return;

                const userData = char.userData;
                const nameplateId = userData.nameplateId;
                
                // Get or create cache for this nameplate
                if (!nameplateCaches.has(nameplateId)) {
                    const nameplate = document.getElementById(`nameplate-${nameplateId}`);
                    if (!nameplate) return;
                    
                    const isPetNameplate = nameplate.classList.contains('pet-nameplate');
                    nameplateCaches.set(nameplateId, {
                        element: nameplate,
                        isPetNameplate,
                        // Standard nameplate elements
                        healthFill: isPetNameplate ? nameplate.querySelector('.pet-health-fill') : nameplate.querySelector('.nameplate-health-fill'),
                        manaFill: nameplate.querySelector('.nameplate-mana-fill'),
                        castBar: nameplate.querySelector('.nameplate-cast-bar'),
                        castBarFill: nameplate.querySelector('.cast-bar-fill'),
                        castBarText: nameplate.querySelector('.cast-bar-text'),
                        ccDiv: isPetNameplate ? nameplate.querySelector('.pet-cc-display') : nameplate.querySelector('.nameplate-cc'),
                        buffsDiv: nameplate.querySelector('.nameplate-buffs'),
                        drIndicators: {
                            stun: nameplate.querySelector('.dr-indicator.stun'),
                            incap: nameplate.querySelector('.dr-indicator.incap'),
                            fear: nameplate.querySelector('.dr-indicator.fear'),
                            root: nameplate.querySelector('.dr-indicator.root')
                        },
                        comboPips: Array.from(nameplate.querySelectorAll('.combo-pip')),
                        // Pet-specific cached elements
                        petHpText: nameplate.querySelector('.pet-hp-text'),
                        petNameLabel: nameplate.querySelector('.pet-name-label'),
                        petHealthGhost: nameplate.querySelector('.pet-health-ghost'),
                        petHealthWrapper: nameplate.querySelector('.pet-health-wrapper'),
                        petResourceFill: nameplate.querySelector('.pet-resource-fill'),
                        petAbilityPips: Array.from(nameplate.querySelectorAll('.pet-ability-pip')),
                        petCcDisplay: nameplate.querySelector('.pet-cc-display'),
                        // Track previous HP for ghost bar ‚Äî chunk-based tracking
                        _prevHpPct: 100,
                        _ghostHpPct: 100,
                        _lastDamageChunkTime: 0
                    });
                }

                const cache = nameplateCaches.get(nameplateId);
                const nameplate = cache.element;

                // Project 3D position to 2D screen (reuse vector)
                tempVector.copy(char.position);
                tempVector.y += userData.isPet ? 1.2 : 2.5; 
                tempVector.project(camera);

                // Check if behind camera (z > 1) or way off-screen
                // We use a strict frustum check to prevent phantom nameplates
                const onScreen = tempVector.z <= 1 && Math.abs(tempVector.x) <= 1.05 && Math.abs(tempVector.y) <= 1.05;
                if (!onScreen) {
                    if (nameplate.style.display !== 'none') {
                        nameplate.style.display = 'none';
                    }
                    return;
                }

                if (nameplate.style.display !== 'flex') {
                    nameplate.style.display = 'flex';
                }
                
                const x = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(tempVector.y) * 0.5 + 0.5) * window.innerHeight;
                nameplate.style.left = `${x}px`;
                nameplate.style.top = `${y}px`;

                // Update health bar
                const healthPercent = (userData.health / userData.maxHealth) * 100;
                if (cache.healthFill) cache.healthFill.style.width = `${healthPercent}%`;

                // =============================================
                // PET NAMEPLATE UPDATE (comprehensive overhaul v2)
                // =============================================
                if (userData.isPet && cache.isPetNameplate) {
                    const hpPct = Math.round(healthPercent);
                    const now = performance.now();
                    
                    // HP Text: Show percentage + raw HP + armor/resist indicator
                    if (cache.petHpText) {
                        const rawHp = Math.round(userData.health);
                        const hpStr = rawHp >= 1000 ? `${(rawHp / 1000).toFixed(1)}k` : `${rawHp}`;
                        // Show frenzy stacks for hunter pet
                        const frenzyStr = (userData.frenzyStacks > 0) ? ` üî•${userData.frenzyStacks}` : '';
                        cache.petHpText.textContent = `${hpPct}% ¬∑ ${hpStr}${frenzyStr}`;
                    }
                    
                    // Resource bar update (focus / shadow energy)
                    if (cache.petResourceFill && userData.maxFocus > 0) {
                        const focusPct = Math.round((userData.focus / userData.maxFocus) * 100);
                        cache.petResourceFill.style.width = `${focusPct}%`;
                        // Dim resource bar when low
                        cache.petResourceFill.style.opacity = focusPct < 20 ? '0.5' : '1';
                    }
                    
                    // Ghost HP bar ‚Äî improved chunk-based tracking with time delay
                    if (cache.petHealthGhost) {
                        if (hpPct < cache._prevHpPct) {
                            // New damage chunk received
                            cache._ghostHpPct = Math.max(cache._ghostHpPct, cache._prevHpPct);
                            cache._lastDamageChunkTime = now;
                        }
                        // Hold ghost bar for 0.4s after damage, then drain
                        const timeSinceChunk = now - cache._lastDamageChunkTime;
                        if (cache._ghostHpPct > hpPct && timeSinceChunk > 400) {
                            // Drain speed proportional to gap size (bigger chunks drain faster)
                            const gap = cache._ghostHpPct - hpPct;
                            const drainSpeed = Math.max(0.3, gap * 0.04);
                            cache._ghostHpPct = Math.max(hpPct, cache._ghostHpPct - drainSpeed);
                        }
                        cache.petHealthGhost.style.width = `${cache._ghostHpPct}%`;
                        cache._prevHpPct = hpPct;
                    }
                    
                    // Health bar color tiers via CSS class toggling
                    if (cache.healthFill) {
                        cache.healthFill.classList.remove('pet-hp-mid', 'pet-hp-low');
                        if (healthPercent < 25) {
                            cache.healthFill.classList.add('pet-hp-low');
                        } else if (healthPercent < 50) {
                            cache.healthFill.classList.add('pet-hp-mid');
                        }
                    }
                    
                    // Ability cooldown pips update ‚Äî also check focus cost affordability
                    if (cache.petAbilityPips.length > 0 && userData.abilities) {
                        const abilityKeys = Object.keys(userData.abilities).filter(k => !userData.abilities[k].passive);
                        cache.petAbilityPips.forEach((pip, idx) => {
                            if (idx >= abilityKeys.length) return;
                            const ab = userData.abilities[abilityKeys[idx]];
                            if (!ab) return;
                            
                            const isReady = ab.cooldown <= 0;
                            const canAfford = !ab.focusCost || (userData.focus >= ab.focusCost);
                            const isUsable = isReady && canAfford;
                            pip.classList.toggle('ready', isUsable);
                            pip.classList.toggle('on-cd', !isUsable);
                            
                            // Sweep overlay for cooldown visualization
                            const sweep = pip.querySelector('.pip-cd-sweep');
                            if (sweep) {
                                if (isReady) {
                                    sweep.style.clipPath = 'polygon(50% 50%, 50% 0%, 50% 0%)';
                                    // Show low-focus tint if can't afford
                                    sweep.style.background = canAfford ? 'rgba(0, 0, 0, 0.65)' : 'rgba(30, 30, 100, 0.65)';
                                } else {
                                    sweep.style.background = 'rgba(0, 0, 0, 0.65)';
                                    const cdPct = Math.min(1, ab.cooldown / ab.maxCooldown);
                                    const angle = cdPct * 360;
                                    if (angle <= 180) {
                                        sweep.style.clipPath = `polygon(50% 50%, 50% 0%, ${50 + 50 * Math.sin(angle * Math.PI / 180)}% ${50 - 50 * Math.cos(angle * Math.PI / 180)}%, 50% 50%)`;
                                    } else {
                                        sweep.style.clipPath = `polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 0%, ${50 + 50 * Math.sin(angle * Math.PI / 180)}% ${50 - 50 * Math.cos(angle * Math.PI / 180)}%)`;
                                    }
                                }
                            }
                        });
                    }
                    
                    // Pet CC display
                    if (cache.petCcDisplay) {
                        if (userData.ccUntil > 0) {
                            cache.petCcDisplay.classList.add('active');
                            const ccText = userData.ccType === 'stun' ? '‚ö° STUNNED' :
                                          userData.ccType === 'fear' ? 'üò± FEAR' :
                                          userData.ccType === 'root' ? 'üåø ROOTED' :
                                          userData.ccType === 'freeze' ? '‚ùÑÔ∏è FROZEN' :
                                          userData.ccType === 'sheep' ? 'üêë POLY' : '‚ö†Ô∏è CC';
                            cache.petCcDisplay.textContent = `${ccText} ${userData.ccUntil.toFixed(1)}s`;
                        } else {
                            cache.petCcDisplay.classList.remove('active');
                        }
                    }
                }

                // Update mana/resource bar
                if (cache.manaFill && userData.maxMana > 0) {
                    const manaPercent = (userData.mana / userData.maxMana) * 100;
                    cache.manaFill.style.width = `${manaPercent}%`;
                    
                    // Pulse mana bar when low (OOM Warning)
                    if (manaPercent < 15 && userData.classData?.role === 'healer') {
                        cache.manaFill.parentElement.style.boxShadow = '0 0 5px #ff4444';
                        if (Math.sin(Date.now() * 0.01) > 0) {
                            cache.manaFill.style.opacity = '0.6';
                        } else {
                            cache.manaFill.style.opacity = '1.0';
                        }
                    } else {
                        cache.manaFill.parentElement.style.boxShadow = 'none';
                        cache.manaFill.style.opacity = '1.0';
                    }
                }

                // Update Rogue Combo Points
                if (userData.classType === 'rogue' && cache.comboPips) {
                    const cp = userData.comboPoints || 0;
                    cache.comboPips.forEach((pip, idx) => {
                        if (idx < cp) {
                            pip.classList.add('active');
                        } else {
                            pip.classList.remove('active');
                        }
                    });
                }

                // Update Buffs/Debuffs display
                const auras = userData.auras || [];
                const buffsDiv = cache.buffsDiv;
                
                // Only update if aura count changed or timers need update
                // For simplicity, we rebuild when count > 0 or it was > 0
                if (auras.length > 0 || (buffsDiv && buffsDiv.children.length > 0)) {
                    if (buffsDiv) {
                        buffsDiv.innerHTML = auras.map(aura => `
                            <div class="buff-icon ${aura.type}" title="${aura.name}" style="background-image: url('${aura.icon}')">
                                <div class="buff-timer">${Math.ceil(aura.duration)}</div>
                            </div>
                        `).join('');
                    }
                }

                // Update Cast Bar
                const isInterrupted = userData.interruptedUntil && gameState.matchTime < userData.interruptedUntil;
                
                if (cache.castBar) {
                    if (userData.castingAbility && userData.castingAbility.castTime > 0) {
                        cache.castBar.style.display = 'block';
                        cache.castBar.classList.remove('interrupted');
                        const castDuration = userData.castingAbility.castTime;
                        const castPercent = (userData.castProgress / castDuration) * 100;
                        if (cache.castBarFill) cache.castBarFill.style.width = `${castPercent}%`;
                        if (cache.castBarText) cache.castBarText.textContent = userData.castingAbility.name || 'Casting...';
                    } else if (isInterrupted) {
                        cache.castBar.style.display = 'block';
                        cache.castBar.classList.add('interrupted');
                        if (cache.castBarFill) cache.castBarFill.style.width = '100%';
                        if (cache.castBarText) cache.castBarText.textContent = 'INTERRUPTED';
                    } else {
                        cache.castBar.style.display = 'none';
                        cache.castBar.classList.remove('interrupted');
                    }
                }

                // Update CC/Buff status (skip pets ‚Äî handled in pet nameplate section above)
                if (cache.ccDiv && !cache.isPetNameplate) {
                    if (userData.ccUntil > 0) {
                        if (cache.ccDiv.style.display !== 'block') {
                            cache.ccDiv.style.display = 'block';
                        }
                        const ccText = userData.ccType === 'sheep' ? 'üêë POLYMORPH' : 
                                      userData.ccType === 'fear' ? 'üò± FEAR' : 
                                      userData.ccType === 'stun' ? '‚ö° STUNNED' :
                                      userData.ccType === 'freeze' ? '‚ùÑÔ∏è FROZEN' :
                                      userData.ccType === 'banish' ? 'üå™Ô∏è CYCLONE' :
                                      userData.ccType === 'root' ? 'üåø ROOTED' :
                                      userData.ccType === 'invulnerable' ? 'üõ°Ô∏è IMMUNE' : 'CC';
                        cache.ccDiv.textContent = `${ccText} ${userData.ccUntil.toFixed(1)}s`;
                    } else if (userData.buffUntil > 0 && userData.buffType === 'damageBuff') {
                        // Show offensive buff
                        if (cache.ccDiv.style.display !== 'block') {
                            cache.ccDiv.style.display = 'block';
                        }
                        cache.ccDiv.textContent = `üî• BURST ${userData.buffUntil.toFixed(1)}s`;
                        cache.ccDiv.style.background = 'rgba(255, 100, 0, 0.9)';
                    } else {
                        if (cache.ccDiv.style.display !== 'none') {
                            cache.ccDiv.style.display = 'none';
                            cache.ccDiv.style.background = 'rgba(255, 0, 0, 0.9)'; // Reset to red
                        }
                    }
                }

                // Update DR indicators per category
                if (userData.drState) {
                    const cats = { 
                        stun: userData.drState[DR_CATEGORIES.STUN],
                        incap: userData.drState[DR_CATEGORIES.INCAPACITATE],
                        fear: userData.drState[DR_CATEGORIES.FEAR],
                        root: userData.drState[DR_CATEGORIES.ROOT]
                    };
                    
                    Object.entries(cats).forEach(([key, dr]) => {
                        const el = cache.drIndicators[key];
                        if (el && dr) {
                            const stacks = dr.stacks || 0;
                            const expectedClass = `dr-indicator ${key} ${stacks > 0 ? 'active-' + stacks : ''}`;
                            if (el.className !== expectedClass) {
                                el.className = expectedClass;
                            }
                            // Show remaining time as text if active, otherwise restore emoji icon
                            if (dr.timer > 0 && stacks > 0) {
                                el.textContent = Math.ceil(dr.timer);
                            } else {
                                el.textContent = key === 'stun' ? '‚ö°' : key === 'incap' ? 'üêë' : key === 'root' ? 'üåø' : 'üò±';
                            }
                        }
                    });
                }
            });
        }

        // ============================================
        // MATCH SYSTEM
        // ============================================
        async function startNewMatch() {
            // Clear previous characters and nameplates (including pets)
            gameState.team.forEach(char => {
                scene.remove(char);
                if (char.userData.nameplateId) {
                    const nameplate = document.getElementById(`nameplate-${char.userData.nameplateId}`);
                    if (nameplate) nameplate.remove();
                }
            });
            gameState.enemies.forEach(char => {
                scene.remove(char);
                if (char.userData.nameplateId) {
                    const nameplate = document.getElementById(`nameplate-${char.userData.nameplateId}`);
                    if (nameplate) nameplate.remove();
                }
            });
            gameState.team = [];
            gameState.enemies = [];
            
            // Clear caches
            nameplateCaches.clear();

            gameState.matchNumber++;
            gameState.matchTime = 0;
            gameState.inMatch = false; // Stay out of match until loaded
            gameState.matchState = 'waiting'; 
            gameState.gateState = 'closed';
            gameState.gateTimer = 0;
            gameState.dampeningAnnounced = {}; // Reset dampening announcements

            // Hide countdown overlay
            const countdownEl = document.getElementById('countdown-overlay');
            if (countdownEl) countdownEl.style.display = 'none';
            
            // Clear combat log
            document.getElementById('combat-log').innerHTML = '';
            
            // Reset match stats
            gameState.matchStats = {
                damageDealt: 0,
                healingDone: 0,
                ccChains: 0,
                losDamage: 0,
                manaUsed: 0,
                damageAbsorbed: 0,
                buffUptime: 0, 
                responseTimes: []
            };

            // Show arena announcement
            showArenaAnnouncement('Prepare for Battle!', 1500);
            addCombatLog('=== Match Starting ===', 'buff');
            
            // Close gates
            if (window.arenaGates) {
                window.arenaGates.forEach(gate => {
                    gate.barrier.material.opacity = 0.6;
                    gate.glow.material.opacity = 0.2;
                    gate.group.visible = true;
                });
            }

            // 3v3 with dynamic composition based on player roster
            const teamComp = gameState.activeRoster;
            
            // Randomize enemy composition
            // WoW Meta: 1 Healer, 2 DPS
            const allClassKeys = Object.keys(CLASSES);
            const healers = allClassKeys.filter(k => CLASSES[k].role === 'healer');
            const dps = allClassKeys.filter(k => CLASSES[k].role !== 'healer');
            
            const randomHealer = healers[Math.floor(Math.random() * healers.length)];
            const randomDPS1 = dps[Math.floor(Math.random() * dps.length)];
            let randomDPS2 = dps[Math.floor(Math.random() * dps.length)];
            
            // Try to avoid duplicate DPS if possible
            if (randomDPS1 === randomDPS2 && dps.length > 1) {
                randomDPS2 = dps.find(k => k !== randomDPS1);
            }
            
            const enemyComp = [randomDPS1, randomDPS2, randomHealer];

            // PARALLEL SPAWNING: Load all character models at once to avoid sequential bottlenecks
            const [allies, enemies] = await Promise.all([
                Promise.all(teamComp.map(type => createCharacter(type, false))),
                Promise.all(enemyComp.map(type => createCharacter(type, true)))
            ]);

            // Create team (YOUR TEAM) - South Spawn
            for (let i = 0; i < allies.length; i++) {
                const char = allies[i];
                const classType = teamComp[i];
                
                // Position team in a line at the south end
                char.position.set((i - 1) * 3, 0, -15);
                char.rotation.y = 0;
                
                // Calculate gear stats
                const gearStats = calculateTotalGearStats();
                
                // Calculate conquest bonuses
                const tenacityBonus = 1 + (gameState.conquestUpgrades.conquest_tenacity || 0) * 0.1;
                
                // Apply upgrades + gear stats + conquest
                const baseHealth = char.userData.classData.health;
                char.userData.maxHealth = (baseHealth * (1 + gameState.upgrades.health * 0.1) + (gearStats.health * 1000)) * tenacityBonus;
                char.userData.health = char.userData.maxHealth;
                char.userData.resilience = gameState.upgrades.resilience * 0.05 + (gearStats.resilience * 0.01);
                
                // Generic mana setup based on class role
                const isCaster = char.userData.classData.role === 'healer' || char.userData.classData.role === 'ranged';
                const isEnergy = char.userData.classType === 'rogue';
                const isRage = char.userData.classType === 'warrior';
                
                char.userData.maxMana = isCaster ? 50000 : (isEnergy || isRage ? 100 : 0);
                char.userData.mana = isRage ? 0 : char.userData.maxMana; // Warriors start at 0 rage
                
                // Mana regen with talent bonus
                const manaTalentBonus = getTalentBonus('tal_mana');
                char.userData.manaRegen = isCaster ? (500 * (1 + gameState.upgrades.manaRegen * 0.15 + manaTalentBonus) + (gearStats.manaRegen * 50)) : 0;
                char.userData.lastSpellCastTime = -10; // Allow immediate regen at match start
                
                // Apply conquest swiftness bonus
                const swiftnessBonus = 1 + (gameState.conquestUpgrades.conquest_swiftness || 0) * 0.15;
                char.userData.moveSpeed = char.userData.baseMoveSpeed * swiftnessBonus;
                
                // Apply visual gear
                applyVisualGear(char);

                scene.add(char);
                gameState.team.push(char);
                
                // Add hunter/warlock pet to scene separately
                if ((classType === 'hunter' || classType === 'warlock') && char.userData.pet) {
                    const pet = char.userData.pet;
                    pet.userData.ownerRef = char; // Link back to owner
                    
                    // =============================================
                    // PET STAT SCALING v2 (realistic multi-factor system)
                    // =============================================
                    const ownerHP = char.userData.maxHealth;
                    const ownerRes = char.userData.resilience;
                    const isHunterPet = classType === 'hunter';
                    
                    // === HP: Stamina-derived + base ratio + flat floor ===
                    const petHealthRatio = isHunterPet ? 0.50 : 0.45;
                    const flatHpFloor = isHunterPet ? 5000 : 4000;
                    const staminaBonus = (gearStats.stamina || 0) * 120; // Each stamina point = 120 pet HP
                    pet.userData.staminaBonus = staminaBonus;
                    pet.userData.maxHealth = Math.max(flatHpFloor, ownerHP * petHealthRatio + staminaBonus);
                    pet.userData.health = pet.userData.maxHealth;
                    
                    // === Damage: base + upgrades + gear + owner attack power passthrough ===
                    const basePetDmg = isHunterPet ? 2800 : 2200;
                    const upgradeMult = 1 + gameState.upgrades.damage * 0.08;
                    const gearDmgBonus = (gearStats.damage || 0) * 60;
                    pet.userData.baseDamage = (basePetDmg * upgradeMult) + gearDmgBonus;
                    pet.userData.damage = pet.userData.baseDamage;
                    
                    // === Crit: base + gear scaling ===
                    pet.userData.critChance = 0.15 + (gearStats.critChance || 0) * 0.005;
                    pet.userData.critMult = 1.8 + (gearStats.critChance || 0) * 0.01;
                    
                    // Scale ability damage proportionally  
                    const dmgScale = pet.userData.damage / basePetDmg;
                    if (pet.userData.abilities) {
                        Object.values(pet.userData.abilities).forEach(ability => {
                            if (ability.damage) ability.damage = ability.damage * dmgScale;
                        });
                    }
                    
                    // === Resilience: derived from owner ===
                    pet.userData.resilience = Math.min(0.35, 0.10 + ownerRes * 0.6);
                    
                    // === Armor: diminishing returns formula from armorRating ===
                    // Formula: reduction = armorRating / (armorRating + K), K varies by pet type
                    const armorK = isHunterPet ? 10000 : 15000;
                    const baseArmorRating = isHunterPet ? 3200 : 1800;
                    const gearArmorBonus = (gearStats.armor || 0) * 200;
                    pet.userData.armorRating = baseArmorRating + gearArmorBonus;
                    pet.userData.armor = pet.userData.armorRating / (pet.userData.armorRating + armorK);
                    
                    // === Avoidance: scales slightly with gear ===
                    if (isHunterPet) {
                        pet.userData.dodgeChance = Math.min(0.15, 0.08 + (gearStats.agility || 0) * 0.002);
                        pet.userData.parryChance = 0.04;
                        pet.userData.spellResist = 0;
                    } else {
                        pet.userData.dodgeChance = 0.03;
                        pet.userData.parryChance = 0;
                        pet.userData.spellResist = Math.min(0.20, 0.12 + (gearStats.spellResist || 0) * 0.003);
                    }
                    
                    // === Focus regeneration: scales with haste ===
                    const baseFocusRegen = isHunterPet ? 5.0 : 4.0;
                    pet.userData.focusRegen = baseFocusRegen * (1 + (gearStats.haste || 0) * 0.01);
                    pet.userData.focus = pet.userData.maxFocus;
                    
                    // === Reset combat stats ===
                    pet.userData.totalDamageDealt = 0;
                    pet.userData.totalDamageTaken = 0;
                    pet.userData.totalDamageAvoided = 0;
                    pet.userData.totalDamageBlocked = 0;
                    pet.userData.totalDamageRedirected = 0;
                    pet.userData.killCount = 0;
                    pet.userData.highestHit = 0;
                    pet.userData.lastDamageTakenTime = 0;
                    pet.userData.frenzyStacks = 0;
                    pet.userData.frenzyUntil = 0;
                    
                    // Position pet next to owner
                    pet.position.set(char.position.x + 1.5, 0, char.position.z);
                    pet.rotation.y = 0;
                    
                    scene.add(pet);
                    gameState.team.push(pet);
                    
                    createPetNameplate(pet.userData.nameplateId, false, pet.userData);
                }
            }

            // Create enemies (ENEMY TEAM) - North Spawn
            for (let i = 0; i < enemies.length; i++) {
                const char = enemies[i];
                const classType = enemyComp[i];

                // Position enemies in a line at the north end
                char.position.set((i - 1) * 3, 0, 15);
                char.rotation.y = Math.PI;
                
            // Enemy MMR based on player rating with slight randomness
            // Enemies are slightly above/below your rating to simulate matchmaking
            const enemyMMR = Math.max(0, gameState.arenaRating + (Math.random() * 200 - 50));
            char.userData.enemyMMR = enemyMMR;
            
            // Prestige Difficulty Scaling (Compounding 1.25x per level)
            const prestigePowerFactor = Math.pow(1.25, gameState.prestigeLevel);
            char.userData.powerScale = prestigePowerFactor; // Store for use in combat calculations

            // Enemy scaling based on their MMR (more realistic difficulty curve)
            // Past 2400 (Gladiator), scaling accelerates for infinite challenge
            let ratingScale = (1 + (enemyMMR / 1000) * 0.3) * prestigePowerFactor;
            if (enemyMMR > 2400) {
                // Accelerate scaling past Gladiator rank
                const gladiatorExpertise = (enemyMMR - 2400) / 600; 
                ratingScale *= (1 + gladiatorExpertise);
            }
            
            const baseHealth = char.userData.classData.health;
            char.userData.maxHealth = baseHealth * ratingScale;
            char.userData.health = char.userData.maxHealth;
            char.userData.resilience = Math.min(0.6, 0.1 * ratingScale); // Cap resilience to keep matches killable
            
            // Generic enemy mana setup
            const isCaster = char.userData.classData.role === 'healer' || char.userData.classData.role === 'ranged';
            const isEnergy = char.userData.classType === 'rogue';
            const isRage = char.userData.classType === 'warrior';
            
            char.userData.maxMana = isCaster ? 50000 * ratingScale : (isEnergy || isRage ? 100 : 0);
            char.userData.mana = isRage ? 0 : char.userData.maxMana;
            char.userData.manaRegen = isCaster ? 500 * ratingScale : 0;
            char.userData.lastSpellCastTime = -10;
            
            scene.add(char);
            gameState.enemies.push(char);
            
            // Add hunter/warlock pet to scene separately
            if ((classType === 'hunter' || classType === 'warlock') && char.userData.pet) {
                const pet = char.userData.pet;
                pet.userData.ownerRef = char; // Link back to owner
                pet.userData.powerScale = prestigePowerFactor;
                const isHunterPet = classType === 'hunter';
                
                // =============================================
                // ENEMY PET STAT SCALING v2 (mirrors player system)
                // =============================================
                const ownerHP = char.userData.maxHealth;
                const ownerRes = char.userData.resilience;
                
                // === HP ===
                const petHealthRatio = isHunterPet ? 0.50 : 0.45;
                const flatHpFloor = (isHunterPet ? 5000 : 4000) * ratingScale;
                pet.userData.maxHealth = Math.max(flatHpFloor, ownerHP * petHealthRatio);
                pet.userData.health = pet.userData.maxHealth;
                
                // === Damage ===
                const basePetDmg = isHunterPet ? 2800 : 2200;
                pet.userData.baseDamage = basePetDmg * ratingScale;
                pet.userData.damage = pet.userData.baseDamage;
                
                // === Crit ===
                pet.userData.critChance = Math.min(0.30, 0.15 + (enemyMMR / 10000));
                pet.userData.critMult = 1.8 + Math.min(0.4, enemyMMR / 8000);
                
                // Scale ability damage
                const dmgScale = ratingScale;
                if (pet.userData.abilities) {
                    Object.values(pet.userData.abilities).forEach(ability => {
                        if (ability.damage) ability.damage = ability.damage * dmgScale;
                    });
                }
                
                // === Resilience ===
                pet.userData.resilience = Math.min(0.40, 0.10 + ownerRes * 0.5);
                
                // === Armor: diminishing returns (enemy pets scale with rating) ===
                const armorK = isHunterPet ? 10000 : 15000;
                const baseArmorRating = (isHunterPet ? 3200 : 1800) * ratingScale;
                pet.userData.armorRating = baseArmorRating;
                pet.userData.armor = pet.userData.armorRating / (pet.userData.armorRating + armorK);
                
                // === Avoidance: enemy pets scale with MMR ===
                if (isHunterPet) {
                    pet.userData.dodgeChance = Math.min(0.15, 0.08 + enemyMMR / 20000);
                    pet.userData.parryChance = 0.04;
                    pet.userData.spellResist = 0;
                } else {
                    pet.userData.dodgeChance = 0.03;
                    pet.userData.parryChance = 0;
                    pet.userData.spellResist = Math.min(0.20, 0.12 + enemyMMR / 15000);
                }
                
                // === Focus ===
                pet.userData.focusRegen = (isHunterPet ? 5.0 : 4.0) * (1 + ratingScale * 0.05);
                pet.userData.focus = pet.userData.maxFocus;
                
                // === Reset combat stats ===
                pet.userData.totalDamageDealt = 0;
                pet.userData.totalDamageTaken = 0;
                pet.userData.totalDamageAvoided = 0;
                pet.userData.totalDamageBlocked = 0;
                pet.userData.totalDamageRedirected = 0;
                pet.userData.killCount = 0;
                pet.userData.highestHit = 0;
                pet.userData.lastDamageTakenTime = 0;
                pet.userData.frenzyStacks = 0;
                pet.userData.frenzyUntil = 0;
                    
                    // Position pet next to owner
                    pet.position.set(char.position.x + 1.5, 0, char.position.z);
                    pet.rotation.y = Math.PI;
                    
                    scene.add(pet);
                    gameState.enemies.push(pet);
                    
                    createPetNameplate(pet.userData.nameplateId, true, pet.userData);
                }
            }


            updateHealthBars();
            gameState.inMatch = true; // Match is now ready to start
        }

        // LOS Checking
        const raycaster = new THREE.Raycaster();
        const losCache = new Map(); // Performance: Cache LOS checks
        let lastLosCacheClear = 0;

        function checkLineOfSight(source, target) {
            if (!source || !target) return false;
            
            // Performance: Throttle LOS checks by caching results for 100ms
            const now = performance.now();
            const cacheKey = `${source.id}-${target.id}`;
            if (losCache.has(cacheKey)) {
                const entry = losCache.get(cacheKey);
                if (now - entry.time < 100) return entry.result;
            }

            const start = source.position.clone().add(new THREE.Vector3(0, 2, 0));
            const end = target.position.clone().add(new THREE.Vector3(0, 2, 0));
            const direction = end.clone().sub(start).normalize();
            const distance = start.distanceTo(end);

            raycaster.set(start, direction);
            // Use recursive: true because pillars might be nested in Groups
            const intersects = raycaster.intersectObjects(arenaObstacles, true);

            let result = true;
            // If we hit something closer than the target, LOS is broken
            for (let intersect of intersects) {
                if (intersect.distance < distance - 0.5) {
                    result = false;
                    break;
                }
            }

            losCache.set(cacheKey, { result, time: now });
            return result;
        }

        // ============================================
        // IMPROVED MOVEMENT SYSTEM
        // ============================================

        // ============================================
        // COMBAT SYSTEM (Authentic WoW Arena)
        // ============================================
        function killCharacter(char) {
            if (!char.userData) return;
            
            // Mark as dead immediately
            const wasAlreadyDead = char.userData.health <= 0;
            char.userData.health = 0;
            char.visible = false;
            char.userData.ccUntil = 0;
            char.userData.castingUntil = 0;
            char.userData.target = null;
            
            // Always attempt removal regardless of previous health state to ensure no "stuck" models
            if (char.parent) {
                char.parent.remove(char);
            }
            scene.remove(char); 
            
            // Clear nameplate immediately
            const nameplateId = char.userData.nameplateId;
            const nameplate = document.getElementById(`nameplate-${nameplateId}`);
            if (nameplate) {
                // One last health update to 0% for visual clarity before removal
                const healthFill = nameplate.querySelector('.nameplate-health-fill') || nameplate.querySelector('.pet-health-fill');
                if (healthFill) healthFill.style.width = '0%';
                
                // Also zero ghost bar on pet nameplates
                const ghostBar = nameplate.querySelector('.pet-health-ghost');
                if (ghostBar) ghostBar.style.width = '0%';
                
                // Hide and remove
                nameplate.style.display = 'none';
                nameplate.remove();
            }
            
            // Cleanup cache
            if (nameplateId) {
                nameplateCaches.delete(nameplateId);
            }
            
            if (!wasAlreadyDead) {
                // Clean up Soul Link if a felhunter dies
                if (char.userData.isPet && char.userData.petType === 'warlock_pet' && char.userData.soulLinkActive) {
                    const owner = char.userData.ownerRef;
                    if (owner) {
                        owner._soulLinked = false;
                        // Remove Soul Link aura from owner
                        if (owner.userData && owner.userData.auras) {
                            owner.userData.auras = owner.userData.auras.filter(a => a.name !== 'Soul Link');
                        }
                    }
                }
                
                // Proper name resolution: pets use petName, players use classData.name
                const unitName = char.userData.isPet 
                    ? `${char.userData.isEnemy ? 'Enemy' : 'Ally'} ${char.userData.petName || 'Pet'}`
                    : (char.userData.classData?.name || 'Unit');
                
                // Pet death includes damage stats + avoidance summary in log
                if (char.userData.isPet && char.userData.totalDamageDealt > 0) {
                    const fmtK = (n) => n >= 1000 ? `${(n / 1000).toFixed(1)}k` : Math.round(n);
                    const dmgStr = fmtK(char.userData.totalDamageDealt);
                    const avoidStr = (char.userData.totalDamageAvoided || 0) > 0 
                        ? `, ${fmtK(char.userData.totalDamageAvoided)} avoided` : '';
                    const blockStr = (char.userData.totalDamageBlocked || 0) > 0 
                        ? `, ${fmtK(char.userData.totalDamageBlocked)} blocked` : '';
                    const redirectStr = (char.userData.totalDamageRedirected || 0) > 0 
                        ? `, ${fmtK(char.userData.totalDamageRedirected)} soul-linked` : '';
                    addCombatLog(`${unitName} has died! (dealt ${dmgStr} damage${char.userData.killCount > 0 ? `, ${char.userData.killCount} kill(s)` : ''}${avoidStr}${blockStr}${redirectStr})`, 'death');
                } else {
                    addCombatLog(`${unitName} has died!`, 'death');
                }
                
                if (window.triggerCrowdCheer) window.triggerCrowdCheer(2.0);
                
                // Clear targets of others
                [...gameState.team, ...gameState.enemies].forEach(other => {
                    if (other.userData.target === char) other.userData.target = null;
                });
            }
        }

        function updateCombat(deltaTime) {
            if (!gameState.inMatch) return;

            const speedMultiplier = 1 + gameState.upgrades.matchSpeed * 0.08;
            const effectiveDelta = deltaTime * speedMultiplier;
            gameState.matchTime += effectiveDelta;
            
            // Performance Throttling
            const ps = gameState.PERF_STREAMS;
            ps.aiTick += effectiveDelta;
            ps.uiTick += effectiveDelta;
            const isAiTick = ps.aiTick >= ps.aiHeartbeat;
            const isUiTick = ps.uiTick >= ps.uiHeartbeat;

            if (isAiTick) ps.aiTick = 0;
            if (isUiTick) ps.uiTick = 0;

            // ARENA GATE OPENING SEQUENCE
            if (gameState.matchState === 'waiting') {
                gameState.gateTimer += effectiveDelta;
                
                if (gameState.gateTimer >= 3 && gameState.gateState === 'closed') {
                    // 3 second countdown
                    showArenaAnnouncement('3', 800);
                    gameState.gateState = 'countdown3';
                } else if (gameState.gateTimer >= 4 && gameState.gateState === 'countdown3') {
                    showArenaAnnouncement('2', 800);
                    gameState.gateState = 'countdown2';
                } else if (gameState.gateTimer >= 5 && gameState.gateState === 'countdown2') {
                    showArenaAnnouncement('1', 800);
                    gameState.gateState = 'countdown1';
                } else if (gameState.gateTimer >= 6 && gameState.gateState === 'countdown1') {
                    // Open gates!
                    showArenaAnnouncement('FIGHT!', 1500);
                    addCombatLog('Arena gates open! Fight begins!', 'buff');
                    gameState.gateState = 'opening';
                    gameState.matchState = 'fighting';
                    
                    // Fade out gates
                    if (window.arenaGates) {
                        window.arenaGates.forEach(gate => {
                            let opacity = 0.6;
                            const fadeOut = setInterval(() => {
                                opacity -= 0.05;
                                gate.barrier.material.opacity = Math.max(0, opacity);
                                gate.glow.material.opacity = Math.max(0, opacity * 0.33);
                                
                                if (opacity <= 0) {
                                    clearInterval(fadeOut);
                                    gate.group.visible = false;
                                    gameState.gateState = 'open';
                                }
                            }, 50);
                        });
                    }
                }
                
                // Characters can't move during countdown
                return;
            }

            // Dampening mechanic - healing reduction over time (starts at 60s)
            const dampening = gameState.matchTime > 60 ? Math.min(0.9, (gameState.matchTime - 60) / 300) : 0;
            
            // Announce dampening at key thresholds
            if (!gameState.dampeningAnnounced) gameState.dampeningAnnounced = {};
            
            if (gameState.matchTime >= 60 && !gameState.dampeningAnnounced['60']) {
                showArenaAnnouncement('DAMPENING: 10%', 2000);
                addCombatLog('Dampening activated! Healing reduced by 10%', 'cc');
                gameState.dampeningAnnounced['60'] = true;
            } else if (gameState.matchTime >= 120 && !gameState.dampeningAnnounced['120']) {
                const dampeningPercent = Math.round(dampening * 100);
                showArenaAnnouncement(`SHADOW SIGHT: DAMPENING ${dampeningPercent}%`, 2000);
                addCombatLog('Shadow Sight active! Stealth and LoS dancing is harder!', 'cc');
                addCombatLog(`Dampening increased to ${dampeningPercent}%`, 'cc');
                gameState.dampeningAnnounced['120'] = true;
                
                // Visual effect: Pulse arena lighting
                if (window.ambientLight) {
                    const originalIntensity = window.ambientLight.intensity;
                    const pulse = setInterval(() => {
                        window.ambientLight.intensity = originalIntensity + (Math.sin(Date.now() * 0.01) * 0.2);
                        if (gameState.matchTime > 125) {
                            clearInterval(pulse);
                            window.ambientLight.intensity = originalIntensity;
                        }
                    }, 50);
                }
            } else if (gameState.matchTime >= 180 && !gameState.dampeningAnnounced['180']) {
                const dampeningPercent = Math.round(dampening * 100);
                showArenaAnnouncement(`DAMPENING: ${dampeningPercent}%`, 1500);
                addCombatLog(`Dampening increased to ${dampeningPercent}%`, 'cc');
                gameState.dampeningAnnounced['180'] = true;
            }

            // Update all characters (status effects, cooldowns, etc.)
            [...gameState.team, ...gameState.enemies].forEach(char => {
                const userData = char.userData;
                
                // Cooldowns (only for heroes with abilities arrays ‚Äî pets use object abilities handled in updatePetAI)
                if (userData.abilities && Array.isArray(userData.abilities)) {
                    userData.abilities.forEach(ability => {
                        if (ability.currentCooldown > 0) {
                            const gearStats = userData.isEnemy ? { cooldownReduction: 0 } : calculateTotalGearStats();
                            const talentCDR = userData.isEnemy ? 0 : getTalentBonus('tal_cdr');
                            const cdReduction = 1 - (gameState.upgrades.cooldownReduction * 0.05 + (gearStats.cooldownReduction || 0) * 0.01 + talentCDR);
                            ability.currentCooldown -= effectiveDelta * cdReduction;
                        }
                    });
                }

                // GCD Update
                if (userData.gcdUntil > 0) {
                    userData.gcdUntil -= effectiveDelta;
                }

                // Aura system update
                if (userData.auras) {
                    for (let i = userData.auras.length - 1; i >= 0; i--) {
                        userData.auras[i].duration -= effectiveDelta;
                        if (userData.auras[i].duration <= 0) {
                            userData.auras.splice(i, 1);
                        }
                    }
                }

                // CC duration countdown
                if (userData.ccUntil > 0) {
                    userData.ccUntil -= effectiveDelta;
                    if (userData.ccUntil <= 0) {
                        userData.ccType = null;
                    }
                }

                // Buff/debuff duration
                if (userData.buffUntil > 0) {
                    userData.buffUntil -= effectiveDelta;
                }

                // Inner Focus / Efficiency handled during spell casting
                
                // Second Wind Talent: Passive heal when dropping below 30%
                if (!userData.isEnemy && !userData.isPet && userData.health > 0) {
                    const recoveryBonus = getTalentBonus('tal_recovery');
                    if (recoveryBonus > 0) {
                        const hpPct = userData.health / userData.maxHealth;
                        const now = gameState.matchTime;
                        if (hpPct < 0.3 && (!userData.lastRecoveryTime || now - userData.lastRecoveryTime > 30)) {
                            const healAmount = userData.maxHealth * recoveryBonus;
                            userData.health = Math.min(userData.maxHealth, userData.health + healAmount);
                            userData.lastRecoveryTime = now;
                            showDamageNumber(char.position, "SECOND WIND!", true, false, true);
                            soundManager.playMagic('E4');
                        }
                    }
                }

                // Trinket cooldown
                if (userData.trinketCooldown > 0) {
                    userData.trinketCooldown -= effectiveDelta;
                }

                // Mana regeneration (for healers and energy classes)
                if (userData.maxMana > 0) {
                    if (userData.classType === 'rogue') {
                        // Rogue Energy Regen (10 per second)
                        userData.mana = Math.min(userData.maxMana, userData.mana + 10 * effectiveDelta);
                    } else if (userData.classType === 'warrior') {
                        // Warrior Rage doesn't naturally regen
                    } else if (userData.mana < userData.maxMana) {
                        const isCaster = userData.classData?.role === 'healer' || userData.classData?.role === 'ranged';
                        let regenAmount = (userData.manaRegen || 0) * effectiveDelta;
                        
                        if (isCaster) {
                            // 5-Second Rule: Full regen if no spell cast for 5s, else 30% regen
                            const timeSinceLastCast = gameState.matchTime - (userData.lastSpellCastTime || 0);
                            if (timeSinceLastCast < 5) {
                                regenAmount *= 0.3; // Casting/recently cast penalty
                            }
                        }
                        
                        userData.mana = Math.min(userData.maxMana, userData.mana + regenAmount);
                    }
                }

                // Diminishing returns reset (18 seconds)
                if (!userData.drState) {
                    userData.drState = {};
                    Object.values(DR_CATEGORIES).forEach(cat => {
                        userData.drState[cat] = { stacks: 0, timer: 0 };
                    });
                }

                // LoS Failure tracking for stalemate prevention (Stalemate Buster)
                userData.timeSinceLastSeen = userData.timeSinceLastSeen || 0;
                const hasTargetLOS = userData.target ? checkLineOfSight(char, userData.target) : true;
                if (userData.target && !hasTargetLOS && userData.health > 0) {
                    userData.timeSinceLastSeen += effectiveDelta;
                } else {
                    userData.timeSinceLastSeen = 0;
                }

                let maxDrStacks = 0;
                Object.keys(userData.drState).forEach(cat => {
                    if (userData.drState[cat].timer > 0) {
                        userData.drState[cat].timer -= effectiveDelta;
                        if (userData.drState[cat].timer <= 0) {
                            userData.drState[cat].stacks = 0;
                        } else {
                            maxDrStacks = Math.max(maxDrStacks, userData.drState[cat].stacks);
                        }
                    }
                });
                userData.drStacks = maxDrStacks; // Sync with visual nameplate state

                // School lock (from interrupts)
                if (userData.schoolLockedUntil > 0) {
                    userData.schoolLockedUntil -= effectiveDelta;
                }

                // Casting progress
                if (userData.castingTarget && userData.castingAbility) {
                    const target = userData.castingTarget;
                    
                    // IF CC'd while casting, interrupt the cast
                    if (userData.ccUntil > 0) {
                        userData.interruptedUntil = gameState.matchTime + 1.5;
                        userData.interruptedSpellName = userData.castingAbility.name;
                        userData.castingAbility = null;
                        userData.castingTarget = null;
                        userData.castProgress = 0;
                        showDamageNumber(char.position, 'INTERRUPTED', false, false, true);
                    } else if (!checkLineOfSight(char, target)) {
                        // LOS Check during cast: If LoS is broken for more than 0.4s, cast fails
                        // Shadow Sight reduces this grace period to 0.15s, making LoS dancing much harder
                        const gracePeriod = (gameState.matchTime > 120) ? 0.15 : 0.4;
                        userData.losFailureTime = (userData.losFailureTime || 0) + effectiveDelta;
                        if (userData.losFailureTime > gracePeriod) {
                            userData.interruptedUntil = gameState.matchTime + 1.5;
                            userData.interruptedSpellName = userData.castingAbility.name;
                            userData.castingAbility = null;
                            userData.castingTarget = null;
                            userData.castProgress = 0;
                            userData.losFailureTime = 0;
                            showDamageNumber(char.position, 'LoS BROKEN', false, false, true);
                            addCombatLog(`${userData.classData.name}'s cast was interrupted by Line of Sight!`, 'cc');
                        }
                    } else {
                        userData.losFailureTime = 0;
                        
                        // Apply Haste to casting speed
                        const gearStats = userData.isEnemy ? { haste: 0 } : calculateTotalGearStats();
                        const hasteVal = (gameState.upgrades.matchSpeed * 0.08) + (gearStats.haste || 0) * 0.01;
                        const castSpeedMultiplier = 1 + hasteVal;
                        
                        userData.castProgress += effectiveDelta * castSpeedMultiplier;
                        
                        const castTime = userData.castingAbility.castTime || 1.5;
                        if (userData.castProgress >= castTime) {
                            // Cast complete!
                            finishCast(char);
                        }
                    }
                }
                
                // Snares/Slows recovery
                const baseSpeed = userData.isPet ? 5 : (userData.classData?.role === 'melee' ? 4 : 2.5);
                if (userData.moveSpeed < baseSpeed) {
                    userData.moveSpeed = THREE.MathUtils.lerp(userData.moveSpeed, baseSpeed, 0.05);
                }

                // Track buff uptime for player team
                if (!userData.isEnemy && !userData.isPet && userData.auras) {
                    const hasBuffs = userData.auras.some(a => a.type === 'buff');
                    if (hasBuffs && userData.health > 0) {
                        gameState.matchStats.buffUptime += effectiveDelta;
                    }
                }
            });

            // MOVEMENT & PHYSICS (Run every frame for smoothness)
            executeTeamMovement(gameState.team, gameState.enemies, effectiveDelta);
            executeTeamMovement(gameState.enemies, gameState.team, effectiveDelta);

            // STRATEGIC AI & DECISIONS (Throttled to Heartbeat)
            if (isAiTick) {
                executeTeamAIDecisions(gameState.team, gameState.enemies, dampening);
                executeTeamAIDecisions(gameState.enemies, gameState.team, dampening);
            }

            // UI UPDATES (Throttled)
            if (isUiTick) {
                updateNameplates();
                updateHealthBars();
            }

            // PET AI (Independent logic)
            updatePetAI(effectiveDelta);

            // POST-MOVEMENT GROUNDING & FIXES (Ensures no floating/bouncing)
            [...gameState.team, ...gameState.enemies].forEach(char => {
                if (isNaN(char.position.x) || isNaN(char.position.z)) {
                    char.position.set(0, 0, 0);
                    char.userData.velocity.set(0, 0, 0);
                }
                
                // Hard Boundary Check: Keep everyone inside the arena
                const distFromCenterSq = char.position.x ** 2 + char.position.z ** 2;
                if (distFromCenterSq > 19 * 19) {
                    const dist = Math.sqrt(distFromCenterSq);
                    const pullBack = new THREE.Vector3(-char.position.x, 0, -char.position.z).normalize();
                    // If way outside (e.g. 25+), hard snap back to 16
                    if (dist > 25) {
                        char.position.set(pullBack.x * -16, char.position.y, pullBack.z * -16);
                        char.userData.velocity?.set(0, 0, 0); // Kill momentum
                    } else {
                        // Strong push back
                        char.position.add(pullBack.multiplyScalar((dist - 19) * 0.9));
                    }
                }

                const targetY = getGroundHeight(char.position.x, char.position.z, char.position.y);
                const heightDiff = char.position.y - targetY;
                
                // Force XZ movement only in velocity
                char.userData.velocity.y = 0;
                
                // If character falls too far below ground, snap them up
                if (heightDiff < -0.1) {
                    char.position.y = targetY;
                } else if (heightDiff > 0.001) {
                    // Smoothly descend to ground (Gravity simulation)
                    char.position.y = THREE.MathUtils.lerp(char.position.y, targetY, 0.2);
                } else {
                    char.position.y = targetY;
                }
            });

            // Check match end - only if teams are actually populated
            if (gameState.team.length === 0 || gameState.enemies.length === 0) return;

            // SAFETY TIMEOUT: End match if it exceeds 5 minutes
            if (gameState.matchTime > 300 && gameState.inMatch) {
                const teamHP = gameState.team.reduce((sum, c) => sum + (c.userData.health || 0), 0);
                const enemyHP = gameState.enemies.reduce((sum, c) => sum + (c.userData.health || 0), 0);
                addCombatLog("Match Timeout! Determining winner by health...", "cc");
                endMatch(teamHP > enemyHP);
                return;
            }

            const teamAlive = gameState.team.filter(c => c.userData.health > 0.5 && !c.userData.isPet).length;
            const enemiesAlive = gameState.enemies.filter(c => c.userData.health > 0.5 && !c.userData.isPet).length;

            // Ensure any character with very low health is properly killed
            [...gameState.team, ...gameState.enemies].forEach(char => {
                if (char.userData.health > 0 && char.userData.health <= 0.5) {
                    killCharacter(char);
                }
            });

            if ((teamAlive === 0 || enemiesAlive === 0) && gameState.inMatch) {
                endMatch(teamAlive > 0);
            }

            updateHealthBars();
        }

        function executeTeamMovement(team, enemies, deltaTime) {
            const aliveEnemies = enemies.filter(e => e.userData.health > 0 && !e.userData.isPet);
            const aliveAllies = team.filter(a => a.userData.health > 0 && !a.userData.isPet);
            
            if (aliveEnemies.length === 0 || aliveAllies.length === 0) return;

            // STALEMATE DETECTION (Pro Logic)
            const totalAlive = aliveEnemies.length + aliveAllies.length;
            const timeSinceAction = gameState.matchTime - (gameState.matchStats.lastCombatActionTime || 0);
            const isStalemate = timeSinceAction > 8.0;
            const isCriticalStalemate = timeSinceAction > 15.0; // Deep stalemate - force center push
            const isDuelingSituation = totalAlive <= 2; // 1v1 situations often stalemate at pillars
            const isShadowSightActive = gameState.matchTime > 120; // After 2 mins, vision improves

            // 1. CALCULATE THREAT CENTER (Enemy Pressure)
            const enemyThreatCenter = new THREE.Vector3(0, 0, 0);
            aliveEnemies.forEach(e => enemyThreatCenter.add(e.position));
            enemyThreatCenter.divideScalar(aliveEnemies.length);

            aliveAllies.forEach((char, index) => {
                if (char.userData.gcdUntil > 0 || char.userData.castingAbility) return;
                
                const role = char.userData.classData?.role;
                const isHealer = role === 'healer';
                const myHealthScalar = char.userData.health / char.userData.maxHealth;

                // PVP TRINKET AI
                if (char.userData.ccUntil > 2 && char.userData.trinketCooldown <= 0) {
                    let shouldTrinket = false;
                    if (isHealer) {
                        const criticalAlly = aliveAllies.find(a => (a.userData.health / a.userData.maxHealth) < 0.35);
                        if (criticalAlly) shouldTrinket = true;
                    }
                    if (myHealthScalar < 0.25) shouldTrinket = true;
                    if (char.userData.ccUntil > 5) shouldTrinket = true;
                    if (shouldTrinket) {
                        useTrinket(char);
                    }
                }

                if (char.userData.ccUntil > 0) {
                    char.userData.velocity.multiplyScalar(0.9); 
                    return;
                }

                if (!char.userData.classData) return;

                const isRanged = role === 'ranged';

                // 2. DETERMINE TARGET POSITION & BEHAVIOR
                let targetPos = new THREE.Vector3().copy(char.position);
                let optimalRange = 1.5;
                let behavior = 'aggressive'; 

                // Kill Target Detection: If any enemy is very low, everyone becomes aggressive
                const killTarget = aliveEnemies.find(e => (e.userData.health / e.userData.maxHealth) < 0.3);
                const pressureTarget = aliveEnemies.find(e => e.userData.classData.role === 'healer') || aliveEnemies[0];

                if (role === 'melee') {
                    const target = killTarget || pressureTarget;
                    if (target) {
                        const spreadAngle = (index * (Math.PI * 2 / 3)) + (gameState.matchTime * 0.2);
                        const offset = new THREE.Vector3(Math.cos(spreadAngle) * 1.5, 0, Math.sin(spreadAngle) * 1.5);
                        targetPos.copy(target.position).add(offset);
                        optimalRange = 0.5;
                    }
                } else if (isRanged || isHealer) {
                    const nearestEnemy = aliveEnemies.sort((a,b) => char.position.distanceTo(a.position) - char.position.distanceTo(b.position))[0];
                    const threatDist = nearestEnemy ? char.position.distanceTo(nearestEnemy.position) : 999;
                    const beingAttacked = aliveEnemies.some(e => e.userData.target === char);
                    
                    // Behavior selection
                    const forceAggressive = isStalemate || (isDuelingSituation && myHealthScalar > 0.3) || isShadowSightActive;
                    
                    if (char.userData.timeSinceLastSeen > 4.0 || forceAggressive) behavior = 'aggressive'; // Stalemate Buster
                    else if (beingAttacked || myHealthScalar < 0.4 || (threatDist < 5 && !killTarget)) behavior = 'kiting';
                    else if (myHealthScalar < 0.7) behavior = 'defensive';
                    else if (killTarget) behavior = 'aggressive';
                    else behavior = 'support';

                    // Deep Stalemate Override: Force everyone to the center map to find LoS
                    if (isCriticalStalemate) {
                        behavior = 'aggressive';
                        const center = new THREE.Vector3(0, 0, 0);
                        targetPos.copy(center);
                        optimalRange = 0;
                    } else if (isHealer) {
                        const allyInNeed = aliveAllies.sort((a,b) => (a.userData.health/a.userData.maxHealth) - (b.userData.health/b.userData.maxHealth))[0];
                        if (allyInNeed) {
                            const nearestPillar = arenaObstacles.sort((a,b) => char.position.distanceTo(a.position) - char.position.distanceTo(b.position))[0];
                            
                            // HEALER PILLAR DANCING
                            // If kiting or kited, hide behind nearest pillar relative to nearest enemy
                            if (behavior === 'kiting' && nearestEnemy) {
                                if (nearestPillar && char.position.distanceTo(nearestPillar.position) < 15) {
                                    // Find position behind pillar relative to enemy
                                    const dirFromEnemyToPillar = new THREE.Vector3().subVectors(nearestPillar.position, nearestEnemy.position).normalize();
                                    targetPos.copy(nearestPillar.position).addScaledVector(dirFromEnemyToPillar, 2.5);
                                    optimalRange = 0.2;
                                } else {
                                    const dirAway = new THREE.Vector3().subVectors(char.position, nearestEnemy.position).normalize();
                                    targetPos.copy(char.position).addScaledVector(dirAway, 6.0);
                                    optimalRange = 0.5;
                                }
                            } else {
                                // Support mode: Try to stay near a pillar but peek to heal
                                // If ally NOT in LoS, must move to ally!
                                if (!checkLineOfSight(char, allyInNeed)) {
                                    targetPos.copy(allyInNeed.position);
                                    optimalRange = 5.0;
                                } else {
                                    targetPos.copy(allyInNeed.position);
                                    optimalRange = 12.0;
                                    
                                    if (nearestPillar && behavior !== 'aggressive') {
                                        const pillarPos = nearestPillar.position.clone();
                                        const distToPillar = char.position.distanceTo(pillarPos);
                                        
                                        if (distToPillar > 3) {
                                            targetPos.copy(pillarPos).addScaledVector(new THREE.Vector3().subVectors(char.position, pillarPos).normalize(), 2.0);
                                            optimalRange = 0.5;
                                        } else {
                                            targetPos.copy(char.position);
                                        }
                                    } else if (behavior === 'aggressive' && nearestEnemy) {
                                        // AGGRESSIVE HEALER: Chase to get CC/Damage LoS
                                        targetPos.copy(nearestEnemy.position);
                                        optimalRange = 8.0;
                                    }
                                }
                            }
                        }
                    } else if (isRanged) {
                        const target = char.userData.target || killTarget || pressureTarget;
                        if (target) {
                            const hasLOS = checkLineOfSight(char, target);
                            
                            if (behavior === 'kiting') {
                                const nearestPillar = arenaObstacles.sort((a,b) => char.position.distanceTo(a.position) - char.position.distanceTo(b.position))[0];
                                if (nearestPillar && nearestEnemy && char.position.distanceTo(nearestPillar.position) < 10) {
                                    // Hide behind pillar
                                    const dirFromEnemyToPillar = new THREE.Vector3().subVectors(nearestPillar.position, nearestEnemy.position).normalize();
                                    targetPos.copy(nearestPillar.position).addScaledVector(dirFromEnemyToPillar, 2.5);
                                    optimalRange = 0.2;
                                } else {
                                    const dirAway = new THREE.Vector3().subVectors(char.position, enemyThreatCenter).normalize();
                                    targetPos.copy(char.position).addScaledVector(dirAway, 10.0);
                                    optimalRange = 1.0;
                                }
                            } else if (!hasLOS && behavior !== 'defensive') {
                                // AGGRESSIVE LOS: Move to re-establish LoS
                                const dirToTarget = new THREE.Vector3().subVectors(target.position, char.position).normalize();
                                
                                if (char.userData.timeSinceLastSeen > 4.0 || behavior === 'aggressive') {
                                    // Stalemate Buster: Move directly towards target or center to flush them out
                                    if (isCriticalStalemate) {
                                        targetPos.set(0, 0, 0);
                                        optimalRange = 0;
                                    } else {
                                        // Orbit the target to "peek" around their pillar
                                        const orbitAngle = gameState.matchTime * 0.5;
                                        const orbitOffset = new THREE.Vector3(Math.cos(orbitAngle) * 6, 0, Math.sin(orbitAngle) * 6);
                                        targetPos.copy(target.position).add(orbitOffset);
                                        optimalRange = 1.0;
                                    }
                                } else {
                                    // Try moving perpendicular to the direction to peek around obstacle
                                    const peekDir = new THREE.Vector3(-dirToTarget.z, 0, dirToTarget.x).multiplyScalar(5.0);
                                    targetPos.copy(char.position).add(peekDir).addScaledVector(dirToTarget, 2.0);
                                    optimalRange = 0.5;
                                }
                            } else {
                                // Standard Ranged Positioning
                                const dirToTarget = new THREE.Vector3().subVectors(target.position, char.position).normalize();
                                targetPos.copy(target.position).addScaledVector(dirToTarget, -18.0);
                                optimalRange = 2.0;
                            }
                        }
                    }
                }

                // 3. APPLY STEERING (XZ ONLY)
                
                // Vertical Pathfinding: If target is on a different level, head to the ramp first
                if (needsLevelChange(char.position, targetPos)) {
                    if (!char.userData.currentWaypoint) {
                        char.userData.currentWaypoint = getRampEntryPoint(char.position, targetPos);
                    }
                    
                    if (char.userData.currentWaypoint) {
                        const distToWaypoint = new THREE.Vector3(char.position.x, 0, char.position.z)
                            .distanceTo(new THREE.Vector3(char.userData.currentWaypoint.x, 0, char.userData.currentWaypoint.z));
                            
                        if (distToWaypoint < 1.0) {
                            // Reached waypoint, now try to reach final target or next waypoint
                            char.userData.currentWaypoint = null;
                        } else {
                            // Override target with waypoint
                            targetPos.copy(char.userData.currentWaypoint);
                        }
                    }
                } else {
                    char.userData.currentWaypoint = null;
                }

                const toTarget = new THREE.Vector3().subVectors(targetPos, char.position);
                toTarget.y = 0;
                const distToTarget = toTarget.length();
                
                let desiredSpeed = char.userData.moveSpeed;
                if (distToTarget < optimalRange) {
                    desiredSpeed = 0;
                } else if (distToTarget < optimalRange + 3) {
                    desiredSpeed *= (distToTarget - optimalRange) / 3;
                }
                
                if (toTarget.lengthSq() > 0.001) {
                    toTarget.normalize().multiplyScalar(desiredSpeed);
                } else {
                    toTarget.set(0, 0, 0);
                }
                char.userData.desiredVelocity.copy(toTarget);

                // 4. SEPARATION (Soft Pressure)
                const separationForce = new THREE.Vector3(0, 0, 0);
                aliveAllies.forEach(other => {
                    if (other === char) return;
                    const diff = new THREE.Vector3().subVectors(char.position, other.position);
                    diff.y = 0;
                    const dist = diff.length();
                    const minSep = isHealer ? 5.0 : 3.0; 
                    if (dist < minSep && dist > 0.1) {
                        const strength = (minSep - dist) / minSep;
                        diff.normalize().multiplyScalar(strength * 2.5);
                        separationForce.add(diff);
                    }
                });
                char.userData.desiredVelocity.add(separationForce);

                // Final Velocity Smoothing
                const acceleration = 12.0;
                const velocityChange = new THREE.Vector3().subVectors(char.userData.desiredVelocity, char.userData.velocity);
                velocityChange.y = 0;
                if (velocityChange.length() > acceleration * deltaTime) {
                    velocityChange.normalize().multiplyScalar(acceleration * deltaTime);
                }
                char.userData.velocity.add(velocityChange);
                char.userData.velocity.y = 0;

                // 5. MOVE & BOUNDS
                if (!isNaN(char.userData.velocity.x) && !isNaN(char.userData.velocity.z)) {
                    char.position.add(char.userData.velocity.clone().multiplyScalar(deltaTime));
                }

                // Arena Bounds (Soft constraint)
                const distFromCenter = Math.sqrt(char.position.x ** 2 + char.position.z ** 2);
                if (distFromCenter > 17.0) {
                    const pullBack = new THREE.Vector3(-char.position.x, 0, -char.position.z).normalize();
                    char.position.add(pullBack.multiplyScalar((distFromCenter - 17.0) * 0.5));
                }

                // Face movement
                if (char.userData.velocity.lengthSq() > 0.1) {
                    const targetAngle = Math.atan2(char.userData.velocity.x, char.userData.velocity.z);
                    char.rotation.y = THREE.MathUtils.lerp(char.rotation.y, targetAngle, 0.1);
                }

                char.userData.lastPosition.copy(char.position);
            });

            // 6. DAMPED COLLISION RESPONSE (Fixes Shaking)
            const allUnits = [...aliveAllies, ...aliveEnemies];
            allUnits.forEach((char, i) => {
                for (let j = i + 1; j < allUnits.length; j++) {
                    const other = allUnits[j];
                    const diff = new THREE.Vector3().subVectors(char.position, other.position);
                    diff.y = 0;
                    const distSq = diff.lengthSq();
                    const minDist = 1.2; // Combined radius
                    if (distSq < minDist * minDist) {
                        const dist = Math.sqrt(distSq) || 0.1;
                        const pushAmount = (minDist - dist) * 0.15; // Soft push instead of snap
                        const pushVec = diff.normalize().multiplyScalar(pushAmount);
                        char.position.add(pushVec);
                        other.position.sub(pushVec);
                    }
                }
                
                // Pillar Collision (Soft push)
                collisionObjects.forEach(obstacle => {
                    const diff = new THREE.Vector3(char.position.x - obstacle.x, 0, char.position.z - obstacle.z);
                    const distSq = diff.lengthSq();
                    const minDist = 0.8 + obstacle.radius;
                    if (distSq < minDist * minDist) {
                        const dist = Math.sqrt(distSq) || 0.1;
                        const pushAmount = (minDist - dist) * 0.3;
                        const pushVec = diff.normalize().multiplyScalar(pushAmount);
                        char.position.add(pushVec);
                    }
                });
            });
        }

        function executeTeamAIDecisions(team, enemies, dampening) {
            const aliveEnemies = enemies.filter(e => e.userData.health > 0 && !e.userData.isPet);
            const aliveAllies = team.filter(a => a.userData.health > 0 && !a.userData.isPet);
            if (aliveEnemies.length === 0 || aliveAllies.length === 0) return;

            aliveAllies.forEach((char) => {
                const role = char.userData.classData?.role;
                const isHealer = role === 'healer';
                const myHealthScalar = char.userData.health / char.userData.maxHealth;

                // 1. REFRESH TARGETING (Essential for Movement)
                // Sort enemies by kill priority based on Team Doctrine
                const sortedEnemies = aliveEnemies.sort((a, b) => {
                    const aHP = a.userData.health / a.userData.maxHealth;
                    const bHP = b.userData.health / b.userData.maxHealth;
                    
                    // Kill priority: Always target critical units (<30% HP)
                    if (aHP < 0.3 && bHP >= 0.3) return -1;
                    if (bHP < 0.3 && aHP >= 0.3) return 1;

                    if (char.userData.isEnemy) {
                        // Enemy AI follows Balanced priority
                        const aIsHealer = a.userData.classData.role === 'healer';
                        const bIsHealer = b.userData.classData.role === 'healer';
                        if (aIsHealer && !bIsHealer) return -1;
                        if (bIsHealer && !aIsHealer) return 1;
                    } else {
                        // Player Team follows selected Doctrine
                        const doctrine = gameState.teamDoctrine;
                        if (doctrine === 'tunnel_healer') {
                            const aIsHealer = a.userData.classData.role === 'healer';
                            const bIsHealer = b.userData.classData.role === 'healer';
                            if (aIsHealer && !bIsHealer) return -1;
                            if (bIsHealer && !aIsHealer) return 1;
                        } else if (doctrine === 'tunnel_dps') {
                            const aIsHealer = a.userData.classData.role === 'healer';
                            const bIsHealer = b.userData.classData.role === 'healer';
                            if (!aIsHealer && bIsHealer) return -1;
                            if (!bIsHealer && aIsHealer) return 1;
                        } else if (doctrine === 'split_pressure') {
                            // Split: try to target whoever isn't being targeted by allies
                            const aTargetedCount = aliveAllies.filter(allied => allied !== char && allied.userData.target === a).length;
                            const bTargetedCount = aliveAllies.filter(allied => allied !== char && allied.userData.target === b).length;
                            if (aTargetedCount < bTargetedCount) return -1;
                            if (bTargetedCount < aTargetedCount) return 1;
                        } else {
                            // Balanced (Standard priority)
                            const aIsHealer = a.userData.classData.role === 'healer';
                            const bIsHealer = b.userData.classData.role === 'healer';
                            if (aIsHealer && !bIsHealer) return -1;
                            if (bIsHealer && !aIsHealer) return 1;
                        }
                    }
                    
                    return aHP - bHP;
                });

                // Set persistent target for movement logic to track
                char.userData.target = sortedEnemies[0];

                // Root allows ability usage but prevents movement; all other CC prevents both
                if ((char.userData.ccUntil > 0 && char.userData.ccType !== 'root') || char.userData.gcdUntil > 0 || char.userData.castingAbility || !char.userData.classData) return;
                
                // Reaction Delay (Difficulty Scales with Rating and Prestige for Enemies)
                // Enemies get faster as prestige and rating increase, reducing their decision delay.
                let reactionThreshold = 0.85;
                if (char.userData.isEnemy) {
                    // At higher rating/prestige, reactionThreshold drops, making enemies check logic more often.
                    // Scaling is now infinite, capping at 0.8 to ensure at least 0.05 delay
                    const difficultyFactor = Math.min(0.8, (gameState.arenaRating / 3000) * 0.4 + (gameState.prestigeLevel * 0.15));
                    reactionThreshold = 0.85 - difficultyFactor;
                }
                if (Math.random() > reactionThreshold) return; 

                const abilities = char.userData.abilities;

                // 2. DEFENSIVE CHECK
                const defensiveAbility = abilities.find(a => a.type === 'defensive' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                if (defensiveAbility && myHealthScalar < 0.4) {
                    useAbility(char, char, defensiveAbility, dampening);
                    defensiveAbility.currentCooldown = defensiveAbility.cooldown;
                    return;
                }

                // 3. INTERRUPT CHECK
                const interruptAbility = abilities.find(a => a.type === 'interrupt' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                if (interruptAbility) {
                    const castingEnemy = aliveEnemies.find(e => e.userData.castingAbility && checkLineOfSight(char, e) && char.position.distanceTo(e.position) < (role === 'melee' ? 5 : 30));
                    if (castingEnemy) {
                        useAbility(char, castingEnemy, interruptAbility, dampening);
                        interruptAbility.currentCooldown = interruptAbility.cooldown;
                        return;
                    }
                }

                // 4. CC CHECK (Cross-CC Healer)
                const ccAbility = abilities.find(a => a.type === 'cc' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                if (ccAbility) {
                    const healerEnemy = aliveEnemies.find(e => e.userData.classData.role === 'healer');
                    if (healerEnemy && healerEnemy.userData.ccUntil <= 0 && checkLineOfSight(char, healerEnemy) && char.userData.target !== healerEnemy) {
                        useAbility(char, healerEnemy, ccAbility, dampening);
                        ccAbility.currentCooldown = ccAbility.cooldown;
                        return;
                    }
                }

                // 5. ROLE-BASED ACTIONS
                if (isHealer) {
                    const lowestAlly = aliveAllies.sort((a, b) => (a.userData.health / a.userData.maxHealth) - (b.userData.health / b.userData.maxHealth))[0];
                    const manaPercent = char.userData.mana / char.userData.maxMana;
                    const isLowMana = manaPercent < 0.3;

                    // Filter abilities to find suitable heals
                    const healAbilities = abilities.filter(a => a.type === 'heal' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                    
                    if (lowestAlly && lowestAlly.userData.health < lowestAlly.userData.maxHealth * 0.95) {
                        let chosenHeal = null;
                        
                        if (isLowMana) {
                            // CONSERVE MANA: Prefer cheaper/efficient heals unless someone is critical
                            const isCritical = (lowestAlly.userData.health / lowestAlly.userData.maxHealth) < 0.35;
                            if (isCritical) {
                                // Panic: Use biggest heal available
                                chosenHeal = healAbilities.sort((a,b) => (b.heal || 0) - (a.heal || 0))[0];
                            } else {
                                // Efficient: Use cheapest heal that still provides value
                                chosenHeal = healAbilities.sort((a,b) => (a.mana || 0) - (b.mana || 0))[0];
                            }
                        } else {
                            // STANDARD: Use best heal for the situation
                            chosenHeal = healAbilities.sort((a,b) => (b.heal || 0) - (a.heal || 0))[0];
                        }

                        if (chosenHeal && checkLineOfSight(char, lowestAlly)) {
                            useAbility(char, lowestAlly, chosenHeal, dampening);
                            chosenHeal.currentCooldown = chosenHeal.cooldown;
                            return;
                        } else if (!chosenHeal && isLowMana) {
                            // OOM State: Healer might want to back off or alert
                            if (Math.random() < 0.1) {
                                showDamageNumber(char.position, "OOM!", false, false, true);
                            }
                        }
                    }
                    
                    // Offensive pressure if everyone is healthy and we have enough mana
                    const target = !isLowMana ? sortedEnemies.find(e => checkLineOfSight(char, e)) : null;
                    if (target) {
                        const selectedDmgAbility = abilities.find(a => a.type === 'damage' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                        if (selectedDmgAbility) {
                            useAbility(char, target, selectedDmgAbility, dampening);
                            selectedDmgAbility.currentCooldown = selectedDmgAbility.cooldown;
                        }
                    }
                } else {
                    // DPS Target selection (must be in LOS)
                    // If primary target is out of LOS, try to find a target that IS in LOS before moving
                    let target = sortedEnemies.find(e => e.userData.ccUntil <= 0 && checkLineOfSight(char, e));
                    
                    // If no valid target in LOS, the movement system will push us to find LOS to the primary target
                    if (target) {
                        const offensiveAbility = abilities.find(a => a.type === 'offensive' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                        if (offensiveAbility && (target.userData.health / target.userData.maxHealth) < 0.5) {
                            useAbility(char, target, offensiveAbility, dampening);
                            offensiveAbility.currentCooldown = offensiveAbility.cooldown;
                        }

                        let selectedDmgAbility = null;
                        if (char.userData.classType === 'rogue') {
                            const cp = char.userData.comboPoints || 0;
                            if (cp >= 4) selectedDmgAbility = abilities.find(a => a.spendsComboPoint && a.type === 'damage' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                            if (!selectedDmgAbility) selectedDmgAbility = abilities.find(a => a.generatesComboPoint && a.type === 'damage' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                        }
                        if (!selectedDmgAbility) selectedDmgAbility = abilities.find(a => a.type === 'damage' && a.currentCooldown <= 0 && canAffordAbility(char, a));
                        
                        if (selectedDmgAbility) {
                            useAbility(char, target, selectedDmgAbility, dampening);
                            selectedDmgAbility.currentCooldown = selectedDmgAbility.cooldown;
                        }
                    }
                }
            });
        }

        function startDot(target, damagePerTick, duration, intervalSeconds, name = 'DoT') {
            const startTime = performance.now();
            const intervalMs = intervalSeconds * 1000;
            const durationMs = duration * 1000;
            
            const dotInterval = setInterval(() => {
                const now = performance.now();
                if (now - startTime > durationMs || !target.userData || target.userData.health <= 0 || !gameState.inMatch) {
                    clearInterval(dotInterval);
                    return;
                }
                
                target.userData.health = Math.max(0, target.userData.health - damagePerTick);
                showDamageNumber(target.position, Math.round(damagePerTick), false, false, false, 0xff0000); // Red for bleed
                
                if (target.userData.health <= 0) {
                    killCharacter(target);
                    clearInterval(dotInterval);
                }
            }, intervalMs);
        }

        // =============================================
        // CENTRALIZED PET DAMAGE PIPELINE v2
        // Handles avoidance, armor/spell resist, absorbs, soul link, tracking
        // =============================================
        function dealDamageToPet(pet, rawDmg, damageType = 'physical', source = null, abilityName = '') {
            const petData = pet.userData;
            if (!petData || petData.health <= 0) return 0;
            
            // Invulnerability check
            if (petData.ccUntil > 0 && petData.ccType === 'invulnerable') {
                showDamageNumber(pet.position, 'IMMUNE', false, false, true);
                return 0;
            }
            
            // === AVOIDANCE ROLL (dodge/parry for physical, spell resist for magic) ===
            if (damageType === 'physical' || damageType === 'melee') {
                // Dodge roll
                if (Math.random() < (petData.dodgeChance || 0)) {
                    petData.totalDamageAvoided = (petData.totalDamageAvoided || 0) + rawDmg;
                    showDamageNumber(pet.position, 'üèÉ DODGE', false, false, true);
                    // Flash the health wrapper
                    const npEl = document.getElementById(`nameplate-${petData.nameplateId}`);
                    if (npEl) {
                        const hw = npEl.querySelector('.pet-health-wrapper');
                        if (hw) { hw.classList.remove('dodge-flash'); void hw.offsetWidth; hw.classList.add('dodge-flash'); }
                    }
                    return 0;
                }
                // Parry roll (only vs melee range attacks)
                if (source && pet.position.distanceTo(source.position) < 4.0 && Math.random() < (petData.parryChance || 0)) {
                    petData.totalDamageAvoided = (petData.totalDamageAvoided || 0) + rawDmg;
                    showDamageNumber(pet.position, '‚öîÔ∏è PARRY', false, false, true);
                    return 0;
                }
            } else if (damageType === 'shadow' || damageType === 'magic' || damageType === 'frost' || damageType === 'fire') {
                // Spell resistance: partial resist (reduces damage, doesn't fully avoid)
                const resistChance = petData.spellResist || 0;
                if (resistChance > 0 && Math.random() < resistChance) {
                    const resistPct = 0.30 + Math.random() * 0.40; // Resist 30-70% of the spell
                    const resistedAmt = rawDmg * resistPct;
                    rawDmg -= resistedAmt;
                    petData.totalDamageAvoided = (petData.totalDamageAvoided || 0) + resistedAmt;
                    showDamageNumber(pet.position, `üõ° RESIST (${Math.round(resistPct * 100)}%)`, false, false, true);
                }
            }
            
            // === ARMOR MITIGATION (physical only, diminishing returns already baked into armor stat) ===
            let mitigatedDmg = rawDmg;
            if ((damageType === 'physical' || damageType === 'melee') && petData.armor > 0) {
                const armorReduction = petData.armor; // Already computed as rating/(rating+K)
                const blocked = mitigatedDmg * armorReduction;
                mitigatedDmg -= blocked;
                petData.totalDamageBlocked = (petData.totalDamageBlocked || 0) + blocked;
            }
            
            // === RESILIENCE ===
            const resMult = Math.max(0.1, 1 - (petData.resilience || 0));
            mitigatedDmg *= resMult;
            
            // === ABSORB SHIELDS ===
            let absorbedAmt = 0;
            if (petData.absorb > 0) {
                absorbedAmt = Math.min(petData.absorb, mitigatedDmg);
                petData.absorb -= absorbedAmt;
                mitigatedDmg -= absorbedAmt;
                if (absorbedAmt > 0) {
                    showDamageNumber(pet.position, `üõ° ${Math.round(absorbedAmt)}`, false, false, true);
                }
            }
            
            // === APPLY FINAL DAMAGE ===
            petData.health = Math.max(0, petData.health - mitigatedDmg);
            petData.totalDamageTaken = (petData.totalDamageTaken || 0) + mitigatedDmg;
            petData.lastDamageTakenTime = performance.now();
            
            // Track highest single hit
            if (mitigatedDmg > (petData.highestHit || 0)) petData.highestHit = mitigatedDmg;
            
            if (petData.health <= 0) {
                killCharacter(pet);
            }
            
            return mitigatedDmg;
        }
        
        // =============================================
        // SOUL LINK DAMAGE REDIRECT
        // Called from executeAbilityEffect when warlock takes damage
        // =============================================
        function processSoulLinkRedirect(owner, rawDamage) {
            if (!owner || !owner.userData) return rawDamage;
            
            // Find the felhunter linked to this owner
            const allUnits = owner.userData.isEnemy ? gameState.enemies : gameState.team;
            const felhunter = allUnits.find(u => 
                u.userData?.isPet && 
                u.userData.petType === 'warlock_pet' && 
                u.userData.ownerRef === owner && 
                u.userData.health > 0 &&
                u.userData.soulLinkActive
            );
            
            if (!felhunter) return rawDamage;
            
            const shareRatio = felhunter.userData.abilities?.soulLink?.damageShared || 0.20;
            const redirectAmt = rawDamage * shareRatio;
            const ownerTakes = rawDamage - redirectAmt;
            
            // Pet takes the redirected portion (bypasses avoidance, but uses resilience)
            const petResMult = Math.max(0.1, 1 - (felhunter.userData.resilience || 0));
            const petTakes = redirectAmt * petResMult;
            felhunter.userData.health = Math.max(0, felhunter.userData.health - petTakes);
            felhunter.userData.totalDamageRedirected = (felhunter.userData.totalDamageRedirected || 0) + petTakes;
            felhunter.userData.totalDamageTaken = (felhunter.userData.totalDamageTaken || 0) + petTakes;
            felhunter.userData.lastDamageTakenTime = performance.now();
            
            if (felhunter.userData.health <= 0) {
                killCharacter(felhunter);
            }
            
            return ownerTakes;
        }

        function updatePetAI(deltaTime) {
            const allPets = [...gameState.team, ...gameState.enemies].filter(entity => entity.userData.isPet && entity.userData.health > 0);
            
            allPets.forEach(pet => {
                const petData = pet.userData;
                const owner = petData.ownerRef;
                const abilities = petData.abilities || {};
                
                // 0. TICK PET ABILITY COOLDOWNS
                Object.values(abilities).forEach(ab => {
                    if (ab.cooldown > 0) ab.cooldown = Math.max(0, ab.cooldown - deltaTime);
                });
                
                // Tick focus/energy regeneration
                if (petData.maxFocus > 0 && petData.focus < petData.maxFocus) {
                    petData.focus = Math.min(petData.maxFocus, petData.focus + (petData.focusRegen || 4) * deltaTime);
                }
                
                // Tick frenzy stacks (hunter pet)
                if (petData.frenzyUntil > 0) {
                    petData.frenzyUntil -= deltaTime;
                    if (petData.frenzyUntil <= 0) {
                        petData.frenzyStacks = 0;
                        petData.frenzyUntil = 0;
                    }
                }
                
                // Tick pet CC
                if (petData.ccUntil > 0) {
                    petData.ccUntil -= deltaTime;
                    if (petData.ccUntil <= 0) {
                        petData.ccUntil = 0;
                        petData.ccType = null;
                    }
                }
                
                // Tick pet dash buff
                if (petData.dashUntil > 0) petData.dashUntil -= deltaTime;
                
                // 1. PET CLEANUP: Kill pets with dead owners or if match ended
                if (!owner || owner.userData.health <= 0 || !gameState.inMatch) {
                    killCharacter(pet);
                    return;
                }
                
                // SOUL LINK ACTIVATION (Warlock Felhunter)
                if (petData.petType === 'warlock_pet' && abilities.soulLink && abilities.soulLink.passive) {
                    if (!petData.soulLinkActive) {
                        petData.soulLinkActive = true;
                        owner._soulLinked = true;
                        applyAura(owner, 'Soul Link', 999, 'buff');
                    }
                }
                
                // OUT-OF-COMBAT REGENERATION (if no damage for 5s)
                const now = performance.now();
                const timeSinceLastDmg = (now - (petData.lastDamageTakenTime || 0)) / 1000;
                if (timeSinceLastDmg > 5 && petData.health < petData.maxHealth && petData.health > 0) {
                    const oocHeal = petData.maxHealth * (petData.oocRegenRate || 0.02) * deltaTime;
                    petData.health = Math.min(petData.maxHealth, petData.health + oocHeal);
                }
                
                // 2. BOUNDARY ENFORCEMENT
                const distFromCenterSq = pet.position.x ** 2 + pet.position.z ** 2;
                if (distFromCenterSq > 18 * 18) {
                    const dist = Math.sqrt(distFromCenterSq);
                    const pullBack = new THREE.Vector3(-pet.position.x, 0, -pet.position.z).normalize();
                    if (dist > 22) {
                        const petGroundY = getGroundHeight(pet.position.x, pet.position.z, pet.position.y);
                        pet.position.set(pullBack.x * -16, petGroundY, pullBack.z * -16);
                        petData.velocity.set(0, 0, 0);
                    } else {
                        pet.position.add(pullBack.multiplyScalar((dist - 18) * 0.8));
                    }
                }

                // 3. IMPROVED GROUNDING
                const petGroundY = getGroundHeight(pet.position.x, pet.position.z, pet.position.y);
                if (pet.position.y < petGroundY + 0.2) {
                    pet.position.y = petGroundY;
                    petData.velocity.y = 0;
                } else {
                    petData.velocity.y -= 15.0 * deltaTime;
                    pet.position.y += petData.velocity.y * deltaTime;
                }
                
                // CC CHECK: If pet is CC'd (stunned/feared/rooted), skip movement & attacks
                if (petData.ccUntil > 0 && petData.ccType !== 'root') {
                    petData.velocity.multiplyScalar(0.9);
                    petData.animState = 'idle';
                    return;
                }
                
                const enemyTeam = petData.isEnemy ? gameState.team : gameState.enemies;
                const allyTeam = petData.isEnemy ? gameState.enemies : gameState.team;
                const petEnemies = enemyTeam.filter(e => e.userData.health > 0);
                const currentTime = performance.now();
                
                // Helper: check if pet can afford focus cost
                const canAffordFocus = (ab) => !ab.focusCost || petData.focus >= ab.focusCost;
                const spendFocus = (ab) => { if (ab.focusCost) petData.focus = Math.max(0, petData.focus - ab.focusCost); };
                
                // =============================================
                // HUNTER PET: Mend Pet (self-heal when low, respects healing reduction)
                // =============================================
                if (petData.petType === 'hunter_pet' && abilities.mend) {
                    const myHpPct = petData.health / petData.maxHealth;
                    if (myHpPct < 0.5 && abilities.mend.cooldown <= 0) {
                        let healAmount = petData.maxHealth * abilities.mend.healPercent;
                        
                        if (petData.healingReduction > 0) {
                            healAmount *= (1 - petData.healingReduction);
                        }
                        
                        const actualHeal = Math.min(petData.maxHealth - petData.health, healAmount);
                        petData.health += actualHeal;
                        abilities.mend.cooldown = abilities.mend.maxCooldown;
                        showDamageNumber(pet.position, Math.round(actualHeal), true);
                        applyAura(pet, 'Mend Pet', 3, 'buff');
                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName}: Mend Pet ‚Üí +${Math.round(actualHeal)} HP${petData.healingReduction > 0 ? ' (reduced)' : ''}`, 'heal');
                        createAbilityEffect(pet.position, 0x44ff44);
                        createExplosion(pet.position, 0x44ff44, 6);
                    }
                }
                
                // =============================================
                // HUNTER PET: Roar of Sacrifice (protect low-HP owner)
                // =============================================
                if (petData.petType === 'hunter_pet' && abilities.roarOfSacrifice) {
                    const ownerHpPct = owner.userData.health / owner.userData.maxHealth;
                    const petHpPct = petData.health / petData.maxHealth;
                    if (ownerHpPct < 0.35 && petHpPct > 0.30 && abilities.roarOfSacrifice.cooldown <= 0) {
                        const dmgRed = abilities.roarOfSacrifice.damageReduction;
                        const dur = abilities.roarOfSacrifice.duration;
                        owner.userData.resilience += dmgRed;
                        setTimeout(() => { if (owner.userData) owner.userData.resilience -= dmgRed; }, dur * 1000);
                        abilities.roarOfSacrifice.cooldown = abilities.roarOfSacrifice.maxCooldown;
                        applyAura(owner, 'Roar of Sacrifice', dur, 'buff');
                        showDamageNumber(pet.position, 'üõ°Ô∏è ROAR!', false, false, true);
                        showDamageNumber(owner.position, `+${Math.round(dmgRed * 100)}% DR`, false, false, true);
                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName}: Roar of Sacrifice ‚Üí ${owner.userData.classData.name} (-${Math.round(dmgRed * 100)}% dmg, ${dur}s)`, 'buff');
                        createExplosion(pet.position, 0xabd473, 12);
                        soundManager.playMelee();
                    }
                }
                
                // =============================================
                // WARLOCK PET (FELHUNTER): Spell Lock (interrupt)
                // =============================================
                if (petData.petType === 'warlock_pet' && abilities.spellLock) {
                    if (abilities.spellLock.cooldown <= 0 && canAffordFocus(abilities.spellLock)) {
                        const castingEnemies = petEnemies.filter(e => 
                            e.userData.castingAbility && 
                            e.userData.castingAbility.castTime > 0.5 &&
                            pet.position.distanceTo(e.position) < 20.0
                        );
                        
                        let castingEnemy = null;
                        if (castingEnemies.length > 0) {
                            const healerCasting = castingEnemies.find(e => e.userData.classData?.role === 'healer');
                            if (healerCasting) {
                                castingEnemy = healerCasting;
                            } else {
                                castingEnemy = castingEnemies.sort((a, b) => 
                                    (b.userData.castProgress / b.userData.castingAbility.castTime) - 
                                    (a.userData.castProgress / a.userData.castingAbility.castTime)
                                )[0];
                            }
                        }
                        
                        if (castingEnemy) {
                            spendFocus(abilities.spellLock);
                            abilities.spellLock.cooldown = abilities.spellLock.maxCooldown;
                            const duration = abilities.spellLock.duration;
                            castingEnemy.userData.schoolLockedUntil = duration;
                            const castAbilityName = castingEnemy.userData.castingAbility.name;
                            
                            castingEnemy.userData.castingAbility = null;
                            castingEnemy.userData.castingTarget = null;
                            castingEnemy.userData.castProgress = 0;
                            
                            applyAura(castingEnemy, 'Spell Lock', duration, 'debuff');
                            showDamageNumber(castingEnemy.position, 'üîí SPELL LOCK!', false, false, true);
                            addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} Felhunter: Spell Lock ‚Üí ${castingEnemy.userData.classData?.name || 'target'}'s ${castAbilityName} (${duration}s lockout)`, 'cc');
                            soundManager.playMagic('C2');
                            
                            createFelLockLine(pet.position, castingEnemy.position);
                            createAbilityEffect(castingEnemy.position, 0x32ff00);
                        }
                    }
                }
                
                // =============================================
                // WARLOCK PET (FELHUNTER): Devour Magic (dispel + heal)
                // =============================================
                if (petData.petType === 'warlock_pet' && abilities.devourMagic) {
                    if (abilities.devourMagic.cooldown <= 0 && canAffordFocus(abilities.devourMagic)) {
                        const ownerDebuffs = (owner.userData.auras || []).filter(a => a.type === 'debuff');
                        if (ownerDebuffs.length > 0) {
                            const ccDebuff = ownerDebuffs.find(a => a.name.includes('Lock') || a.name.includes('Silence'));
                            const healRedDebuff = ownerDebuffs.find(a => a.name.includes('Mortal') || a.name.includes('Healing Reduction'));
                            const removed = ccDebuff || healRedDebuff || ownerDebuffs[0];
                            
                            owner.userData.auras = owner.userData.auras.filter(a => a !== removed);
                            spendFocus(abilities.devourMagic);
                            abilities.devourMagic.cooldown = abilities.devourMagic.maxCooldown;
                            
                            let healAmt = petData.maxHealth * abilities.devourMagic.healPercent;
                            if (petData.healingReduction > 0) healAmt *= (1 - petData.healingReduction);
                            const actualHeal = Math.min(petData.maxHealth - petData.health, healAmt);
                            petData.health += actualHeal;
                            
                            // Devour also restores some focus
                            petData.focus = Math.min(petData.maxFocus, petData.focus + 15);
                            
                            showDamageNumber(pet.position, '‚ú® DEVOUR!', false, false, true);
                            if (actualHeal > 0) showDamageNumber(pet.position, Math.round(actualHeal), true);
                            addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} Felhunter: Devour Magic removes ${removed.name}${actualHeal > 0 ? ` (+${Math.round(actualHeal)} HP)` : ''}`, 'buff');
                            createAbilityEffect(owner.position, 0x32ff00);
                            createExplosion(pet.position, 0x32ff00, 5);
                        }
                    }
                }
                
                const distToOwner = pet.position.distanceTo(owner.position);
                const isRooted = petData.ccUntil > 0 && petData.ccType === 'root';
                
                // Leash logic
                if (!isRooted && (distToOwner > 20.0 || petEnemies.length === 0)) {
                    petData.target = owner;
                    const dir = new THREE.Vector3().subVectors(owner.position, pet.position);
                    dir.y = 0;
                    if (dir.length() > 2.0) {
                        dir.normalize();
                        const speed = petData.dashUntil > 0 ? petData.moveSpeed * 2.0 : petData.moveSpeed * 1.5;
                        petData.velocity.copy(dir).multiplyScalar(speed);
                        pet.position.add(petData.velocity.clone().multiplyScalar(deltaTime));
                        
                        const targetRotation = Math.atan2(dir.x, dir.z);
                        let diff = targetRotation - pet.rotation.y;
                        diff = ((diff % (Math.PI * 2)) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
                        pet.rotation.y += diff * 0.15;
                        
                        petData.animState = 'running';
                        petData.walkCyclePhase = (petData.walkCyclePhase || 0) + deltaTime * 12;
                    } else {
                        petData.velocity.set(0, 0, 0);
                        petData.animState = 'idle';
                    }
                    return;
                }

                // =============================================
                // TARGET SELECTION (smarter priority system)
                // =============================================
                let targetEnemy = null;
                
                if (owner.userData.target && owner.userData.target.userData.health > 0) {
                    targetEnemy = owner.userData.target;
                }
                
                if (!targetEnemy) {
                    const attackersOfOwner = petEnemies.filter(e => e.userData.target === owner && !e.userData.isPet);
                    if (attackersOfOwner.length > 0) {
                        targetEnemy = attackersOfOwner.sort((a, b) => 
                            pet.position.distanceTo(a.position) - pet.position.distanceTo(b.position)
                        )[0];
                    }
                }
                
                if (!targetEnemy) {
                    const lowEnemies = petEnemies.filter(e => !e.userData.isPet && (e.userData.health / e.userData.maxHealth) < 0.3);
                    if (lowEnemies.length > 0) {
                        targetEnemy = lowEnemies[0];
                    }
                }
                
                if (!targetEnemy && petEnemies.length > 0) {
                    targetEnemy = petEnemies.sort((a, b) => pet.position.distanceTo(a.position) - pet.position.distanceTo(b.position))[0];
                }
                
                if (targetEnemy) {
                    const distToTarget = pet.position.distanceTo(targetEnemy.position);
                    
                    // DASH (hunter)
                    if (petData.petType === 'hunter_pet' && abilities.dash && distToTarget > 8.0 && abilities.dash.cooldown <= 0) {
                        abilities.dash.cooldown = abilities.dash.maxCooldown;
                        petData.dashUntil = abilities.dash.duration;
                        applyAura(pet, 'Dash', abilities.dash.duration, 'buff');
                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName} dashes!`, 'buff');
                    }
                    
                    // MOVEMENT (unless rooted)
                    if (!isRooted && distToTarget > 2.0) {
                        const dir = new THREE.Vector3().subVectors(targetEnemy.position, pet.position);
                        dir.y = 0;
                        if (dir.lengthSq() > 0.001) dir.normalize();
                        const speed = petData.dashUntil > 0 ? petData.moveSpeed * 2.0 : petData.moveSpeed;
                        petData.velocity.copy(dir).multiplyScalar(speed);
                        pet.position.add(petData.velocity.clone().multiplyScalar(deltaTime));
                        
                        const targetRotation = Math.atan2(dir.x, dir.z);
                        let diff = targetRotation - pet.rotation.y;
                        diff = ((diff % (Math.PI * 2)) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
                        pet.rotation.y += diff * 0.15;
                        
                        petData.animState = 'running';
                        petData.walkCyclePhase = (petData.walkCyclePhase || 0) + deltaTime * 12;

                        if (distToTarget > 5.0 && petData.dashUntil <= 0) {
                            petData.velocity.multiplyScalar(1.8); 
                        }
                    } else if (distToTarget <= 2.0) {
                        petData.velocity.set(0, 0, 0);
                        petData.animState = 'attacking';
                        pet.lookAt(targetEnemy.position.x, pet.position.y, targetEnemy.position.z);
                        
                        // =============================================
                        // PET ATTACK SYSTEM v2 (focus-gated, avoidance-aware)
                        // =============================================
                        // Frenzy: attack speed scales with stacks
                        const frenzyHaste = 1 + (petData.frenzyStacks || 0) * 0.06; // 6% per stack
                        const effectiveAttackCd = petData.attackCooldown / frenzyHaste;
                        
                        if (currentTime - petData.lastAttackTime >= effectiveAttackCd * 1000) {
                            petData.lastAttackTime = currentTime;
                            gameState.matchStats.lastCombatActionTime = gameState.matchTime;
                            
                            // =============================================
                            // REALISTIC PET DAMAGE PIPELINE v2
                            // =============================================
                            
                            // 1. Target mitigation
                            const targetRes = targetEnemy.userData.resilience || 0;
                            const targetArmor = targetEnemy.userData.armor || 0;
                            const targetSpellResist = targetEnemy.userData.spellResist || 0;
                            const defenseTalent = targetEnemy.userData.isEnemy ? 0 : getTalentBonus('tal_defense');
                            const resMult = Math.max(0.1, 1 - targetRes - defenseTalent);
                            
                            // 2. Pet offensive modifiers
                            const petCritChance = petData.critChance || 0.15;
                            const petCritMult = petData.critMult || 1.8;
                            const isCrit = Math.random() < petCritChance;
                            const critDmgMult = isCrit ? petCritMult : 1.0;
                            
                            // 3. Damage variance (¬±10% natural swing)
                            const variance = 0.90 + Math.random() * 0.20;
                            
                            // 4. Owner buff passthrough
                            const ownerBuff = (owner.userData.buffUntil > 0 && owner.userData.buffType === 'damageBuff') ? 1.25 : 1.0;
                            
                            // CENTRALIZED pet outgoing damage applicator
                            const applyPetDamage = (target, rawDmg, abilityName, dmgType = 'physical') => {
                                // Determine armor vs spell resist based on damage type
                                let mitigationMult = 1.0;
                                if (dmgType === 'physical' || dmgType === 'melee') {
                                    mitigationMult = Math.max(0.85, 1 - targetArmor);
                                } else {
                                    // Magic damage uses spell resist
                                    mitigationMult = Math.max(0.85, 1 - targetSpellResist);
                                }
                                
                                let dmg = rawDmg * variance * critDmgMult * resMult * mitigationMult * ownerBuff;
                                
                                // Invulnerability check
                                if (target.userData.ccUntil > 0 && target.userData.ccType === 'invulnerable') {
                                    showDamageNumber(target.position, 'IMMUNE', false, false, true);
                                    return 0;
                                }
                                
                                // Target avoidance (dodge/parry) ‚Äî only for physical
                                if ((dmgType === 'physical' || dmgType === 'melee') && target.userData.dodgeChance) {
                                    if (Math.random() < target.userData.dodgeChance) {
                                        showDamageNumber(target.position, 'DODGE', false, false, true);
                                        return 0;
                                    }
                                }
                                
                                // Absorb shields
                                let absorbedAmt = 0;
                                if (target.userData.absorb > 0) {
                                    absorbedAmt = Math.min(target.userData.absorb, dmg);
                                    target.userData.absorb -= absorbedAmt;
                                    dmg -= absorbedAmt;
                                    if (absorbedAmt > 0) {
                                        showDamageNumber(target.position, `üõ° ${Math.round(absorbedAmt)}`, false, false, true);
                                    }
                                }
                                
                                // Apply final damage
                                target.userData.health = Math.max(0, target.userData.health - dmg);
                                
                                // Track combat stats
                                petData.totalDamageDealt = (petData.totalDamageDealt || 0) + dmg + absorbedAmt;
                                if (dmg > (petData.highestHit || 0)) petData.highestHit = dmg;
                                if (!petData.isEnemy) {
                                    gameState.matchStats.damageDealt += dmg;
                                }
                                
                                if (target.userData.totalDamageTaken !== undefined) {
                                    target.userData.totalDamageTaken += dmg;
                                }
                                
                                if (target.userData.health <= 0) {
                                    petData.killCount = (petData.killCount || 0) + 1;
                                    killCharacter(target);
                                }
                                return dmg;
                            };
                            
                            // =============================================
                            // HUNTER PET COMBAT (physical damage, focus-gated)
                            // =============================================
                            if (petData.petType === 'hunter_pet') {
                                
                                // KILL COMMAND ‚Äî big burst (priority)
                                if (abilities.bite && abilities.bite.cooldown <= 0 && canAffordFocus(abilities.bite)) {
                                    spendFocus(abilities.bite);
                                    const dmg = abilities.bite.damage;
                                    const actual = applyPetDamage(targetEnemy, dmg, 'Kill Command', 'physical');
                                    abilities.bite.cooldown = abilities.bite.maxCooldown;
                                    
                                    if (actual > 0) {
                                        showDamageNumber(targetEnemy.position, Math.round(actual), false, isCrit);
                                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName}: Kill Command ‚Üí ${targetEnemy.userData.isPet ? (targetEnemy.userData.petName || 'Pet') : (targetEnemy.userData.classData?.name || 'target')} for ${Math.round(actual)}${isCrit ? ' (CRIT)' : ''}`, 'damage');
                                        createAbilityEffect(targetEnemy.position, isCrit ? 0xffff00 : 0xabd473);
                                        createExplosion(targetEnemy.position, 0xabd473, 8);
                                        soundManager.playMelee();
                                    }
                                }
                                // CLAW ‚Äî medium damage, shorter cooldown, chance to proc Savage Rend bleed + Frenzy
                                else if (abilities.claw && abilities.claw.cooldown <= 0 && canAffordFocus(abilities.claw)) {
                                    spendFocus(abilities.claw);
                                    const dmg = abilities.claw.damage;
                                    const actual = applyPetDamage(targetEnemy, dmg, 'Claw', 'physical');
                                    abilities.claw.cooldown = abilities.claw.maxCooldown;
                                    
                                    if (actual > 0) {
                                        showDamageNumber(targetEnemy.position, Math.round(actual), false, isCrit);
                                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName}: Claw ‚Üí ${targetEnemy.userData.isPet ? (targetEnemy.userData.petName || 'Pet') : (targetEnemy.userData.classData?.name || 'target')} for ${Math.round(actual)}${isCrit ? ' (CRIT)' : ''}`, 'damage');
                                        createAbilityEffect(targetEnemy.position, 0xabd473);
                                        soundManager.playMelee();
                                        
                                        // Savage Rend proc (25% chance on Claw) ‚Äî applies a 6s bleed DoT
                                        if (Math.random() < 0.25) {
                                            const bleedTotal = petData.baseDamage * 0.8;
                                            const bleedTicks = 3; // 3 ticks over 6s
                                            const bleedPerTick = bleedTotal / bleedTicks;
                                            applyAura(targetEnemy, 'Savage Rend', 6, 'debuff');
                                            showDamageNumber(targetEnemy.position, 'ü©∏ REND!', false, false, true);
                                            addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} ${petData.petName}: Savage Rend procs! (${Math.round(bleedTotal)} bleed over 6s)`, 'damage');
                                            
                                            let tickCount = 0;
                                            const bleedTimer = setInterval(() => {
                                                tickCount++;
                                                if (tickCount > bleedTicks || !gameState.inMatch || targetEnemy.userData.health <= 0) {
                                                    clearInterval(bleedTimer);
                                                    return;
                                                }
                                                const bleedDmg = bleedPerTick * resMult;
                                                targetEnemy.userData.health = Math.max(0, targetEnemy.userData.health - bleedDmg);
                                                petData.totalDamageDealt = (petData.totalDamageDealt || 0) + bleedDmg;
                                                if (!petData.isEnemy) gameState.matchStats.damageDealt += bleedDmg;
                                                showDamageNumber(targetEnemy.position, `ü©∏${Math.round(bleedDmg)}`, false, false);
                                                if (targetEnemy.userData.health <= 0) {
                                                    petData.killCount = (petData.killCount || 0) + 1;
                                                    killCharacter(targetEnemy);
                                                    clearInterval(bleedTimer);
                                                }
                                            }, 2000);
                                            setTimeout(() => clearInterval(bleedTimer), 6500);
                                        }
                                        
                                        // Frenzy proc (30% chance on Claw hit) ‚Äî stacking attack speed buff
                                        if (Math.random() < 0.30) {
                                            petData.frenzyStacks = Math.min(5, (petData.frenzyStacks || 0) + 1);
                                            petData.frenzyUntil = 10; // 10 second duration, refreshes on proc
                                            applyAura(pet, `Frenzy x${petData.frenzyStacks}`, 10, 'buff');
                                            if (petData.frenzyStacks >= 3) {
                                                showDamageNumber(pet.position, `üî• FRENZY x${petData.frenzyStacks}`, false, false, true);
                                            }
                                        }
                                    }
                                }
                                // AUTO-ATTACK ‚Äî basic melee swing when abilities on CD or OOM
                                else {
                                    const autoDmg = petData.baseDamage * 0.6;
                                    const actual = applyPetDamage(targetEnemy, autoDmg, 'Melee', 'physical');
                                    if (actual > 0) {
                                        showDamageNumber(targetEnemy.position, Math.round(actual), false, isCrit);
                                        soundManager.playMelee();
                                    }
                                }
                            }
                            // =============================================
                            // WARLOCK PET (FELHUNTER) COMBAT (shadow damage, debuff-scaling)
                            // =============================================
                            else if (petData.petType === 'warlock_pet') {
                                
                                // SHADOW BITE ‚Äî magic damage, bonus per active debuff on target
                                if (abilities.shadowBite && abilities.shadowBite.cooldown <= 0 && canAffordFocus(abilities.shadowBite)) {
                                    spendFocus(abilities.shadowBite);
                                    let dmg = abilities.shadowBite.damage;
                                    
                                    // Debuff scaling: +8% damage per debuff on target (up to 5 debuffs = +40%)
                                    const targetDebuffs = (targetEnemy.userData.auras || []).filter(a => a.type === 'debuff').length;
                                    const debuffBonus = 1 + Math.min(5, targetDebuffs) * 0.08;
                                    dmg *= debuffBonus;
                                    
                                    const actual = applyPetDamage(targetEnemy, dmg, 'Shadow Bite', 'shadow');
                                    abilities.shadowBite.cooldown = abilities.shadowBite.maxCooldown;
                                    
                                    if (actual > 0) {
                                        showDamageNumber(targetEnemy.position, Math.round(actual), false, isCrit);
                                        const debuffText = targetDebuffs > 0 ? ` (${targetDebuffs} debuff${targetDebuffs > 1 ? 's' : ''}: +${Math.round((debuffBonus - 1) * 100)}%)` : '';
                                        addCombatLog(`${petData.isEnemy ? 'Enemy' : 'Ally'} Felhunter: Shadow Bite ‚Üí ${targetEnemy.userData.isPet ? (targetEnemy.userData.petName || 'Pet') : (targetEnemy.userData.classData?.name || 'target')} for ${Math.round(actual)}${isCrit ? ' (CRIT)' : ''}${debuffText}`, 'damage');
                                        createAbilityEffect(targetEnemy.position, isCrit ? 0xdd88ff : 0x8787ed);
                                        soundManager.playMagic('A3');
                                    }
                                }
                                // AUTO-ATTACK ‚Äî basic shadow melee when Shadow Bite on CD or OOM
                                else {
                                    const autoDmg = petData.baseDamage * 0.5;
                                    const actual = applyPetDamage(targetEnemy, autoDmg, 'Melee', 'shadow');
                                    if (actual > 0) {
                                        showDamageNumber(targetEnemy.position, Math.round(actual), false, isCrit);
                                        soundManager.playMelee();
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function canAffordAbility(char, ability) {
            const efficiencyBonus = char.userData.isEnemy ? 0 : getTalentBonus('tal_efficiency');
            const manaCost = (ability.mana || 0) * (1 - efficiencyBonus);
            
            if (manaCost > 0 && char.userData.mana < manaCost) return false;
            if (ability.energyCost && char.userData.mana < ability.energyCost) return false;
            if (ability.rageCost && char.userData.mana < ability.rageCost) return false;
            if (ability.spendsComboPoint && (char.userData.comboPoints || 0) === 0) return false;
            return true;
        }

        function useAbility(caster, target, ability, dampening = 0) {
            // Check Global Cooldown
            if (caster.userData.gcdUntil > 0) return;

            // Resource check before starting
            if (!canAffordAbility(caster, ability)) return;

            // Check if caster is already casting
            if (caster.userData.castingAbility) return;

            // Check if caster is CC'd or School Locked (root allows ability usage)
            if (caster.userData.ccUntil > 0 && caster.userData.ccType !== 'root' && ability.type !== 'defensive') return;
            if (ability.castTime && caster.userData.schoolLockedUntil > 0) {
                showDamageNumber(caster.position, 'LOCKED!', false, false, true);
                return;
            }

            // Interrupt logic
            if (ability.type === 'interrupt') {
                if (target.userData.castingAbility) {
                    // Success!
                    const duration = ability.duration || 4;
                    target.userData.schoolLockedUntil = duration;
                    const castAbilityName = target.userData.castingAbility.name;
                    
                    // Stop target's cast
                    target.userData.castingAbility = null;
                    target.userData.castingTarget = null;
                    target.userData.castProgress = 0;
                    
                    applyAura(target, 'School Lock', duration, 'debuff');
                    showDamageNumber(target.position, 'INTERRUPTED!', false, false, true);
                    addCombatLog(`${caster.userData.classData.name} interrupts ${target.userData.classData.name}'s ${castAbilityName}!`, 'cc');
                    soundManager.playMagic('C2'); // Low thud for interrupt
                }
                
                // Interrupts are usually off-GCD in WoW, but for spam prevention let's add a tiny GCD or just return
                // For now, let's keep them off-GCD but add a tiny 0.1s lockout to prevent double-press glitches
                caster.userData.gcdUntil = 0.1; 
                return;
            }

            // Record casting/use for mana regen rules
            if (ability.mana > 0) {
                caster.userData.lastSpellCastTime = gameState.matchTime;
            }

            // Set Global Cooldown (standard 1.5s, usually defensives are off-GCD but let's apply to all for spam prevention)
            // We can scale this with Haste upgrade if we want
            const gearStats = caster.userData.isEnemy ? { haste: 0 } : calculateTotalGearStats();
            const hasteVal = (gameState.upgrades.matchSpeed * 0.08) + (gearStats.haste || 0) * 0.01;
            caster.userData.gcdUntil = Math.max(1.0, 1.5 / (1 + hasteVal));

            // If it has a cast time, start casting instead of instant use
            if (ability.castTime && !caster.userData.castingAbility) {
                caster.userData.castingAbility = ability;
                caster.userData.castingTarget = target;
                caster.userData.castProgress = 0;
                return;
            }

            // Proceed with instant use or cast completion logic
            executeAbilityEffect(caster, target, ability, dampening);
        }

        function finishCast(char) {
            if (!char.userData.castingAbility || !char.userData.castingTarget) return;
            
            const ability = char.userData.castingAbility;
            const target = char.userData.castingTarget;
            
            // Clean up casting state
            char.userData.castingAbility = null;
            char.userData.castingTarget = null;
            char.userData.castProgress = 0;
            
            // Perform the ability
            executeAbilityEffect(char, target, ability, 0); // Dampening handled inside execute
        }

        function useTrinket(char) {
            if (!char.userData || char.userData.trinketCooldown > 0) return;
            
            const wasCCed = char.userData.ccUntil > 0;
            if (!wasCCed) return;
            
            // Reset CC state
            char.userData.ccUntil = 0;
            char.userData.ccType = null;
            char.userData.trinketCooldown = 90; // 90 second cooldown
            
            // Brief immunity to prevent instant re-CC (common in Arena games for feel)
            char.userData.trinketImmunityUntil = gameState.matchTime + 1.5;
            
            // Clean up auras that are debuffs (CC is usually a debuff)
            if (char.userData.auras) {
                // Remove most debuffs
                char.userData.auras = char.userData.auras.filter(a => a.type !== 'debuff');
            }
            
            // Visual feedback
            createAbilityEffect(char.position, 0xffffff); // Bright white burst
            showDamageNumber(char.position, 'üõ°Ô∏è TRINKET!', false, false, true);
            addCombatLog(`${char.userData.classData.name} used PvP Trinket!`, 'buff');
            
            // Sound
            soundManager.playMagic('C5');
        }

        function executeAbilityEffect(caster, target, ability, dampening = 0) {
            // Stalemate Prevention: Reset combat timer on any active ability use
            gameState.matchStats.lastCombatActionTime = gameState.matchTime;

            // Re-check CC/Target validity (root allows ability usage)
            if (caster.userData.ccUntil > 0 && caster.userData.ccType !== 'root' && ability.type !== 'defensive') return;
            if (target.userData.health <= 0) return;

            // Resource checks
            if (!canAffordAbility(caster, ability)) return;

            // Capture current combo points for effect calculation
            const currentCP = caster.userData.comboPoints || 0;

            // Consume resources
            if (ability.mana) {
                const efficiencyBonus = caster.userData.isEnemy ? 0 : getTalentBonus('tal_efficiency');
                caster.userData.mana -= ability.mana * (1 - efficiencyBonus);
            }
            if (ability.energyCost) caster.userData.mana -= ability.energyCost;
            if (ability.rageCost) caster.userData.mana -= ability.rageCost;
            if (ability.rageGen) caster.userData.mana = Math.min(caster.userData.maxMana, caster.userData.mana + ability.rageGen);

            // Handle Rogue Combo Points
            if (ability.generatesComboPoint) {
                caster.userData.comboPoints = Math.min(5, (caster.userData.comboPoints || 0) + ability.generatesComboPoint);
            }
            if (ability.spendsComboPoint) {
                caster.userData.comboPoints = 0;
            }

            // Play sound
            soundManager.playAbility(ability);

            if (ability.type === 'heal') {
                // HEALING with dampening
                // Calculate gear stats for player team only
                const gearStats = caster.userData.isEnemy ? { healingPower: 0 } : calculateTotalGearStats();
                
                // Conquest mastery bonus (only for player team)
                const masteryBonus = caster.userData.isEnemy ? 1 : (1 + (gameState.conquestUpgrades.conquest_mastery || 0) * 0.05);
                
                // Prestige Power Scaling
                const powerScale = caster.userData.powerScale || 1;
                
                let healAmount = (ability.heal || 0) * (1 + gameState.upgrades.healingPower * 0.12) * (1 + gearStats.healingPower * 0.02) * masteryBonus * powerScale;
                healAmount *= (1 - dampening); // Dampening reduces healing
                
                // Mortal Strike healing reduction
                if (target.userData.healingReduction > 0) {
                    healAmount *= (1 - target.userData.healingReduction);
                }

                // Power Word: Shield
                if (ability.absorb) {
                    target.userData.absorb = (target.userData.absorb || 0) + ability.absorb;
                    applyAura(target, 'Power Word: Shield', ability.duration || 15, 'buff');
                    setTimeout(() => {
                        if (target.userData) {
                            target.userData.absorb = Math.max(0, (target.userData.absorb || 0) - ability.absorb);
                        }
                    }, (ability.duration || 15) * 1000);
                }

                // HoT (Heal over Time)
                if (ability.hot) {
                    const hotDuration = ability.duration || 15;
                    const hotInterval = 2; // Every 2 seconds
                    const ticks = hotDuration / hotInterval;
                    const healPerTick = ability.hot / ticks;
                    
                    applyAura(target, ability.name, hotDuration, 'buff');
                    
                    const hotTimer = setInterval(() => {
                        if (!gameState.inMatch || target.userData.health <= 0) {
                            clearInterval(hotTimer);
                            return;
                        }
                        
                        const actualHeal = Math.min(target.userData.maxHealth - target.userData.health, healPerTick);
                        target.userData.health += actualHeal;
                        showDamageNumber(target.position, Math.round(actualHeal), true);
                    }, hotInterval * 1000);
                    
                    setTimeout(() => clearInterval(hotTimer), hotDuration * 1000 + 100);
                }

                const actualHeal = Math.min(target.userData.maxHealth - target.userData.health, healAmount);
                target.userData.health += actualHeal;
                showDamageNumber(target.position, Math.round(actualHeal), true);
                
                // Track stats (player only)
                if (!caster.userData.isEnemy) {
                    gameState.matchStats.healingDone += actualHeal;
                    gameState.matchStats.manaUsed += (ability.mana || 0);
                }
                
                // Combat log
                addCombatLog(`${caster.userData.classData.name} heals ${target.userData.classData.name} for ${Math.round(actualHeal)}`, 'heal');
                
                // Healing beam effect
                createHealingBeam(caster.position, target.position);
                
                // Set casting animation state
                caster.userData.castingUntil = performance.now() + 500;
                caster.userData.castingType = 'heal';
            } 
            else if (ability.type === 'damage') {
                // DAMAGE with resilience and buffs
                if (target.userData.ccUntil > 0 && target.userData.ccType === 'invulnerable' && !ability.shatterImmunity) return;

                // Calculate gear stats for player team only
                const gearStats = caster.userData.isEnemy ? { damage: 0, critChance: 0 } : calculateTotalGearStats();
                const damageTalentBonus = caster.userData.isEnemy ? 0 : getTalentBonus('tal_damage');
                const critDamageTalentBonus = caster.userData.isEnemy ? 0 : getTalentBonus('tal_crit');

                // Conquest bonuses (only for player team)
                const masteryBonus = caster.userData.isEnemy ? 1 : (1 + (gameState.conquestUpgrades.conquest_mastery || 0) * 0.05);
                const versatilityDamage = caster.userData.isEnemy ? 1 : (1 + (gameState.conquestUpgrades.conquest_versatility || 0) * 0.03);

                // Prestige Power Scaling
                const powerScale = caster.userData.powerScale || 1;

                let damage = ((ability.damage || 0) * (1 + gameState.upgrades.damage * 0.08 + damageTalentBonus) + (gearStats.damage * 100)) * masteryBonus * versatilityDamage * powerScale;
                
                // Executioner Talent: damage against targets below 35% health
                if (!caster.userData.isEnemy && (target.userData.health / target.userData.maxHealth) < 0.35) {
                    damage *= (1 + getTalentBonus('tal_execution'));
                }
                
                // Rogue Eviscerate scaling
                if (ability.name === 'Eviscerate') {
                    damage *= (0.5 + currentCP * 0.4); // 5 CP = 2.5x base damage
                }
                
                // Apply offensive buffs (Combustion, etc)
                if (caster.userData.buffUntil > 0 && caster.userData.buffType === 'damageBuff') {
                    damage *= 1.5;
                }

                // Critical strike (upgrades + gear)
                const critChance = 0.15 + gameState.upgrades.critChance * 0.03 + (gearStats.critChance * 0.01);
                const isCrit = Math.random() < critChance;
                if (isCrit) damage *= (2 + critDamageTalentBonus);

                // Warrior Rage generation on dealing damage (Roughly 5 rage per attack)
                if (caster.userData.classType === 'warrior') {
                    caster.userData.mana = Math.min(caster.userData.maxMana, caster.userData.mana + 7.5);
                }

                // =============================================
                // PET TARGET: Route through centralized dealDamageToPet() for full avoidance pipeline
                // =============================================
                if (target.userData.isPet) {
                    const petDmgType = ability.damageType || (ability.school === 'physical' ? 'physical' : 'magic');
                    const actualPetDmg = dealDamageToPet(target, damage, petDmgType, caster, ability.name);
                    
                    if (actualPetDmg > 0) {
                        showDamageNumber(target.position, Math.round(actualPetDmg), false, isCrit);
                        if (!caster.userData.isEnemy) {
                            gameState.matchStats.damageDealt += actualPetDmg;
                        }
                        
                        const critText = isCrit ? ' (CRIT)' : '';
                        const targetName = target.userData.petName || 'Pet';
                        const casterName = caster.userData.isPet 
                            ? (caster.userData.petName || 'Pet') 
                            : (caster.userData.classData?.name || 'Unit');
                        addCombatLog(`${casterName}'s ${ability.name} hits ${targetName} for ${Math.round(actualPetDmg)}${critText}`, 'damage');
                    }
                    
                    // Create VFX for pet targets too
                    if (ability.name === 'Mortal Strike') {
                        createSlashEffect(target.position, caster.rotation.y);
                        createAbilityEffect(target.position, isCrit ? 0xffff00 : 0xff4444);
                    } else {
                        createAbilityEffect(target.position, isCrit ? 0xffff00 : 0xff4444);
                    }
                    caster.userData.attackingUntil = performance.now() + 300;
                    
                    // Apply mortal strike healing reduction to pets too
                    if (ability.healingReduction) {
                        target.userData.healingReduction = ability.healingReduction;
                        applyAura(target, 'Mortal Strike', 10, 'debuff');
                        setTimeout(() => { if (target.userData) target.userData.healingReduction = 0; }, 10000);
                    }
                    
                    return; // Skip the normal damage pipeline ‚Äî dealDamageToPet handled everything
                }
                
                // =============================================
                // SOUL LINK REDIRECT: Warlock with active Soul Link shares 20% of incoming damage to Felhunter
                // =============================================
                if (target._soulLinked && !target.userData.isPet) {
                    damage = processSoulLinkRedirect(target, damage);
                }
                
                // Resilience damage reduction
                const defenseTalentBonus = target.userData.isEnemy ? 0 : getTalentBonus('tal_defense');
                damage *= (1 - target.userData.resilience - defenseTalentBonus);
                
                // Versatility damage reduction (only for player team)
                const versatilityReduction = target.userData.isEnemy ? 1 : (1 - (gameState.conquestUpgrades.conquest_versatility || 0) * 0.03);
                damage *= versatilityReduction;

                // Apply Absorb Shields
                if (target.userData.absorb > 0) {
                    const absorbed = Math.min(target.userData.absorb, damage);
                    target.userData.absorb -= absorbed;
                    damage -= absorbed;
                    
                    // Track for player team
                    if (!target.userData.isEnemy) {
                        gameState.matchStats.damageAbsorbed += absorbed;
                    }
                    
                    showDamageNumber(target.position, `ABSORBED (${Math.round(absorbed)})`, false, false, true);
                }

                // Apply mortal strike healing reduction
                if (ability.healingReduction) {
                    target.userData.healingReduction = ability.healingReduction;
                    applyAura(target, 'Mortal Strike', 10, 'debuff');
                    setTimeout(() => { if (target.userData) target.userData.healingReduction = 0; }, 10000);
                }

                // Mortal Wound (Monk Rising Sun Kick - weaker healing reduction)
                if (ability.mortalWound) {
                    target.userData.healingReduction = Math.max(target.userData.healingReduction || 0, ability.mortalWound);
                    applyAura(target, 'Healing Reduction', 10, 'debuff');
                    setTimeout(() => { if (target.userData) target.userData.healingReduction = 0; }, 10000);
                }

                // Shattering Throw - removes invulnerability (Ice Block, Divine Shield)
                if (ability.shatterImmunity && target.userData.ccType === 'invulnerable') {
                    target.userData.ccType = null;
                    target.userData.buffUntil = 0;
                    target.userData.ccUntil = 0;
                    if (target.userData.auras) {
                        target.userData.auras = target.userData.auras.filter(a => 
                            a.name !== 'Ice Block' && a.name !== 'Divine Shield' && a.name !== 'Feign Death'
                        );
                    }
                    showDamageNumber(target.position, 'üí• SHATTERED!', false, false, true);
                    createExplosion(target.position, 0xffaa00, 20);
                    addCombatLog(`${caster.userData.classData.name} shatters ${target.userData.classData.name}'s immunity!`, 'cc');
                }

                // Apply Silence (Strangulate, Garrote)
                if (ability.applySilence) {
                    target.userData.schoolLockedUntil = Math.max(target.userData.schoolLockedUntil || 0, ability.applySilence);
                    applyAura(target, 'Silenced', ability.applySilence, 'debuff');
                    showDamageNumber(target.position, 'üîá SILENCED!', false, false, true);
                    addCombatLog(`${caster.userData.classData.name} silences ${target.userData.classData.name} for ${ability.applySilence}s`, 'cc');
                }

                // Slow effect (Chains of Ice)
                if (ability.slow && ability.slowDuration) {
                    const slowFactor = ability.slow;
                    target.userData.moveSpeed *= (1 - slowFactor);
                    applyAura(target, ability.name, ability.slowDuration, 'debuff');
                    showDamageNumber(target.position, 'üêå SLOWED!', false, false, true);
                    setTimeout(() => { if (target.userData) target.userData.moveSpeed /= (1 - slowFactor); }, ability.slowDuration * 1000);
                }

                // DoT effect (Garrote bleed)
                if (ability.dot && ability.dotDamage && ability.dotDuration) {
                    startDot(target, ability.dotDamage / (ability.dotDuration / 2), ability.dotDuration, 2, ability.name);
                    applyAura(target, ability.name, ability.dotDuration, 'debuff');
                }
                
                // Create spell-specific projectiles
                const startPos = caster.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                const targetPos = target.position.clone().add(new THREE.Vector3(0, 1, 0));
                
                if (ability.name === 'Fireball') {
                    createFireballProjectile(startPos, targetPos, () => {
                        target.userData.health = Math.max(0, target.userData.health - damage);
                        showDamageNumber(target.position, Math.round(damage), false, isCrit);
                        if (target.userData.health <= 0) {
                            killCharacter(target);
                        }
                    });
                    caster.userData.castingUntil = performance.now() + 800;
                    caster.userData.castingType = 'damage';
                    return; // Delay damage until projectile hits
                } else if (ability.name === 'Chain Lightning') {
                    // Shaman Chain Lightning - jumps to nearby enemies
                    createChainLightningEffect(caster.position, target.position, ability.chains || 1, caster.userData.isEnemy);
                    
                    const hitTarget = (t, dmg) => {
                        t.userData.health = Math.max(0, t.userData.health - dmg);
                        showDamageNumber(t.position, Math.round(dmg), false, false);
                        if (t.userData.health <= 0) killCharacter(t);
                    };
                    
                    hitTarget(target, damage);
                    
                    // Logic to find additional targets
                    if (ability.chains > 0) {
                        const enemyTeam = caster.userData.isEnemy ? gameState.team : gameState.enemies;
                        let chainedCount = 0;
                        enemyTeam.forEach(other => {
                            if (other !== target && other.visible && chainedCount < ability.chains) {
                                if (other.position.distanceTo(target.position) < 8) {
                                    setTimeout(() => hitTarget(other, damage * 0.7), 200);
                                    chainedCount++;
                                }
                            }
                        });
                    }
                    
                    caster.userData.castingUntil = performance.now() + 600;
                    caster.userData.castingType = 'damage';
                } else if (ability.name === 'Blizzard') {
                    // Mage Blizzard - AoE slow and damage
                    createBlizzardEffect(target.position, 6, 4000); // position, radius, duration
                    
                    const blizzardStartTime = performance.now();
                    const blizzardInterval = setInterval(() => {
                        if (performance.now() - blizzardStartTime > 4000) {
                            clearInterval(blizzardInterval);
                            return;
                        }
                        
                        const enemyTeam = caster.userData.isEnemy ? gameState.team : gameState.enemies;
                        enemyTeam.forEach(enemy => {
                            if (enemy.visible && enemy.position.distanceTo(target.position) < 6) {
                                const tickDamage = damage / 8; // 8 ticks over 4 seconds
                                enemy.userData.health = Math.max(0, enemy.userData.health - tickDamage);
                                showDamageNumber(enemy.position, Math.round(tickDamage), false, false);
                                enemy.userData.moveSpeed *= 0.7; // Slow effect
                                setTimeout(() => { if (enemy.userData) enemy.userData.moveSpeed /= 0.7; }, 500);
                                if (enemy.userData.health <= 0) killCharacter(enemy);
                            }
                        });
                    }, 500);
                    
                    caster.userData.castingUntil = performance.now() + 1000;
                    caster.userData.castingType = 'damage';
                    return;
                } else if (ability.name === 'Chaos Bolt') {
                    // Warlock Chaos Bolt - Green fire projectile
                    createFireballProjectile(startPos, targetPos, () => {
                        target.userData.health = Math.max(0, target.userData.health - damage);
                        showDamageNumber(target.position, Math.round(damage), false, isCrit);
                        if (target.userData.health <= 0) {
                            killCharacter(target);
                        }
                    });
                    // Chaos Bolt is much larger and more green
                    caster.userData.castingUntil = performance.now() + 1000;
                    caster.userData.castingType = 'damage';
                    return;
                } else if (ability.name === 'Death Coil') {
                    // Death Knight Death Coil - Dark green/purple projectile
                    createDeathCoilProjectile(startPos, targetPos, () => {
                        target.userData.health = Math.max(0, target.userData.health - damage);
                        showDamageNumber(target.position, Math.round(damage), false, isCrit);
                        
                        // Self heal component
                        if (ability.selfHeal) {
                            const healAmount = ability.selfHeal;
                            caster.userData.health = Math.min(caster.userData.maxHealth, caster.userData.health + healAmount);
                            showDamageNumber(caster.position, Math.round(healAmount), true);
                        }
                        
                        if (target.userData.health <= 0) {
                            killCharacter(target);
                        }
                    });
                    caster.userData.castingUntil = performance.now() + 600;
                    caster.userData.castingType = 'damage';
                    return;
                } else if (ability.name === 'Frostbolt') {
                    target.userData.moveSpeed *= 0.5;
                    createFrostboltProjectile(startPos, targetPos, () => {
                        target.userData.health = Math.max(0, target.userData.health - damage);
                        showDamageNumber(target.position, Math.round(damage), false, isCrit);
                        if (target.userData.health <= 0) {
                            killCharacter(target);
                        }
                    });
                    caster.userData.castingUntil = performance.now() + 800;
                    caster.userData.castingType = 'damage';
                    return; // Delay damage until projectile hits
                } else if (ability.name === 'Aimed Shot') {
                    // Hunter Aimed Shot with bow draw animation
                    createArrowProjectile(startPos, targetPos, () => {
                        target.userData.health = Math.max(0, target.userData.health - damage);
                        showDamageNumber(target.position, Math.round(damage), false, isCrit);
                        if (target.userData.health <= 0) {
                            killCharacter(target);
                        }
                    });
                    caster.userData.attackingUntil = performance.now() + 600; // Trigger bow animation
                    caster.userData.attackType = 'bow';
                    return;
                } else if (ability.name === 'Mortal Strike') {
                    // Warrior Mortal Strike - slash effect
                    createSlashEffect(target.position, caster.rotation.y);
                    createAbilityEffect(target.position, isCrit ? 0xffff00 : 0xff4444);
                    caster.userData.attackingUntil = performance.now() + 300;
                } else if (ability.name === 'Strangulate') {
                    // DK Strangulate - dark grip on throat
                    createAbilityEffect(target.position, 0xc41e3a);
                    createExplosion(target.position, 0x660022, 8);
                    caster.userData.attackingUntil = performance.now() + 300;
                } else if (ability.name === 'Garrote') {
                    // Rogue Garrote - bleed slash
                    createSlashEffect(target.position, caster.rotation.y);
                    createAbilityEffect(target.position, 0xff2200);
                    caster.userData.attackingUntil = performance.now() + 300;
                } else if (ability.name === 'Shattering Throw') {
                    // Warrior Shattering Throw - thrown weapon
                    createAbilityEffect(target.position, 0xffaa00);
                    createExplosion(target.position, 0xffcc00, 15);
                    caster.userData.attackingUntil = performance.now() + 400;
                } else {
                    // Other instant melee attacks
                    createAbilityEffect(target.position, isCrit ? 0xffff00 : 0xff4444);
                    caster.userData.attackingUntil = performance.now() + 300;
                }

                target.userData.health = Math.max(0, target.userData.health - damage);
                
                // Track damage taken (works for both players and pets)
                if (target.userData.totalDamageTaken !== undefined) {
                    target.userData.totalDamageTaken += damage;
                }
                
                // Warrior Rage generation on taking damage (Roughly 1 rage per 1% health lost)
                if (target.userData.classType === 'warrior') {
                    const rageGen = (damage / target.userData.maxHealth) * 100;
                    target.userData.mana = Math.min(target.userData.maxMana, target.userData.mana + rageGen);
                }

                showDamageNumber(target.position, Math.round(damage), false, isCrit);
                
                // Track stats (player only)
                if (!caster.userData.isEnemy) {
                    gameState.matchStats.damageDealt += damage;
                    if (checkLineOfSight(caster, target)) {
                        gameState.matchStats.losDamage += damage;
                    }
                }

                // Combat log (handle pet target names gracefully)
                const critText = isCrit ? ' (CRIT)' : '';
                const targetName = target.userData.isPet 
                    ? (target.userData.petName || 'Pet') 
                    : (target.userData.classData?.name || 'Unit');
                const casterName = caster.userData.isPet 
                    ? (caster.userData.petName || 'Pet') 
                    : (caster.userData.classData?.name || 'Unit');
                addCombatLog(`${casterName}'s ${ability.name} hits ${targetName} for ${Math.round(damage)}${critText}`, 'damage');

                if (target.userData.health <= 0) {
                    killCharacter(target);
                }
            }
            else if (ability.type === 'cc') {
                // CROWD CONTROL with diminishing returns
                if (target.userData.ccUntil > 0) return; // Already CC'd
                
                // Trinket/Grace Immunity Check
                if (target.userData.trinketImmunityUntil && gameState.matchTime < target.userData.trinketImmunityUntil) {
                    showDamageNumber(target.position, 'IMMUNE!', false, false, true);
                    return;
                }
                
                // Diminishing returns calculation
                const cat = ability.drCategory || 'cc';
                if (!target.userData.drState[cat]) {
                    target.userData.drState[cat] = { stacks: 0, timer: 0 };
                }
                
                const drStacks = target.userData.drState[cat].stacks;
                const drMultiplier = drStacks === 0 ? 1 : 
                                    drStacks === 1 ? 0.5 : 
                                    drStacks === 2 ? 0.25 : 0;
                
                if (drMultiplier === 0) {
                    showDamageNumber(target.position, 'IMMUNE (DR)!', false, false, true);
                    return;
                }

                let ccDuration = 0;
                if (ability.sheep) ccDuration = ability.sheep;
                else if (ability.fear) ccDuration = ability.fear;
                else if (ability.stun) ccDuration = ability.stun;
                else if (ability.freeze) ccDuration = ability.freeze;
                else if (ability.banish) ccDuration = ability.banish;
                else if (ability.disorient) ccDuration = ability.disorient;
                else if (ability.root) ccDuration = ability.root;

                // Rogue Kidney Shot scaling
                if (ability.name === 'Kidney Shot') {
                    ccDuration = currentCP * 1.2;
                }

                ccDuration *= drMultiplier;
                
                // Apply upgrades + gear stats for player team only
                const gearStats = caster.userData.isEnemy ? { ccDuration: 0 } : calculateTotalGearStats();
                const ccResTalentBonus = target.userData.isEnemy ? 0 : getTalentBonus('tal_cc_res');
                
                ccDuration *= (1 + gameState.upgrades.ccDuration * 0.1) * (1 + gearStats.ccDuration * 0.02);
                ccDuration *= (1 - ccResTalentBonus); // Reduce duration by talent percentage

                target.userData.ccUntil = ccDuration;
                target.userData.ccType = ability.sheep ? 'sheep' : 
                                         ability.fear ? 'fear' : 
                                         ability.stun ? 'stun' :
                                         ability.freeze ? 'freeze' : 
                                         ability.banish ? 'banish' : 
                                         ability.disorient ? 'fear' : 
                                         ability.root ? 'root' : 'cc';
                
                // Apply visual aura icon
                applyAura(target, ability.name, ccDuration, 'debuff');

                // Update DR state
                target.userData.drState[cat].stacks++;
                target.userData.drState[cat].timer = 18; 

                // Track stats (player only)
                if (!caster.userData.isEnemy) {
                    gameState.matchStats.ccChains++;
                    if (window.triggerCrowdCheer) window.triggerCrowdCheer(1.5);
                }

                // selfHealPercent on CC abilities (Mortal Coil)
                if (ability.selfHealPercent) {
                    const selfHealAmount = caster.userData.maxHealth * ability.selfHealPercent;
                    caster.userData.health = Math.min(caster.userData.maxHealth, caster.userData.health + selfHealAmount);
                    showDamageNumber(caster.position, Math.round(selfHealAmount), true);
                    addCombatLog(`${caster.userData.classData.name} heals for ${Math.round(selfHealAmount)} from ${ability.name}`, 'heal');
                }

                const ccText = ability.sheep ? 'üêë SHEEP!' : 
                              ability.fear ? 'üò± FEAR!' : 
                              ability.stun ? '‚ö° STUNNED!' :
                              ability.freeze ? '‚ùÑÔ∏è FROZEN!' :
                              ability.banish ? 'üå™Ô∏è CYCLONE!' : 
                              ability.disorient ? 'üëÅÔ∏è BLINDED!' : 
                              ability.root ? 'üåø ROOTED!' : 'üí¢ CC!';
                showDamageNumber(target.position, ccText, false, false, true);
                
                // Combat log
                addCombatLog(`${caster.userData.classData.name} uses ${ability.name} on ${target.userData.classData.name} (${ccDuration.toFixed(1)}s)`, 'cc');
                
                // Class-specific CC effects
                if (ability.sheep) {
                    createPolymorphEffect(target.position);
                } else if (ability.fear || ability.disorient) {
                    if (ability.name === 'Psychic Scream') {
                        createPsychicScreamEffect(caster.position);
                    } else if (ability.name === 'Howl of Terror' || ability.name === 'Sigil of Misery') {
                        createAbilityEffect(caster.position, 0x8787ed);
                        createExplosion(caster.position, 0x8787ed, 15);
                    } else if (ability.name === 'Blinding Light') {
                        createExplosion(caster.position, 0xffff00, 20);
                        createAbilityEffect(caster.position, 0xffff00);
                    } else if (ability.name === 'Incapacitating Roar') {
                        createExplosion(caster.position, 0xff7d0a, 15);
                        createAbilityEffect(caster.position, 0xff7d0a);
                    } else {
                        createAbilityEffect(target.position, 0xff00ff);
                    }
                } else if (ability.freeze) {
                    createFreezingTrapEffect(target.position);
                    if (ability.name === 'Ring of Frost') {
                        createExplosion(target.position, 0x69ccf0, 15);
                    }
                } else if (ability.banish) {
                    createCycloneEffect(target.position);
                } else if (ability.root) {
                    // Root effects - green/nature vines
                    createAbilityEffect(target.position, 0x00cc44);
                    if (ability.name === 'Entangling Roots') {
                        createExplosion(target.position, 0x228b22, 10);
                    } else if (ability.name === 'Frost Nova') {
                        createFreezingTrapEffect(target.position);
                        createExplosion(caster.position, 0x69ccf0, 15);
                    } else if (ability.name === 'Earthgrab Totem') {
                        createExplosion(caster.position, 0x8b4513, 12);
                    }
                } else if (ability.name === 'Chaos Nova') {
                    createAbilityEffect(caster.position, 0x32ff00);
                    createExplosion(caster.position, 0x32ff00, 20);
                } else if (ability.name === 'Remorseless Winter') {
                    createExplosion(caster.position, 0x69ccf0, 18);
                    createAbilityEffect(caster.position, 0xaaddff);
                } else if (ability.name === 'Shadowfury') {
                    createExplosion(target.position, 0x8787ed, 18);
                    createAbilityEffect(target.position, 0x550088);
                } else if (ability.name === 'Fel Eruption') {
                    createExplosion(target.position, 0x32ff00, 12);
                    createAbilityEffect(target.position, 0xa330c9);
                } else {
                    createAbilityEffect(target.position, 0xff00ff);
                }
            }
            else if (ability.type === 'defensive') {
                // DEFENSIVE COOLDOWNS
                const defTarget = (ability.target === 'ally') ? target : caster;
                applyAura(defTarget, ability.name, ability.duration, 'buff');
                
                // Desperate Prayer - instant self-heal on use
                if (ability.selfHealOnUse) {
                    const selfHealAmount = caster.userData.maxHealth * ability.selfHealOnUse;
                    caster.userData.health = Math.min(caster.userData.maxHealth, caster.userData.health + selfHealAmount);
                    showDamageNumber(caster.position, Math.round(selfHealAmount), true);
                    createAbilityEffect(caster.position, 0xffffaa);
                    addCombatLog(`${caster.userData.classData.name} heals for ${Math.round(selfHealAmount)} from ${ability.name}`, 'heal');
                }

                // Apply Absorb Shield (Dark Pact, Touch of Karma, PW:S)
                if (ability.absorb) {
                    defTarget.userData.absorb = (defTarget.userData.absorb || 0) + ability.absorb;
                    setTimeout(() => {
                        if (defTarget.userData) {
                            defTarget.userData.absorb = Math.max(0, (defTarget.userData.absorb || 0) - ability.absorb);
                        }
                    }, (ability.duration || 15) * 1000);
                }
                
                if (ability.invulnerable) {
                    defTarget.userData.ccType = 'invulnerable';
                    defTarget.userData.buffUntil = ability.duration;
                    showDamageNumber(defTarget.position, 'IMMUNE!', false, false, true);
                    
                    // Class-specific defensive effects
                    if (ability.name === 'Ice Block') {
                        createIceBlockEffect(defTarget);
                    } else if (ability.name === 'Divine Shield') {
                        createAbilityEffect(defTarget.position, 0xffff00); // Golden bubble
                    } else if (ability.name === 'Metamorphosis') {
                        createAbilityEffect(defTarget.position, 0xa330c9); // Purple transformation
                        createExplosion(defTarget.position, 0x32ff00, 20); // Fel explosion
                    } else {
                        createAbilityEffect(defTarget.position, 0x00ffff);
                    }
                } else if (ability.damageReduction) {
                    defTarget.userData.resilience += ability.damageReduction;
                    setTimeout(() => { if (defTarget.userData) defTarget.userData.resilience -= ability.damageReduction; }, ability.duration * 1000);
                    showDamageNumber(defTarget.position, 'üõ°Ô∏è DEFENSIVE!', false, false, true);
                    
                    // Class-specific defensive effects
                    if (ability.name === 'Barkskin') {
                        createBarkskinEffect(defTarget);
                    } else if (ability.name === 'Die by the Sword') {
                        createWhirlwindEffect(defTarget.position);
                    } else if (ability.name === 'Anti-Magic Shell') {
                        createAMSEffect(defTarget);
                    } else if (ability.name === 'Cloak of Shadows') {
                        createAbilityEffect(defTarget.position, 0x333333); // Dark cloud
                    } else if (ability.name === 'Smoke Bomb') {
                        createExplosion(defTarget.position, 0x333333, 25);
                        createAbilityEffect(defTarget.position, 0x555555);
                    } else {
                        createAbilityEffect(defTarget.position, 0xffaa00);
                    }
                } else if (ability.absorb && !ability.damageReduction && !ability.invulnerable) {
                    // Pure absorb shields (PW:S, Dark Pact without damage reduction)
                    showDamageNumber(defTarget.position, `üõ°Ô∏è ABSORB (${ability.absorb})`, false, false, true);
                    createAbilityEffect(defTarget.position, 0xffdd44);
                }
            }
            else if (ability.type === 'offensive') {
                // OFFENSIVE COOLDOWNS (Combustion, etc)
                applyAura(caster, ability.name, ability.duration, 'buff');
                
                caster.userData.buffType = 'damageBuff';
                caster.userData.buffUntil = ability.duration;
                showDamageNumber(caster.position, 'üî• BURST!', false, false, true);
                
                // Class-specific offensive effects
                if (ability.name === 'Combustion') {
                    createCombustionEffect(caster);
                } else if (ability.name === 'Bestial Wrath') {
                    createAbilityEffect(caster.position, 0xff0000);
                } else if (ability.name === 'Adrenaline Rush') {
                    createAbilityEffect(caster.position, 0xffff00);
                } else if (ability.name === 'Metamorphosis') {
                    createAbilityEffect(caster.position, 0xa330c9);
                    createExplosion(caster.position, 0x32ff00, 20);
                    // Demon Hunter health buff
                    if (ability.healthBuff) {
                        const healthGain = caster.userData.maxHealth * ability.healthBuff;
                        caster.userData.health = Math.min(caster.userData.maxHealth + healthGain, caster.userData.health + healthGain);
                        showDamageNumber(caster.position, Math.round(healthGain), true);
                    }
                } else {
                    createAbilityEffect(caster.position, 0xff8800);
                }
            }
            else if (ability.type === 'utility') {
                // UTILITY (Charge, Blink, Death Grip, Fel Rush)
                if (ability.name === 'Charge' || ability.name === 'Fel Rush') {
                    // Charge effect with trail
                    const startPos = caster.position.clone();
                    const dir = new THREE.Vector3().subVectors(target.position, caster.position).normalize();
                    const targetPos = target.position.clone().sub(dir.multiplyScalar(1.5));
                    caster.position.copy(targetPos);
                    
                    if (ability.name === 'Fel Rush') {
                        createExplosion(startPos, 0x32ff00, 10);
                        createExplosion(targetPos, 0x32ff00, 10);
                        showDamageNumber(caster.position, 'üèÉ FEL RUSH!', false, false, true);
                    } else {
                        createChargeEffect(startPos, targetPos);
                        showDamageNumber(caster.position, '‚öîÔ∏è CHARGE!', false, false, true);
                    }
                    
                    // Add stun or damage
                    if (ability.stun) {
                        useAbility(caster, target, {type: 'cc', stun: ability.stun}, dampening);
                    }
                    if (ability.damage) {
                         target.userData.health = Math.max(0, target.userData.health - ability.damage);
                         showDamageNumber(target.position, Math.round(ability.damage), false);
                    }
                } else if (ability.name === 'Blink') {
                    const startPos = caster.position.clone();
                    const dir = new THREE.Vector3().subVectors(target.position, caster.position).normalize();
                    caster.position.addScaledVector(dir, 10); // Blink 10 units forward
                    
                    // Arcane blink effect
                    createAbilityEffect(startPos, 0xaaaaff);
                    createAbilityEffect(caster.position, 0xaaaaff);
                    showDamageNumber(caster.position, '‚ú® BLINK!', false, false, true);
                } else if (ability.name === 'Death Grip') {
                    // Death Knight Death Grip - Pull target towards caster
                    const dir = new THREE.Vector3().subVectors(caster.position, target.position).normalize();
                    const pullPos = caster.position.clone().add(dir.multiplyScalar(1.5));
                    target.position.copy(pullPos);
                    
                    createAbilityEffect(target.position, 0x00ffff);
                    addCombatLog(`${caster.userData.classData.name} grips ${target.userData.classData.name}!`, 'utility');
                    showDamageNumber(target.position, '‚õìÔ∏è GRIP!', false, false, true);
                } else if (ability.knockback) {
                    const knockbackAmount = ability.knockback;
                    const targets = ability.aoe ? [...gameState.team, ...gameState.enemies].filter(u => 
                        u.userData.health > 0 && 
                        u !== caster && 
                        u.position.distanceTo(caster.position) < 8
                    ) : [target];

                    targets.forEach(t => {
                        const dir = new THREE.Vector3().subVectors(t.position, caster.position).normalize();
                        dir.y = 0.5; // Upward arc
                        
                        // Apply knockback velocity
                        t.userData.velocity.addScaledVector(dir, knockbackAmount * 1.5);
                        showDamageNumber(t.position, 'üí¢ KNOCKBACK!', false, false, true);
                        
                        // Briefly interrupt casting if target is casting
                        if (t.userData.castingAbility) {
                            t.userData.interruptedUntil = gameState.matchTime + 1.5;
                            t.userData.interruptedSpellName = t.userData.castingAbility.name;
                            t.userData.castingAbility = null;
                            t.userData.castingTarget = null;
                            t.userData.castProgress = 0;
                            showDamageNumber(t.position, 'INTERRUPTED', false, false, true);
                        }
                    });

                    if (ability.name === 'Thunderstorm') createExplosion(caster.position, 0x0070de, 20);
                    if (ability.name === 'Typhoon') createExplosion(caster.position, 0x44ff44, 20);
                    if (ability.name === 'High Explosive Trap') createExplosion(caster.position, 0xff8800, 20);
                    if (ability.name === 'Ring of Peace') createExplosion(caster.position, 0x00ff96, 18);
                    
                    addCombatLog(`${caster.userData.classData.name} uses ${ability.name}!`, 'utility');
                }
            }
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        const activeParticles = [];

        // Procedural Glow Texture for particles
        function createGlowTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const particleTexture = createGlowTexture();

        function createParticle(position, velocity, color, size, lifetime) {
            const material = new THREE.SpriteMaterial({
                map: particleTexture,
                color,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const particle = new THREE.Sprite(material);
            particle.position.copy(position);
            particle.scale.set(size, size, 1);
            scene.add(particle);

            activeParticles.push({
                mesh: particle,
                velocity: velocity.clone(),
                lifetime: lifetime,
                maxLifetime: lifetime,
                baseSize: size
            });
        }

        function updateParticles(deltaTime) {
            // Update enchantment visuals
            scene.traverse(child => {
                if (child.userData.isEnchantVisual) {
                    // Update main glow pulses
                    if (child.isMesh && child.material && child.material.transparent) {
                        const pulseFreq = child.userData.isEnchantParticle ? 0.01 : 0.003;
                        const baseOpacity = child.userData.isEnchantParticle ? 0.6 : 0.15;
                        const pulseAmount = child.userData.isEnchantParticle ? 0.4 : 0.1;
                        child.material.opacity = baseOpacity + Math.sin(performance.now() * pulseFreq) * pulseAmount;
                    }

                    // Update spark particles
                    if (child.userData.isEnchantParticle) {
                        // Move particles along blade (Assuming Y is the axis along the blade)
                        child.position.y += child.userData.pSpeed * child.userData.pDir;
                        
                        // Bounce back at ends of blade (approx 0.8 units from center)
                        if (Math.abs(child.position.y) > 0.8) {
                            child.userData.pDir *= -1;
                        }
                        
                        // Add some organic "jitter"
                        child.position.x += (Math.random() - 0.5) * 0.01;
                        child.position.z += (Math.random() - 0.5) * 0.01;
                        
                        // Keep within bounds
                        child.position.x = THREE.MathUtils.clamp(child.position.x, -0.1, 0.1);
                        child.position.z = THREE.MathUtils.clamp(child.position.z, -0.1, 0.1);
                    }
                }
            });

            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const p = activeParticles[i];
                
                // Update position
                p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                
                // Apply some gravity/drag to particles
                p.velocity.y -= 0.5 * deltaTime;
                p.velocity.multiplyScalar(0.99);
                
                // Update lifetime
                p.lifetime -= deltaTime;
                
                // Fade out and shrink
                const alpha = Math.max(0, p.lifetime / p.maxLifetime);
                p.mesh.material.opacity = alpha * 0.8;
                const currentSize = alpha * p.baseSize;
                p.mesh.scale.set(currentSize, currentSize, 1);
                
                // Remove dead particles
                if (p.lifetime <= 0) {
                    scene.remove(p.mesh);
                    // Sprites use shared material in this case, but we should be careful
                    // Actually, if we create a new material per particle, we should dispose it.
                    // For performance, we could pool these.
                    p.mesh.material.dispose();
                    activeParticles.splice(i, 1);
                }
            }
        }

        function createFireballProjectile(start, target, onImpact) {
            const direction = target.clone().sub(start).normalize();
            const distance = start.distanceTo(target);
            const duration = distance / 15; // Speed: 15 units/second

            // Create fireball core
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const fireball = new THREE.Mesh(geometry, material);
            fireball.position.copy(start);
            scene.add(fireball);

            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            fireball.add(glow);

            let elapsed = 0;
            const animateProjectile = () => {
                elapsed += 0.016; // ~60fps
                
                if (elapsed >= duration) {
                    scene.remove(fireball);
                    fireball.geometry.dispose();
                    fireball.material.dispose();
                    glow.geometry.dispose();
                    glow.material.dispose();
                    
                    // Impact effect
                    createExplosion(target, 0xff4400, 20);
                    if (onImpact) onImpact();
                } else {
                    const t = elapsed / duration;
                    fireball.position.lerpVectors(start, target, t);
                    
                    // Trail particles
                    if (Math.random() > 0.5) {
                        const particlePos = fireball.position.clone();
                        const particleVel = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        createParticle(particlePos, particleVel, 0xff6600, 0.15, 0.5);
                    }
                    
                    // Rotate glow
                    glow.rotation.x += 0.1;
                    glow.rotation.y += 0.15;
                    
                    requestAnimationFrame(animateProjectile);
                }
            };
            animateProjectile();
        }

        function createDeathCoilProjectile(start, target, onImpact) {
            const direction = target.clone().sub(start).normalize();
            const distance = start.distanceTo(target);
            const duration = distance / 12; // DK speed

            const geometry = new THREE.SphereGeometry(0.4, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x4B0082, // Indigo/Purple
                transparent: true,
                opacity: 0.8
            });
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(start);
            scene.add(projectile);

            const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x00FF00, // Green
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            projectile.add(glow);

            let elapsed = 0;
            const animateProjectile = () => {
                elapsed += 0.016;
                
                if (elapsed >= duration) {
                    scene.remove(projectile);
                    projectile.geometry.dispose();
                    projectile.material.dispose();
                    glow.geometry.dispose();
                    glow.material.dispose();
                    
                    createExplosion(target, 0x00ff00, 15);
                    if (onImpact) onImpact();
                } else {
                    const t = elapsed / duration;
                    const pos = new THREE.Vector3().lerpVectors(start, target, t);
                    // Sine wave wobble
                    pos.x += Math.sin(t * 15) * 0.4;
                    pos.y += Math.cos(t * 15) * 0.4;
                    projectile.position.copy(pos);
                    
                    if (Math.random() > 0.6) {
                        createParticle(pos, new THREE.Vector3(0,0,0), 0x00ff00, 0.1, 0.4);
                    }
                    
                    requestAnimationFrame(animateProjectile);
                }
            };
            animateProjectile();
        }

        function createFrostboltProjectile(start, target, onImpact) {
            const direction = target.clone().sub(start).normalize();
            const distance = start.distanceTo(target);
            const duration = distance / 18; // Slightly faster than fireball

            // Create frostbolt shard
            const geometry = new THREE.ConeGeometry(0.2, 0.8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: 0x88ddff,
                transparent: true,
                opacity: 0.9,
                emissive: 0x0088ff,
                emissiveIntensity: 0.5
            });
            const frostbolt = new THREE.Mesh(geometry, material);
            frostbolt.position.copy(start);
            frostbolt.rotation.x = -Math.PI / 2;
            scene.add(frostbolt);

            // Point in direction
            const angle = Math.atan2(direction.x, direction.z);
            frostbolt.rotation.z = -angle;

            let elapsed = 0;
            const animateProjectile = () => {
                elapsed += 0.016;
                
                if (elapsed >= duration) {
                    scene.remove(frostbolt);
                    frostbolt.geometry.dispose();
                    frostbolt.material.dispose();
                    
                    // Ice impact effect
                    createExplosion(target, 0x00ddff, 15);
                    if (onImpact) onImpact();
                } else {
                    const t = elapsed / duration;
                    frostbolt.position.lerpVectors(start, target, t);
                    
                    // Ice crystal trail
                    if (Math.random() > 0.6) {
                        const particlePos = frostbolt.position.clone();
                        const particleVel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        createParticle(particlePos, particleVel, 0x88ddff, 0.1, 0.6);
                    }
                    
                    requestAnimationFrame(animateProjectile);
                }
            };
            animateProjectile();
        }

        function createHealingBeam(start, target) {
            // Healing particle stream from caster to target
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const startPos = start.clone().add(new THREE.Vector3(0, 1.5, 0));
                    const targetPos = target.clone().add(new THREE.Vector3(0, 1, 0));
                    const t = Math.random();
                    const particlePos = new THREE.Vector3().lerpVectors(startPos, targetPos, t);
                    
                    const velocity = new THREE.Vector3().subVectors(targetPos, startPos).normalize().multiplyScalar(3);
                    createParticle(particlePos, velocity, 0x44ff44, 0.2, 0.8);
                }, i * 50);
            }
            
            // Healing burst at target
            createExplosion(target, 0x44ff88, 12);
        }

        function createExplosion(position, color, particleCount) {
            for (let i = 0; i < particleCount; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 4
                );
                const particlePos = position.clone().add(new THREE.Vector3(0, 1, 0));
                createParticle(particlePos, velocity, color, 0.15, 0.5 + Math.random() * 0.5);
            }
        }

        // ============================================
        // CLASS-SPECIFIC ABILITY EFFECTS
        // ============================================
        
        // WARRIOR - Whirlwind (spinning blade effect)
        function createBlizzardEffect(position, radius, duration) {
            const blizzardGroup = new THREE.Group();
            blizzardGroup.position.copy(position);
            scene.add(blizzardGroup);

            // Ground frost circle
            const groundGeo = new THREE.CircleGeometry(radius, 32);
            const groundMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.05;
            blizzardGroup.add(ground);

            const snowflakes = [];
            const snowflakeGeo = new THREE.OctahedronGeometry(0.1, 0);
            const snowflakeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < 40; i++) {
                const snowflake = new THREE.Mesh(snowflakeGeo, snowflakeMat);
                snowflake.position.set(
                    (Math.random() - 0.5) * radius * 2,
                    Math.random() * 10 + 2,
                    (Math.random() - 0.5) * radius * 2
                );
                blizzardGroup.add(snowflake);
                snowflakes.push({
                    mesh: snowflake,
                    speed: Math.random() * 0.1 + 0.05,
                    rotationSpeed: Math.random() * 0.1
                });
            }

            const startTime = performance.now();
            const animateBlizzard = () => {
                const elapsed = performance.now() - startTime;
                if (elapsed > duration) {
                    scene.remove(blizzardGroup);
                    blizzardGroup.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    return;
                }

                snowflakes.forEach(s => {
                    s.mesh.position.y -= s.speed;
                    s.mesh.rotation.x += s.rotationSpeed;
                    s.mesh.rotation.y += s.rotationSpeed;
                    if (s.mesh.position.y < 0) {
                        s.mesh.position.y = 10;
                    }
                });

                requestAnimationFrame(animateBlizzard);
            };
            animateBlizzard();
        }

        function createChainLightningEffect(start, target, chains, isEnemy) {
            const color = 0x00ccff;
            const segments = 5;
            
            const createBolt = (p1, p2) => {
                const group = new THREE.Group();
                scene.add(group);
                
                const points = [];
                points.push(p1.clone().add(new THREE.Vector3(0, 1.5, 0)));
                
                for(let i=1; i<segments; i++) {
                    const t = i / segments;
                    const p = new THREE.Vector3().lerpVectors(p1, p2, t);
                    p.y += 1.5;
                    p.x += (Math.random() - 0.5) * 0.5;
                    p.y += (Math.random() - 0.5) * 0.5;
                    p.z += (Math.random() - 0.5) * 0.5;
                    points.push(p);
                }
                
                points.push(p2.clone().add(new THREE.Vector3(0, 1, 0)));
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, segments * 2, 0.05, 8, false);
                const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
                const bolt = new THREE.Mesh(geometry, material);
                group.add(bolt);
                
                setTimeout(() => {
                    scene.remove(group);
                    geometry.dispose();
                    material.dispose();
                }, 150);
            };
            
            createBolt(start, target);
            
            // Chain to others
            if (chains > 0) {
                const targetTeam = isEnemy ? gameState.team : gameState.enemies;
                let chained = 0;
                targetTeam.forEach(other => {
                    if (other.visible && other.position.distanceTo(target) < 8 && other.position.distanceTo(target) > 0.1 && chained < chains) {
                        setTimeout(() => createBolt(target, other.position), 100);
                        chained++;
                    }
                });
            }
        }

        function createWhirlwindEffect(position) {
            const bladeCount = 8;
            const radius = 2.5;
            const duration = 1.0;
            const startTime = performance.now();
            
            const blades = [];
            for (let i = 0; i < bladeCount; i++) {
                const geometry = new THREE.BoxGeometry(0.8, 0.1, 0.1);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const blade = new THREE.Mesh(geometry, material);
                blade.position.copy(position);
                blade.position.y += 1.5;
                scene.add(blade);
                blades.push(blade);
            }
            
            const animate = () => {
                const elapsed = (performance.now() - startTime) / 1000;
                if (elapsed >= duration) {
                    blades.forEach(b => {
                        scene.remove(b);
                        b.geometry.dispose();
                        b.material.dispose();
                    });
                    return;
                }
                
                const rotation = elapsed * Math.PI * 4; // 2 full rotations per second
                blades.forEach((blade, i) => {
                    const angle = rotation + (i / bladeCount) * Math.PI * 2;
                    blade.position.x = position.x + Math.cos(angle) * radius;
                    blade.position.z = position.z + Math.sin(angle) * radius;
                    blade.rotation.y = angle;
                    blade.material.opacity = 0.8 * (1 - elapsed / duration);
                });
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        // WARRIOR - Charge (speed trail)
        function createChargeEffect(start, end) {
            const trailLength = 15;
            for (let i = 0; i < trailLength; i++) {
                setTimeout(() => {
                    const t = i / trailLength;
                    const pos = new THREE.Vector3().lerpVectors(start, end, t);
                    const velocity = new THREE.Vector3(0, Math.random() * 0.5, 0);
                    createParticle(pos, velocity, 0xffaa00, 0.2, 0.3);
                }, i * 20);
            }
        }

        // WARRIOR - Mortal Strike (slash effect)
        function createSlashEffect(position, rotation) {
            const slashGeo = new THREE.PlaneGeometry(3, 0.5);
            const slashMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const slash = new THREE.Mesh(slashGeo, slashMat);
            slash.position.copy(position);
            slash.position.y += 1.5;
            slash.rotation.y = rotation;
            scene.add(slash);
            
            let scale = 0.5;
            const animate = () => {
                scale += 0.15;
                slash.scale.set(scale, 1, 1);
                slashMat.opacity -= 0.08;
                
                if (slashMat.opacity <= 0) {
                    scene.remove(slash);
                    slashGeo.dispose();
                    slashMat.dispose();
                } else {
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        // MAGE - Polymorph (sheep transformation)
        function createPolymorphEffect(position) {
            // Purple sparkles expanding outward
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const velocity = new THREE.Vector3(
                    Math.cos(angle) * 2,
                    Math.random() * 2,
                    Math.sin(angle) * 2
                );
                const pos = position.clone().add(new THREE.Vector3(0, 1, 0));
                createParticle(pos, velocity, 0xff00ff, 0.1, 0.8);
            }
            
            // Poof cloud
            createExplosion(position, 0xee88ff, 15);
        }

        // MAGE - Ice Block (frost shield)
        function createIceBlockEffect(character) {
            // Check if already has effect
            if (character.getObjectByName('ice-block-effect')) return;

            const iceGeo = new THREE.SphereGeometry(1.2, 12, 12);
            const iceMat = new THREE.MeshStandardMaterial({
                color: 0x88ddff,
                transparent: true,
                opacity: 0.4,
                emissive: 0x0088ff,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.1
            });
            const iceShield = new THREE.Mesh(iceGeo, iceMat);
            iceShield.name = 'ice-block-effect';
            iceShield.position.set(0, 1.5, 0);
            character.add(iceShield);
            
            const animate = () => {
                const hasAura = character.userData.auras && character.userData.auras.some(a => a.name === 'Ice Block');
                if (!character.parent || character.userData.health <= 0 || !hasAura || !gameState.inMatch) {
                    // Shatter effect
                    for (let i = 0; i < 20; i++) {
                        const velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 3,
                            Math.random() * 2,
                            (Math.random() - 0.5) * 3
                        );
                        createParticle(character.position.clone().add(new THREE.Vector3(0, 1.5, 0)), velocity, 0x88ddff, 0.15, 0.5);
                    }
                    character.remove(iceShield);
                    iceGeo.dispose();
                    iceMat.dispose();
                    return;
                }
                
                iceShield.rotation.y += 0.02;
                iceMat.emissiveIntensity = 0.5 + Math.sin(performance.now() * 0.005) * 0.3;
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        // MAGE - Combustion (fire aura)
        function createCombustionEffect(character) {
            const startTime = performance.now();
            const duration = 10000; // 10 seconds
            
            const animate = () => {
                const elapsed = performance.now() - startTime;
                if (elapsed >= duration) return;
                
                // Spawn fire particles around character
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.8;
                const pos = character.position.clone();
                pos.x += Math.cos(angle) * radius;
                pos.z += Math.sin(angle) * radius;
                pos.y += Math.random() * 2;
                
                const velocity = new THREE.Vector3(0, Math.random() * 1.5, 0);
                createParticle(pos, velocity, Math.random() > 0.5 ? 0xff6600 : 0xffaa00, 0.15, 0.5);
                
                setTimeout(() => requestAnimationFrame(animate), 50);
            };
            animate();
        }

        // HUNTER - Aimed Shot (arrow projectile)
        function createArrowProjectile(start, target, onImpact) {
            const direction = target.clone().sub(start).normalize();
            const distance = start.distanceTo(target);
            const duration = distance / 25; // Faster than fireball

            const arrowGeo = new THREE.ConeGeometry(0.1, 0.8, 8);
            const arrowMat = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                metalness: 0.3,
                roughness: 0.7
            });
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.copy(start);
            arrow.rotation.x = Math.PI / 2;
            scene.add(arrow);

            // Point arrow in flight direction
            const angle = Math.atan2(direction.x, direction.z);
            arrow.rotation.z = -angle;
            const pitch = Math.asin(direction.y);
            arrow.rotation.x = Math.PI / 2 - pitch;

            let elapsed = 0;
            const animateProjectile = () => {
                elapsed += 0.016;
                
                if (elapsed >= duration) {
                    scene.remove(arrow);
                    arrowGeo.dispose();
                    arrowMat.dispose();
                    createExplosion(target, 0xffaa00, 12);
                    if (onImpact) onImpact();
                } else {
                    const t = elapsed / duration;
                    arrow.position.lerpVectors(start, target, t);
                    requestAnimationFrame(animateProjectile);
                }
            };
            animateProjectile();
        }

        // HUNTER - Freezing Trap (ice explosion)
        function createFreezingTrapEffect(position) {
            // Ice spikes radiating outward
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const spikeGeo = new THREE.ConeGeometry(0.2, 1.5, 6);
                const spikeMat = new THREE.MeshStandardMaterial({
                    color: 0x88ddff,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x0088ff,
                    emissiveIntensity: 0.3
                });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                spike.position.copy(position);
                spike.position.x += Math.cos(angle) * 1.5;
                spike.position.z += Math.sin(angle) * 1.5;
                spike.rotation.z = Math.PI / 6; // Tilt outward
                spike.rotation.y = angle;
                scene.add(spike);
                
                setTimeout(() => {
                    scene.remove(spike);
                    spikeGeo.dispose();
                    spikeMat.dispose();
                }, 2000);
            }
            
            createExplosion(position, 0x88ddff, 25);
        }

        // PRIEST - Psychic Scream (purple shockwave)
        function createPsychicScreamEffect(position) {
            const ringGeo = new THREE.TorusGeometry(0.5, 0.1, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xaa00ff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.position.y += 1;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            let scale = 1;
            const animate = () => {
                scale += 0.3;
                ring.scale.set(scale, scale, scale);
                ringMat.opacity -= 0.04;
                
                if (ringMat.opacity <= 0) {
                    scene.remove(ring);
                    ringGeo.dispose();
                    ringMat.dispose();
                } else {
                    requestAnimationFrame(animate);
                }
            };
            animate();
            
            // Purple particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const velocity = new THREE.Vector3(
                    Math.cos(angle) * 3,
                    Math.random() * 1,
                    Math.sin(angle) * 3
                );
                createParticle(position.clone().add(new THREE.Vector3(0, 1, 0)), velocity, 0xaa00ff, 0.12, 0.6);
            }
        }

        // DRUID - Cyclone (wind vortex)
        function createCycloneEffect(position) {
            const startTime = performance.now();
            const duration = 2000;
            const particleCount = 40;
            
            const animate = () => {
                const elapsed = performance.now() - startTime;
                if (elapsed >= duration) return;
                
                const t = elapsed / duration;
                const height = t * 4; // Rises up
                const radius = 1 - t * 0.5; // Gets narrower
                const angle = elapsed * 0.01;
                
                for (let i = 0; i < 3; i++) {
                    const particleAngle = angle + (i / 3) * Math.PI * 2;
                    const pos = new THREE.Vector3(
                        position.x + Math.cos(particleAngle) * radius,
                        position.y + height,
                        position.z + Math.sin(particleAngle) * radius
                    );
                    const velocity = new THREE.Vector3(
                        Math.cos(particleAngle) * 0.5,
                        2,
                        Math.sin(particleAngle) * 0.5
                    );
                    createParticle(pos, velocity, 0x88ff88, 0.1, 0.3);
                }
                
                setTimeout(() => requestAnimationFrame(animate), 50);
            };
            animate();
        }

        // DRUID - Barkskin (bark armor)
        function createBarkskinEffect(character) {
            // Check if already has effect
            if (character.getObjectByName('barkskin-effect')) return;

            const barkGeo = new THREE.SphereGeometry(1.1, 12, 12);
            const barkMat = new THREE.MeshStandardMaterial({
                color: 0x8b6f47,
                transparent: true,
                opacity: 0.3,
                roughness: 0.9,
                metalness: 0.1
            });
            const barkShield = new THREE.Mesh(barkGeo, barkMat);
            barkShield.name = 'barkskin-effect';
            barkShield.position.set(0, 1.5, 0);
            character.add(barkShield);
            
            const animate = () => {
                const hasAura = character.userData.auras && character.userData.auras.some(a => a.name === 'Barkskin');
                if (!character.parent || character.userData.health <= 0 || !hasAura || !gameState.inMatch) {
                    character.remove(barkShield);
                    barkGeo.dispose();
                    barkMat.dispose();
                    return;
                }
                
                barkShield.rotation.y += 0.01;
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        // DEATH KNIGHT - Anti-Magic Shell / PALADIN - Divine Shield
        function createAMSEffect(character) {
            // Check if already has effect to avoid stacking
            if (character.getObjectByName('ams-effect')) return;

            const auraName = character.userData.auras.some(a => a.name === 'Divine Shield') ? 'Divine Shield' : 'Anti-Magic Shell';
            const color = auraName === 'Divine Shield' ? 0xffd700 : 0x00ff00;

            const amsGeo = new THREE.SphereGeometry(1.2, 16, 16);
            const amsMat = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                wireframe: true,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const amsShield = new THREE.Mesh(amsGeo, amsMat);
            amsShield.name = 'ams-effect';
            amsShield.position.set(0, 1.5, 0); // Center on character
            character.add(amsShield);
            
            const animate = () => {
                // Check if character is still valid and has the aura
                const hasAura = character.userData.auras && character.userData.auras.some(a => a.name === auraName);
                if (!character.parent || character.userData.health <= 0 || !hasAura || !gameState.inMatch) {
                    character.remove(amsShield);
                    amsGeo.dispose();
                    amsMat.dispose();
                    return;
                }
                
                amsShield.rotation.y += 0.02;
                amsShield.rotation.z += 0.01;
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        // ============================================
        // CLASS-SPECIFIC VISUAL BUFF EFFECTS
        // ============================================
        
        function createAvengingWrathEffect(character) {
            const group = new THREE.Group();
            group.userData.isBuffEffect = true;
            group.userData.auraName = 'Avenging Wrath';
            character.add(group);

            // Gold Wings
            const wingGeo = new THREE.PlaneGeometry(1.5, 3);
            const wingMat = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.set(-0.8, 1.8, -0.4);
            leftWing.rotation.y = Math.PI / 4;
            leftWing.rotation.z = -Math.PI / 6;
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.set(0.8, 1.8, -0.4);
            rightWing.rotation.y = -Math.PI / 4;
            rightWing.rotation.z = Math.PI / 6;
            group.add(rightWing);

            // Halo
            const haloGeo = new THREE.TorusGeometry(0.4, 0.05, 8, 32);
            const haloMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.position.y = 2.6;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);

            // Animation logic
            const startTime = performance.now();
            const duration = 20000; // 20s default

            const animate = () => {
                if (!group.parent || !character.userData.auras.some(a => a.name === 'Avenging Wrath')) {
                    character.remove(group);
                    wingGeo.dispose();
                    wingMat.dispose();
                    haloGeo.dispose();
                    haloMat.dispose();
                    return;
                }

                const elapsed = performance.now() - startTime;
                const wave = Math.sin(elapsed * 0.005);
                leftWing.rotation.y = Math.PI / 4 + wave * 0.2;
                rightWing.rotation.y = -Math.PI / 4 - wave * 0.2;
                halo.position.y = 2.6 + wave * 0.05;
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        function createCloakOfShadowsEffect(character) {
            const group = new THREE.Group();
            group.userData.isBuffEffect = true;
            group.userData.auraName = 'Cloak of Shadows';
            character.add(group);

            const shadowGeo = new THREE.SphereGeometry(1.1, 16, 16);
            const shadowMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.5,
                blending: THREE.MultiplyBlending
            });
            const shroud = new THREE.Mesh(shadowGeo, shadowMat);
            shroud.position.y = 1.2;
            group.add(shroud);

            const animate = () => {
                if (!group.parent || !character.userData.auras.some(a => a.name === 'Cloak of Shadows')) {
                    character.remove(group);
                    shadowGeo.dispose();
                    shadowMat.dispose();
                    return;
                }

                if (Math.random() > 0.7) {
                    const pos = character.position.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 1.5,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 1.5
                    ));
                    createParticle(pos, new THREE.Vector3(0, 0.5, 0), 0x330066, 0.1, 0.5);
                }

                requestAnimationFrame(animate);
            };
            animate();
        }

        function createPowerInfusionEffect(character) {
            const group = new THREE.Group();
            group.userData.isBuffEffect = true;
            group.userData.auraName = 'Power Infusion';
            character.add(group);

            const glowGeo = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 16, 1, true);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = 1.25;
            group.add(glow);

            const animate = () => {
                if (!group.parent || !character.userData.auras.some(a => a.name === 'Power Infusion')) {
                    character.remove(group);
                    glowGeo.dispose();
                    glowMat.dispose();
                    return;
                }

                glow.rotation.y += 0.05;
                glowMat.opacity = 0.2 + Math.sin(performance.now() * 0.01) * 0.1;
                
                requestAnimationFrame(animate);
            };
            animate();
        }

        function createFelLockLine(start, end) {
            const points = [
                new THREE.Vector3(start.x, start.y + 0.5, start.z),
                new THREE.Vector3(end.x, end.y + 1.5, end.z)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x32ff00, // Fel Green
                transparent: true,
                opacity: 1.0,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // Animate fade out
            const startTime = performance.now();
            const duration = 500; // 0.5s

            const animateLine = (time) => {
                const elapsed = time - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    scene.remove(line);
                    geometry.dispose();
                    material.dispose();
                } else {
                    material.opacity = 1 - progress;
                    requestAnimationFrame(animateLine);
                }
            };
            requestAnimationFrame(animateLine);
        }

        function createAbilityEffect(position, color) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity: 0.8
            });
            const effect = new THREE.Mesh(geometry, material);
            effect.position.copy(position);
            effect.position.y += 1;
            scene.add(effect);

            // Animate and remove
            let scale = 1;
            const animateEffect = () => {
                scale += 0.1;
                effect.scale.setScalar(scale);
                material.opacity -= 0.05;
                
                if (material.opacity <= 0) {
                    scene.remove(effect);
                } else {
                    requestAnimationFrame(animateEffect);
                }
            };
            animateEffect();
        }

        function showDamageNumber(position, amount, isHeal = false, isCrit = false, isCC = false) {
            const div = document.createElement('div');
            
            // Apply base class and special classes
            let classList = ['damage-number'];
            if (isHeal) classList.push('heal');
            if (isCrit) classList.push('crit');
            if (isCC) classList.push('cc');
            div.className = classList.join(' ');
            
            // Set content
            if (isCC) {
                div.textContent = amount;
            } else if (typeof amount === 'number') {
                div.textContent = Math.round(amount) + (isCrit ? '!' : '');
            } else {
                div.textContent = amount;
            }
            
            document.getElementById('ui-overlay').appendChild(div);

            // Project 3D position to 2D screen
            const vector = position.clone();
            vector.y += 2.5; // Offset above character head
            
            // Add slight random horizontal offset to prevent stacking
            const randomXOffset = (Math.random() - 0.5) * 60;
            const randomYOffset = (Math.random() - 0.5) * 40;

            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth + randomXOffset;
            const y = (-(vector.y) * 0.5 + 0.5) * window.innerHeight + randomYOffset;
            
            div.style.left = x + 'px';
            div.style.top = y + 'px';

            // Use the CSS animations defined earlier
            div.style.animation = isCrit ? 'critPop 1s ease-out forwards' : 'damageFloat 1s ease-out forwards';

            setTimeout(() => div.remove(), 1000);
        }

        function showMatchReview(victory) {
            const modal = document.getElementById('match-review-modal');
            const resultText = document.getElementById('review-result');
            const timerText = document.getElementById('review-timer');
            
            resultText.textContent = victory ? 'VICTORY' : 'DEFEAT';
            resultText.style.color = victory ? '#ffd700' : '#ff4444';
            timerText.textContent = `Time: ${gameState.matchTime.toFixed(1)}s`;
            
            document.getElementById('review-damage-dealt').textContent = Math.round(gameState.matchStats.damageDealt).toLocaleString();
            document.getElementById('review-healing-done').textContent = Math.round(gameState.matchStats.healingDone).toLocaleString();
            document.getElementById('review-cc-chains').textContent = gameState.matchStats.ccChains;
            document.getElementById('review-los-damage').textContent = Math.round(gameState.matchStats.losDamage).toLocaleString();
            
            // Mana efficiency
            const manaEff = gameState.matchStats.manaUsed > 0 ? 
                            Math.round((gameState.matchStats.healingDone / gameState.matchStats.manaUsed) * 100) : 100;
            document.getElementById('review-mana-eff').textContent = `${manaEff}%`;

            // New stats: Absorbed and Buff Uptime
            document.getElementById('review-absorbed').textContent = Math.round(gameState.matchStats.damageAbsorbed || 0).toLocaleString();
            
            // Buff uptime percentage (average across 3 team members)
            const buffUptimePct = gameState.matchTime > 0 ? 
                                 Math.round((gameState.matchStats.buffUptime / (gameState.matchTime * 3)) * 100) : 0;
            document.getElementById('review-buff-uptime').textContent = `${Math.min(100, buffUptimePct)}%`;
            
            // Pet contribution stats
            const petStatsDiv = document.getElementById('review-pet-stats');
            if (petStatsDiv) {
                // Sum up pet damage/kills from ally pets
                let totalPetDmg = 0;
                let totalPetKills = 0;
                gameState.team.forEach(unit => {
                    if (unit.userData && unit.userData.isPet) {
                        totalPetDmg += unit.userData.totalDamageDealt || 0;
                        totalPetKills += unit.userData.killCount || 0;
                    }
                });
                
                if (totalPetDmg > 0) {
                    petStatsDiv.style.display = 'block';
                    document.getElementById('review-pet-damage').textContent = Math.round(totalPetDmg).toLocaleString();
                    document.getElementById('review-pet-kills').textContent = totalPetKills;
                    
                    // Aggregate avoidance stats from all ally pets
                    let totalAvoided = 0, totalBlocked = 0, totalRedirected = 0, highestHit = 0;
                    gameState.team.forEach(unit => {
                        if (unit.userData && unit.userData.isPet) {
                            totalAvoided += unit.userData.totalDamageAvoided || 0;
                            totalBlocked += unit.userData.totalDamageBlocked || 0;
                            totalRedirected += unit.userData.totalDamageRedirected || 0;
                            highestHit = Math.max(highestHit, unit.userData.highestHit || 0);
                        }
                    });
                    
                    const fmtNum = (n) => n >= 1000 ? `${(n/1000).toFixed(1)}k` : Math.round(n).toLocaleString();
                    document.getElementById('review-pet-avoided').textContent = fmtNum(totalAvoided);
                    document.getElementById('review-pet-blocked').textContent = fmtNum(totalBlocked);
                    document.getElementById('review-pet-highest').textContent = fmtNum(highestHit);
                    
                    // Soul Link redirect only shows for warlock pets
                    const redirectRow = document.getElementById('review-pet-redirect-row');
                    if (totalRedirected > 0 && redirectRow) {
                        redirectRow.style.display = '';
                        document.getElementById('review-pet-redirected').textContent = fmtNum(totalRedirected);
                    } else if (redirectRow) {
                        redirectRow.style.display = 'none';
                    }
                    
                    // Update icon based on pet type
                    const petTypeIcon = gameState.team.some(u => u.userData?.petType === 'warlock_pet') ? 'üëπ' : 'üê∫';
                    const petLabel = petStatsDiv.querySelector('div:first-child');
                    if (petLabel) {
                        const petName = gameState.team.find(u => u.userData?.isPet)?.userData?.petName || 'Pet';
                        petLabel.textContent = `${petTypeIcon} ${petName} Contribution`;
                    }
                } else {
                    petStatsDiv.style.display = 'none';
                }
            }
            
            // Show prestige button in review modal when at Gladiator rating
            const prestigeContainer = document.getElementById('review-prestige-container');
            if (prestigeContainer) {
                if (gameState.arenaRating >= CONFIG.prestigeRequirement) {
                    prestigeContainer.style.display = 'block';
                } else {
                    prestigeContainer.style.display = 'none';
                }
            }
            
            modal.style.display = 'flex';
        }

        function endMatch(victory) {
            gameState.inMatch = false;

            if (victory) {
                soundManager.playWin();
                gameState.wins++;
                gameState.lifetimeWins = (gameState.lifetimeWins || 0) + 1;
                gameState.winStreak++;
                gameState.longestWinStreak = Math.max(gameState.longestWinStreak, gameState.winStreak);
                
                // Honor gains with bonuses + conquest elite status
                const honorBonus = 1 + (gameState.upgrades.honorBonus * 0.15);
                const eliteBonus = 1 + (gameState.conquestUpgrades.conquest_honor_boost || 0) * 0.25;
                const honorGained = Math.floor(CONFIG.baseHonorPerWin * honorBonus * eliteBonus);
                gameState.honor += honorGained;
                
                // Show floating honor reward
                setTimeout(() => showFloatingCurrency(honorGained, 'honor'), 500);
                
                // Conquest points (Balance-capped currency)
                const conquestGain = 25;
                const conquestCanEarn = Math.min(conquestGain, gameState.conquestCap - gameState.conquestPoints);
                if (conquestCanEarn > 0) {
                    gameState.conquestPoints += conquestCanEarn;
                    
                    // Show floating conquest reward
                    setTimeout(() => showFloatingCurrency(conquestCanEarn, 'conquest'), 700);
                }
                
                // Calculate arena rating change using WoW-style MMR system
                const enemyCount = gameState.enemies.length || 1;
                const avgEnemyMMR = gameState.enemies.reduce((sum, e) => 
                    sum + (e.userData.enemyMMR || gameState.arenaRating), 0) / enemyCount;
                
                const ratingChange = calculateRatingChange(gameState.arenaRating || 0, avgEnemyMMR || 0, true);
                updateArenaRating(ratingChange);
                gameState.peakRating = Math.max(gameState.peakRating || 0, gameState.arenaRating);
                updateArenaTitle();
                checkRosterUnlocks();
                
                addCombatLog(`Opponent Team Rating: ${Math.round(avgEnemyMMR)} | Rating Change: +${ratingChange}`, 'buff');
                
                let streakBonus = '';
                if (gameState.winStreak >= 3) {
                    const extraHonor = Math.floor(50 * (gameState.winStreak / 3));
                    gameState.honor += extraHonor;
                    streakBonus = ` | ${gameState.winStreak}-Win Streak! +${extraHonor} Bonus Honor`;
                    setTimeout(() => showFloatingCurrency(extraHonor, 'honor'), 1000);
                }
                
                showArenaAnnouncement('VICTORY!', 2000);
                addCombatLog(`=== VICTORY! +${honorGained} Honor, +${conquestCanEarn} Conquest${streakBonus} ===`, 'buff');
            } else {
                soundManager.playLoss();
                gameState.losses++;
                gameState.lifetimeLosses = (gameState.lifetimeLosses || 0) + 1;
                gameState.winStreak = 0; // Break streak
                
                const honorBonus = 1 + (gameState.upgrades.honorBonus * 0.15);
                const honorGained = Math.floor(CONFIG.baseHonorPerLoss * honorBonus);
                gameState.honor += honorGained;
                setTimeout(() => showFloatingCurrency(honorGained, 'honor'), 500);
                
                const enemyCount = gameState.enemies.length || 1;
                const avgEnemyMMR = gameState.enemies.reduce((sum, e) => 
                    sum + (e.userData.enemyMMR || gameState.arenaRating), 0) / enemyCount;
                
                let ratingChange = calculateRatingChange(gameState.arenaRating || 0, avgEnemyMMR || 0, false);
                const ratingProtection = (gameState.conquestUpgrades.conquest_rating_protection || 0) * 0.2;
                if (ratingChange < 0) {
                    ratingChange = Math.floor(ratingChange * (1 - ratingProtection));
                }
                
                updateArenaRating(ratingChange);
                gameState.peakRating = Math.max(gameState.peakRating || 0, gameState.arenaRating);
                updateArenaTitle();
                
                const ratingText = ratingChange >= 0 ? `+${ratingChange}` : ratingChange;
                addCombatLog(`Opponent Team Rating: ${Math.round(avgEnemyMMR)} | Rating Change: ${ratingText}`, 'error');
                
                showArenaAnnouncement('DEFEAT', 2000);
                addCombatLog(`=== DEFEAT - +${honorGained} Honor (Streak Broken) ===`, 'death');
            }

            updateUI();
            
            // Record to history
            const historyEntry = {
                id: Date.now(),
                victory: victory,
                time: gameState.matchTime,
                rating: gameState.arenaRating,
                damage: gameState.matchStats.damageDealt,
                healing: gameState.matchStats.healingDone,
                cc: gameState.matchStats.ccChains,
                date: new Date().toLocaleTimeString()
            };
            if (!gameState.seasonHistory) gameState.seasonHistory = [];
            gameState.seasonHistory.unshift(historyEntry);
            if (gameState.seasonHistory.length > 20) gameState.seasonHistory.pop();

            // Show match review instead of auto-restarting immediately
            showMatchReview(victory);
            
            // If player just hit Gladiator, DON'T auto-continue - let them prestige
            const canPrestige = gameState.arenaRating >= CONFIG.prestigeRequirement;
            
            if (canPrestige) {
                // No auto-timer - player decides: Prestige or Continue
                gameState.reviewTimer = null;
            } else {
                // Auto-continue after 5 seconds if modal is open
                gameState.reviewTimer = setTimeout(() => {
                    const modal = document.getElementById('match-review-modal');
                    if (modal.style.display === 'flex') {
                        modal.style.display = 'none';
                        startNewMatch();
                    }
                }, 5000);
            }
        }
        
        function updateArenaTitle() {
            const rating = gameState.arenaRating;
            let newTitle = 'Combatant';
            
            if (rating >= 3000) newTitle = 'Legend';
            else if (rating >= 2400) newTitle = 'Gladiator';
            else if (rating >= 2200) newTitle = 'Duelist';
            else if (rating >= 2000) newTitle = 'Rival';
            else if (rating >= 1800) newTitle = 'Challenger';
            else if (rating >= 1600) newTitle = 'Competitor';
            
            if (gameState.arenaTitle !== newTitle) {
                const oldTitle = gameState.arenaTitle;
                gameState.arenaTitle = newTitle;
                showArenaAnnouncement(`Title Earned: ${newTitle}!`, 3000);
                addCombatLog(`üèÜ You have earned the title: ${newTitle}!`, 'buff');
            }
        }

        // ============================================
        // COMBAT LOG & ARENA ANNOUNCEMENTS
        // ============================================
        function addCombatLog(message, type = 'damage') {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${gameState.matchTime.toFixed(1)}s] ${message}`;
            log.appendChild(entry);
            
            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }
        
        function applyAura(target, name, duration, type = 'buff') {
            if (!target || !target.userData || !target.userData.auras) return;
            
            // Check if aura already exists
            const existing = target.userData.auras.find(a => a.name === name);
            const icon = AURA_ICONS[name] || AURA_ICONS['Stun']; // Fallback icon

            if (existing) {
                existing.duration = duration;
                existing.maxDuration = duration;
            } else {
                target.userData.auras.push({
                    name,
                    icon,
                    duration,
                    maxDuration: duration,
                    type
                });

                // TRIGGER VISUAL EFFECTS FOR NEW AURAS
                if (name === 'Avenging Wrath') createAvengingWrathEffect(target);
                if (name === 'Cloak of Shadows') createCloakOfShadowsEffect(target);
                if (name === 'Power Infusion') createPowerInfusionEffect(target);
                if (name === 'Ice Block') createIceBlockEffect(target);
                if (name === 'Divine Shield') createAMSEffect(target); // Reuse AMS-like glow for bubble
                if (name === 'Bestial Wrath') createCombustionEffect(target); // Reuse red glow
                if (name === 'Metamorphosis') createCombustionEffect(target);
                if (name === 'Anti-Magic Shell') createAMSEffect(target);
                if (name === 'Barkskin') createBarkskinEffect(target);
                if (name === 'Polymorph') createPolymorphEffect(target.position);
                if (name === 'Cyclone') createCycloneEffect(target.position);
                if (name === 'Freezing Trap') createFreezingTrapEffect(target.position);
            }

            // Sync with legacy logic flags if needed
            if (name === 'Mortal Strike' || name === 'Healing Reduction') {
                target.userData.healingReduction = 0.5;
            }
            if (name === 'Metamorphosis' || name === 'Bestial Wrath') {
                target.userData.buffUntil = performance.now() + duration * 1000;
                target.userData.buffType = 'damageBuff';
            }
            if (name === 'Ice Block' || name === 'Divine Shield') {
                target.userData.ccUntil = duration;
                target.userData.ccType = 'invulnerable';
            }
        }

        function showArenaAnnouncement(message, duration = 2000) {
            const announcement = document.getElementById('arena-announcement');
            announcement.textContent = message;
            announcement.classList.add('show');
            
            setTimeout(() => {
                announcement.classList.remove('show');
            }, duration);
        }
        
        function showFloatingCurrency(amount, type = 'honor', targetElement = null) {
            const floater = document.createElement('div');
            floater.className = `floating-currency floating-${type}`;
            
            // Format with + sign and icon (using shield for honor to distinguish from gold)
            const icon = type === 'honor' ? 'üõ°Ô∏è' : '‚öîÔ∏è';
            floater.textContent = `+${amount} ${icon}`;
            
            // Position near the target currency display in top bar
            if (!targetElement) {
                targetElement = document.getElementById(`${type}-amount`);
            }
            
            const rect = targetElement.getBoundingClientRect();
            floater.style.left = `${rect.left + rect.width / 2}px`;
            floater.style.top = `${rect.top}px`;
            floater.style.transform = 'translateX(-50%)';
            
            document.body.appendChild(floater);
            
            // Remove after animation
            setTimeout(() => {
                floater.remove();
            }, 2000);
        }
        
        function updateArenaRating(change) {
            if (isNaN(change)) change = 0;
            if (isNaN(gameState.arenaRating)) gameState.arenaRating = 0;
            
            const oldRating = gameState.arenaRating;
            gameState.arenaRating = Math.max(0, gameState.arenaRating + change);
            
            const ratingDisplay = document.getElementById('arena-rating');
            const currentRatingEl = document.getElementById('current-rating');
            const ratingChangeEl = document.getElementById('rating-change');
            
            currentRatingEl.textContent = Math.floor(gameState.arenaRating);
            
            if (change !== 0) {
                ratingChangeEl.textContent = change > 0 ? `+${change}` : `${change}`;
                ratingChangeEl.className = change > 0 ? 'rating-change rating-up' : 'rating-change rating-down';
                ratingDisplay.style.display = 'block';
                
                setTimeout(() => {
                    ratingChangeEl.textContent = '';
                    setTimeout(() => {
                        ratingDisplay.style.display = 'none';
                    }, 1000);
                }, 3000);
            }
        }

        // ============================================
        // UI SYSTEM
        // ============================================
        // Standalone gear count updater ‚Äî can be called from anywhere safely
        function updateGearCountDisplay() {
            const el = document.getElementById('gear-count');
            if (!el) return;
            
            let count = 0;
            const g = gameState.equippedGear;
            // Guard: if equippedGear doesn't exist or isn't an object, count is 0
            if (g && typeof g === 'object') {
                const slots = ['weapon','head','shoulders','chest','hands','legs','trinket1','trinket2','enchant'];
                for (let i = 0; i < slots.length; i++) {
                    const v = g[slots[i]];
                    // Only count truthy strings that aren't the literal words "null"/"undefined"
                    if (v && typeof v === 'string' && v !== 'null' && v !== 'undefined') {
                        count++;
                    }
                }
            }
            
            el.textContent = count + '/9';
            el.style.color = count === 0 ? '#888' : (count >= 9 ? '#a335ee' : '#00ff00');
        }

        function updateUI() {
          try {
            const honorText = Math.floor(gameState.honor).toLocaleString();
            const conquestText = Math.floor(gameState.conquestPoints);
            const ratingText = Math.floor(gameState.arenaRating);
            const winText = gameState.wins;
            const lossText = gameState.losses;
            const winrateText = (gameState.wins + gameState.losses > 0) ? 
                Math.round((gameState.wins / (gameState.wins + gameState.losses)) * 100) + '%' : '0%';

            document.getElementById('honor-amount').textContent = honorText;
            document.getElementById('conquest-amount').textContent = conquestText;
            document.getElementById('conquest-cap').textContent = gameState.conquestCap;
            document.getElementById('arena-rating-amount').textContent = ratingText;
            document.getElementById('arena-title').textContent = gameState.arenaTitle || 'Combatant';
            document.getElementById('wins').textContent = winText;
            document.getElementById('losses').textContent = lossText;
            document.getElementById('winrate').textContent = winrateText;
            document.getElementById('win-streak').textContent = gameState.winStreak;
            document.getElementById('best-streak').textContent = gameState.longestWinStreak;
            
            // Talent tree button notification
            const talentBtn = document.getElementById('talent-tree-btn');
            if (talentBtn) {
                if (gameState.talentPoints > 0) {
                    talentBtn.classList.add('shop-available');
                    talentBtn.textContent = `üåü Career Talents (${gameState.talentPoints})`;
                    talentBtn.style.boxShadow = '0 0 15px #ffd700';
                } else {
                    talentBtn.classList.remove('shop-available');
                    talentBtn.textContent = `üåü Career Talents`;
                    talentBtn.style.boxShadow = 'none';
                }
            }
            
            const prestigeBtn = document.getElementById('prestige-btn');
            const mPrestigeBtn = document.getElementById('m-btn-prestige');
            
            if (prestigeBtn) {
                prestigeBtn.style.display = 'block'; // Always show on desktop side panel
                if (gameState.arenaRating >= CONFIG.prestigeRequirement) {
                    const prestigeText = "üèÜ Start New Season (Gladiator Prestige!)";
                    prestigeBtn.classList.remove('disabled');
                    prestigeBtn.classList.add('shop-available');
                    prestigeBtn.textContent = prestigeText;
                    prestigeBtn.style.background = 'linear-gradient(180deg, #ffd700, #b8860b)';
                    prestigeBtn.style.color = '#000';
                    prestigeBtn.style.animation = 'shopPulse 2s ease-in-out infinite';
                    if (mPrestigeBtn) {
                        mPrestigeBtn.classList.remove('disabled');
                        mPrestigeBtn.classList.add('shop-available');
                        mPrestigeBtn.textContent = prestigeText;
                        mPrestigeBtn.style.background = 'linear-gradient(180deg, #ffd700, #b8860b)';
                        mPrestigeBtn.style.color = '#000';
                        mPrestigeBtn.style.animation = 'shopPulse 2s ease-in-out infinite';
                    }
                } else {
                    const prestigeReqText = `Start New Season (Reach ${CONFIG.prestigeRequirement} Rating)`;
                    prestigeBtn.classList.add('disabled');
                    prestigeBtn.classList.remove('shop-available');
                    prestigeBtn.textContent = prestigeReqText;
                    prestigeBtn.style.background = '#444';
                    prestigeBtn.style.color = '';
                    prestigeBtn.style.animation = 'none';
                    if (mPrestigeBtn) {
                        mPrestigeBtn.classList.add('disabled');
                        mPrestigeBtn.classList.remove('shop-available');
                        mPrestigeBtn.textContent = prestigeReqText;
                        mPrestigeBtn.style.background = '';
                        mPrestigeBtn.style.color = '';
                        mPrestigeBtn.style.animation = 'none';
                    }
                }
            }

            // Sync mobile stats
            const mRating = document.getElementById('m-stat-rating');
            if (mRating) {
                mRating.textContent = ratingText;
                document.getElementById('m-stat-wins').textContent = winText;
                document.getElementById('m-stat-losses').textContent = lossText;
                document.getElementById('m-stat-winrate').textContent = winrateText;
            }

            const honorBonus = 1 + ((gameState.upgrades.honorBonus || 0) * 0.15);
            const eliteBonus = 1 + ((gameState.conquestUpgrades.conquest_honor_boost || 0) * 0.25);
            document.getElementById('honor-per-win').textContent = Math.round(CONFIG.baseHonorPerWin * honorBonus * eliteBonus);
            document.getElementById('match-speed').textContent = (1 + (gameState.upgrades.matchSpeed || 0) * 0.08).toFixed(1) + 'x';
          } catch(e) { console.error('updateUI header error:', e); }
            
          // ---- GEAR COUNT (isolated in its own try/catch so nothing can prevent it) ----
          try {
            updateGearCountDisplay();
          } catch(e) { console.error('updateUI gear count error:', e); }
          
          try {
            const strategyEl = document.getElementById('strategy-preset');
            if (strategyEl) strategyEl.value = gameState.teamDoctrine || 'balanced';
            
            // Check if player can afford any gear items
            const allGear = [...PVP_GEAR.weapons, ...PVP_GEAR.armor, ...PVP_GEAR.trinkets];
            const canAffordAny = allGear.some(item => {
                const isEquipped = Object.values(gameState.equippedGear || {}).includes(item.id);
                return !isEquipped && gameState.honor >= item.cost && gameState.arenaRating >= item.ratingRequired;
            });
            
            const shopBtn = document.getElementById('honor-shop-btn');
            const mShopBtn = document.getElementById('m-btn-shop');
            if (canAffordAny) {
                shopBtn.classList.add('shop-available');
                if (mShopBtn) mShopBtn.classList.add('shop-available');
            } else {
                shopBtn.classList.remove('shop-available');
                if (mShopBtn) mShopBtn.classList.remove('shop-available');
            }

            // Render upgrades logic...
            renderUpgrades();

            // Handle Forfeit Buttons Visibility
            const forfeitBtn = document.getElementById('forfeit-btn');
            const mForfeitBtn = document.getElementById('m-btn-forfeit');
            const isMatchActive = gameState.inMatch;
            
            if (forfeitBtn) {
                forfeitBtn.style.display = isMatchActive ? 'block' : 'none';
            }
            if (mForfeitBtn) {
                mForfeitBtn.style.display = isMatchActive ? 'block' : 'none';
            }
          } catch(e) { console.error('updateUI footer error:', e); }
        }

        function renderUpgrades() {
            const containers = [
                document.getElementById('upgrades-container'),
                document.getElementById('mobile-upgrades-container')
            ];
            
            containers.forEach(container => {
                if (!container) return;
                container.innerHTML = '';

                UPGRADES.forEach(upgrade => {
                    const level = gameState.upgrades[upgrade.id];
                    const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, level));
                    const canAfford = gameState.honor >= cost;

                    const item = document.createElement('div');
                    item.className = `upgrade-item ${canAfford ? '' : 'disabled'}`;
                    item.innerHTML = `
                        <img src="${upgrade.icon}" class="upgrade-icon-img" alt="${upgrade.name}">
                        <div class="upgrade-info">
                            <div class="upgrade-name">${upgrade.name}</div>
                            <div class="upgrade-desc">${upgrade.desc}</div>
                            <div class="upgrade-cost-row">
                                <span class="upgrade-cost">
                                    <img src="https://rosebud.ai/assets/honor-token.webp?Aozw" style="width:14px;height:14px;">
                                    ${cost.toLocaleString()}
                                </span>
                                <span class="upgrade-level">Lv. ${level}</span>
                            </div>
                        </div>
                    `;

                    item.onclick = () => {
                        if (gameState.honor >= cost) {
                            gameState.honor -= cost;
                            gameState.upgrades[upgrade.id]++;
                            updateUI();
                            soundManager.playClick();
                        }
                    };

                    container.appendChild(item);
                });
            });
        }

        function updateMatchUI() {
            document.getElementById('match-number').textContent = gameState.matchNumber;
            document.getElementById('match-timer').textContent = gameState.matchTime.toFixed(1);

            const teamHealth = document.getElementById('team-health');
            const enemyHealth = document.getElementById('enemy-health');

            const renderTeam = (units, container) => {
                container.innerHTML = '';
                units.forEach(unit => {
                    const userData = unit.userData;
                    const hpPercent = (userData.health / userData.maxHealth) * 100;
                    const manaPercent = userData.maxMana > 0 ? (userData.mana / userData.maxMana) * 100 : 0;
                    
                    const isPet = userData.isPet;
                    const petIcon = userData.petType === 'hunter_pet' ? 'üê∫' : userData.petType === 'warlock_pet' ? 'üëπ' : 'üêæ';
                    const name = isPet ? (userData.petName || 'Pet') : (userData.classData?.name || 'Unknown');
                    const icon = isPet ? petIcon : `<img src="${CLASS_ICONS[userData.classType]}" style="width:14px;height:14px;border-radius:2px;">`;
                    
                    const indicator = document.createElement('div');
                    indicator.className = `health-indicator ${isPet ? 'pet-hud-indicator' : ''}`;
                    
                    // Apply smaller styling for pets ‚Äî sub-unit indented under owner
                    if (isPet) {
                        indicator.style.transform = 'scale(0.8)';
                        indicator.style.transformOrigin = 'left center';
                        indicator.style.opacity = hpPercent < 25 ? '0.9' : '0.75';
                        indicator.style.marginTop = '-10px';
                        indicator.style.marginLeft = '10px';
                        indicator.style.borderLeft = `2px solid ${hpPercent < 25 ? 'rgba(255,80,80,0.5)' : 'rgba(255,255,255,0.2)'}`;
                        indicator.style.paddingLeft = '5px';
                    }
                    
                    // Pet HP color coding for HUD bar
                    let petBarColor = 'linear-gradient(180deg, #55ff55, #008800)';
                    if (isPet) {
                        if (hpPercent < 25) petBarColor = 'linear-gradient(180deg, #ff4444, #880000)';
                        else if (hpPercent < 50) petBarColor = 'linear-gradient(180deg, #ffcc00, #886600)';
                    }
                    
                    // Format HP display
                    const hpDisplay = isPet 
                        ? `${Math.round(hpPercent)}%` 
                        : Math.ceil(userData.health).toLocaleString();

                    indicator.innerHTML = `
                        <div class="unit-label" style="${isPet ? 'font-size: 9px; margin-bottom: 2px;' : ''}">
                            <span style="display: flex; align-items: center; gap: 4px;">
                                ${icon}
                                ${name}
                                ${isPet && userData.ccUntil > 0 ? '<span style="color:#ffaa00;font-size:8px;">CC</span>' : ''}
                            </span>
                            <span>${hpDisplay}</span>
                        </div>
                        <div class="health-bar" style="${isPet ? 'height: 5px;' : ''}">
                            <div class="health-fill ${userData.classType || ''}" style="width: ${hpPercent}%; ${isPet ? `background: ${petBarColor};` : ''}${isPet && hpPercent < 25 ? 'animation: petHpPulse 0.6s ease-in-out infinite;' : ''}"></div>
                        </div>
                    `;

                    if (!isPet && userData.maxMana > 0) {
                        const manaBar = document.createElement('div');
                        manaBar.className = 'mana-bar';
                        const isLowMana = manaPercent < 15 && userData.classData?.role === 'healer';
                        const pulseStyle = isLowMana && (Math.sin(Date.now() * 0.01) > 0) ? 'opacity: 0.6; filter: brightness(1.5);' : '';
                        
                        manaBar.innerHTML = `<div class="mana-fill" style="width: ${manaPercent}%; ${pulseStyle}"></div>`;
                        indicator.appendChild(manaBar);
                    }
                    container.appendChild(indicator);
                });
            };

            renderTeam(gameState.team, teamHealth);
            renderTeam(gameState.enemies, enemyHealth);
        }

        function updateHealthBars() {
            updateMatchUI();
        }
        // Redundant UI functions removed. Using updateMatchUI instead.
        function doPrestige() {
            if (gameState.arenaRating < CONFIG.prestigeRequirement) return;

            // Grant Conquest Points (Gladiator Medallions)
            const pointsEarned = 500;
            gameState.conquestPoints += pointsEarned;
            
            // Grant Talent Point & Increment Prestige
            gameState.prestigeLevel++;
            gameState.talentPoints++;

            // Add a season record to history
            const seasonSummary = {
                type: 'Prestige Reset',
                rating: Math.floor(gameState.arenaRating),
                wins: gameState.wins,
                losses: gameState.losses,
                conquestEarned: pointsEarned,
                talentPointsEarned: 1,
                prestigeLevel: gameState.prestigeLevel,
                timestamp: new Date().toLocaleDateString()
            };
            
            // Push to career history
            if (!gameState.seasonHistory) gameState.seasonHistory = [];
            gameState.seasonHistory.unshift(seasonSummary);

            // Show Prestige Celebration via arena announcement (no alert() which can be blocked)
            showArenaAnnouncement(`üèÜ GLADIATOR PRESTIGE ${gameState.prestigeLevel}!`, 4000);
            addCombatLog(`üèÜ GLADIATOR PRESTIGE REACHED! Level ${gameState.prestigeLevel} ‚Äî +1 Talent Point, +${pointsEarned} Conquest!`, 'buff');
            addCombatLog(`Rating & Upgrades reset. Career Talents persist!`, 'buff');
            soundManager.playWin();

            // Reset for new season, only career talents and conquest points persist
            gameState.honor = 0;
            gameState.arenaRating = 0;
            gameState.wins = 0;
            gameState.losses = 0;
            gameState.matchNumber = 0;
            gameState.winStreak = 0;
            gameState.arenaTitle = 'Combatant';

            // Ensure all gear is properly cleared ‚Äî log before/after for debugging
            console.log('üîÑ PRESTIGE: Gear BEFORE clear:', JSON.stringify(gameState.equippedGear));
            gameState.equippedGear = {
                weapon: null,
                head: null,
                shoulders: null,
                chest: null,
                hands: null,
                legs: null,
                trinket1: null,
                trinket2: null,
                enchant: null
            };
            console.log('üîÑ PRESTIGE: Gear AFTER clear:', JSON.stringify(gameState.equippedGear));
            
            // IMMEDIATELY update gear count display ‚Äî don't wait for updateUI
            updateGearCountDisplay();

            // Reset conquest upgrades (only career talents stay)
            gameState.conquestUpgrades = {
                conquest_weapon_upgrade: 0,
                conquest_armor_upgrade: 0,
                conquest_versatility: 0,
                conquest_mastery: 0,
                conquest_tenacity: 0,
                conquest_swiftness: 0,
                conquest_honor_boost: 0,
                conquest_rating_protection: 0
            };

            // Reset all upgrades on prestige
            gameState.upgrades = {
                damage: 0,
                health: 0,
                resilience: 0,
                healingPower: 0,
                ccDuration: 0,
                cooldownReduction: 0,
                critChance: 0,
                manaRegen: 0,
                honorBonus: 0,
                matchSpeed: 0
            };

            saveGame();
            updateUI();
            
            // Close any open modals before starting fresh
            document.getElementById('match-review-modal').style.display = 'none';

            startNewMatch();
        }

        // ============================================
        // WOW-STYLE ARENA RATING SYSTEM
        // ============================================
        function calculateRatingChange(playerRating, opponentRating, didWin) {
            // K-factor: High early (32), decreases with experience
            // WoW uses higher K-factor for first ~50 games, then stabilizes
            const gamesPlayed = gameState.wins + gameState.losses;
            let kFactor;
            
            if (gamesPlayed < 10) {
                kFactor = 48; // Very high volatility for placement matches
            } else if (gamesPlayed < 30) {
                kFactor = 32; // High volatility early on
            } else if (gamesPlayed < 100) {
                kFactor = 24; // Medium volatility
            } else {
                kFactor = 16; // Stable rating for experienced players
            }
            
            // Expected score using Elo formula
            // Higher rated player expected to win more
            const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
            
            // Actual score (1 for win, 0 for loss)
            const actualScore = didWin ? 1 : 0;
            
            // Base rating change
            let ratingChange = kFactor * (actualScore - expectedScore);
            
            // CATCH-UP LOGIC: Under 1000 rating, gains are faster and losses are significantly reduced
            if (playerRating < 1000) {
                if (didWin) {
                    ratingChange *= 1.8; // Fast climb out of "unranked" tiers
                } else {
                    ratingChange *= 0.4; // Soften the blow for new players
                }
            }
            
            // Win streak momentum bonus (like WoW's MMR inflation)
            if (didWin && gameState.winStreak >= 3) {
                const streakBonus = Math.min(gameState.winStreak * 2, 10); // Cap at +10
                ratingChange += streakBonus;
            }
            
            // Minimum rating change (prevent stagnation)
            if (didWin) {
                ratingChange = Math.max(ratingChange, 5); // Minimum +5 on win
            } else {
                ratingChange = Math.min(ratingChange, -3); // Maximum -3 on loss (less punishing)
            }
            
            // Floor at 0 rating
            const newRating = Math.max(0, playerRating + ratingChange);
            
            return Math.round(newRating - playerRating);
        }

        // ============================================
        // HONOR SHOP SYSTEM
        // ============================================
        // Complete gear progression system with WoW-style PvP gear
        // Features:
        // - 8 equipment slots (weapon, head, shoulders, chest, hands, legs, trinket1, trinket2)
        // - 20+ gear pieces across 5 tiers (Combatant to Gladiator)
        // - Rating requirements gate higher tiers
        // - Gear stats integrate into combat: damage, health, resilience, healing, CC, CDR, crit, mana
        // - Visual shop UI with tabs, tier badges, stat displays
        // - Smart trinket system (can equip in either slot)
        // - Gear stats summary display
        // - Purchase validation (honor cost + rating requirement)
        // - Visual feedback (pulsing shop button when affordable items available)
        // - Gear resets through prestige (along with upgrades)
        let currentShopTab = 'weapons';

        function calculateTotalGearStats() {
            const stats = {
                damage: 0,
                health: 0,
                resilience: 0,
                healingPower: 0,
                ccDuration: 0,
                cooldownReduction: 0,
                critChance: 0,
                manaRegen: 0,
                haste: 0
            };

            // Sum up all equipped gear stats
            Object.values(gameState.equippedGear).forEach(itemId => {
                if (!itemId) return;
                
                // Check if it's an enchant first
                if (ENCHANTS[itemId]) {
                    const enchant = ENCHANTS[itemId];
                    Object.entries(enchant.stats).forEach(([stat, value]) => {
                        // For enchants, we might need different logic if they are multipliers
                        // but let's stick to additive for simplicity unless it's a known multiplier
                        if (stats.hasOwnProperty(stat)) {
                            stats[stat] += value;
                        }
                    });
                    return;
                }

                // Find the item across all gear categories
                const allGear = [...PVP_GEAR.weapons, ...PVP_GEAR.armor, ...PVP_GEAR.trinkets];
                const item = allGear.find(g => g.id === itemId);
                
                if (item && item.stats) {
                    Object.entries(item.stats).forEach(([stat, value]) => {
                        if (stats.hasOwnProperty(stat)) {
                            stats[stat] += value;
                        }
                    });
                }
            });

            return stats;
        }

        function getTalentBonus(talentId) {
            const level = gameState.talents[talentId] || 0;
            if (level === 0) return 0;

            switch (talentId) {
                case 'tal_damage': return level * 0.05;
                case 'tal_crit': return level * 0.15;
                case 'tal_execution': return level * 0.10;
                case 'tal_defense': return level * 0.03;
                case 'tal_cc_res': return level * 0.10;
                case 'tal_recovery': return level * 0.05; // 5% heal
                case 'tal_mana': return level * 0.10;
                case 'tal_cdr': return level * 0.05;
                case 'tal_efficiency': return level * 0.08;
                default: return 0;
            }
        }

        function openHonorShop() {
            document.getElementById('honor-shop-modal').classList.add('show');
            renderGearStatsSummary();
            renderShopItems(currentShopTab);
        }

        function renderGearStatsSummary() {
            const summary = document.getElementById('gear-stats-summary');
            const gearStats = calculateTotalGearStats();
            
            const statLabels = {
                damage: '‚öîÔ∏è Damage',
                health: '‚ù§Ô∏è Health',
                resilience: 'üõ°Ô∏è Resilience',
                healingPower: 'üíö Healing',
                ccDuration: '‚è±Ô∏è CC Duration',
                cooldownReduction: '‚ö° Cooldown',
                critChance: 'üí• Crit Chance',
                manaRegen: 'üíô Mana Regen'
            };
            
            summary.innerHTML = '';
            Object.entries(gearStats).forEach(([stat, value]) => {
                if (value > 0) {
                    const div = document.createElement('div');
                    div.style.color = '#00ff00';
                    div.innerHTML = `<strong>${statLabels[stat] || stat}:</strong> +${value}`;
                    summary.appendChild(div);
                }
            });
            
            if (Object.values(gearStats).every(v => v === 0)) {
                summary.innerHTML = '<div style="text-align: center; color: #888; grid-column: 1 / -1;">No gear equipped. Purchase items below to boost your team!</div>';
            }
        }

        function closeHonorShop() {
            document.getElementById('honor-shop-modal').classList.remove('show');
        }

        function switchShopTab(tab) {
            currentShopTab = tab;
            
            // Update tab visuals
            document.querySelectorAll('.shop-tab').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                }
            });
            
            renderShopItems(tab);
        }

        function renderShopItems(tab) {
            const container = document.getElementById('shop-items-container');
            container.innerHTML = '';

            let items = [];
            if (tab === 'weapons') items = PVP_GEAR.weapons;
            else if (tab === 'armor') items = PVP_GEAR.armor;
            else if (tab === 'trinkets') items = PVP_GEAR.trinkets;
            else if (tab === 'enchants') {
                renderEnchantItems();
                return;
            }

            items.forEach(item => {
                const isEquipped = Object.values(gameState.equippedGear).includes(item.id);
                const canAfford = gameState.honor >= item.cost;
                const meetsRating = gameState.arenaRating >= item.ratingRequired;
                const isLocked = !meetsRating;
                const cantAfford = !isLocked && !canAfford && !isEquipped;

                const itemDiv = document.createElement('div');
                itemDiv.className = `shop-item ${isLocked ? 'locked' : ''} ${cantAfford ? 'cant-afford' : ''} ${isEquipped ? 'equipped' : ''}`;
                
                // Build rating requirement label
                const ratingLabel = isLocked ? 
                    `<div style="color: #ff4444; font-weight: bold; font-size: 11px; margin-bottom: 5px;">üîí Requires ${item.ratingRequired} Rating</div>` : 
                    `<div style="color: #44ff44; font-size: 11px; margin-bottom: 5px;">‚úì Rating Met (${item.ratingRequired})</div>`;

                // Build stats display
                let statsHTML = '';
                if (item.stats) {
                    statsHTML = '<div class="item-stats">';
                    Object.entries(item.stats).forEach(([stat, value]) => {
                        const statName = stat.replace(/([A-Z])/g, ' $1').trim();
                        const displayName = statName.charAt(0).toUpperCase() + statName.slice(1);
                        statsHTML += `<div class="item-stat">+${value} ${displayName}</div>`;
                    });
                    statsHTML += '</div>';
                }

                // Get current item in this slot (if any)
                let currentItem = null;
                if (item.slot === 'trinket1') {
                    // Check both trinket slots
                    const trinket1Id = gameState.equippedGear.trinket1;
                    const trinket2Id = gameState.equippedGear.trinket2;
                    if (trinket1Id || trinket2Id) {
                        const allGear = [...PVP_GEAR.weapons, ...PVP_GEAR.armor, ...PVP_GEAR.trinkets];
                        currentItem = allGear.find(g => g.id === trinket1Id) || allGear.find(g => g.id === trinket2Id);
                    }
                } else {
                    const equippedId = gameState.equippedGear[item.slot];
                    if (equippedId) {
                        const allGear = [...PVP_GEAR.weapons, ...PVP_GEAR.armor, ...PVP_GEAR.trinkets];
                        currentItem = allGear.find(g => g.id === equippedId);
                    }
                }

                const slotLabel = item.slot.replace('trinket1', 'Trinket').replace(/([A-Z])/g, ' $1').trim();
                const slotDisplayName = slotLabel.charAt(0).toUpperCase() + slotLabel.slice(1);

                itemDiv.innerHTML = `
                    <div class="slot-info">${slotDisplayName}</div>
                    <div class="item-tier tier-${item.tier.toLowerCase()}">${item.tier}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-level">Item Level ${item.itemLevel}</div>
                    ${ratingLabel}
                    ${statsHTML}
                    <div class="item-description">${item.description}</div>
                    ${currentItem && !isEquipped ? `<div style="font-size: 11px; color: #ff8800; margin-top: 8px;">‚ö†Ô∏è Replaces: ${currentItem.name}</div>` : ''}
                    <div class="item-cost">
                        <span class="cost-amount">
                            <img src="https://rosebud.ai/assets/honor-token.webp?Aozw" style="width:18px;height:18px;">
                            ${item.cost.toLocaleString()}
                        </span>
                        <button class="buy-button" ${isLocked || !canAfford || isEquipped ? 'disabled' : ''}>
                            ${isEquipped ? 'Equipped' : (isLocked ? 'üîí Locked' : (canAfford ? 'Buy' : 'Not Enough Honor'))}
                        </button>
                    </div>
                `;

                // Add click handler for purchase
                const buyBtn = itemDiv.querySelector('.buy-button');
                if (!isLocked && !isEquipped) {
                    buyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        purchaseGear(item);
                    });
                }

                container.appendChild(itemDiv);
            });
        }

        function renderEnchantItems() {
            const container = document.getElementById('shop-items-container');
            container.innerHTML = '';

            Object.values(ENCHANTS).forEach(enchant => {
                const isEquipped = gameState.equippedGear.enchant === enchant.id;
                const canAfford = gameState.honor >= enchant.cost;
                const meetsRating = gameState.arenaRating >= enchant.ratingRequired;
                const isLocked = !meetsRating;
                const cantAfford = !isLocked && !canAfford && !isEquipped;

                const itemDiv = document.createElement('div');
                itemDiv.className = `shop-item ${isLocked ? 'locked' : ''} ${cantAfford ? 'cant-afford' : ''} ${isEquipped ? 'equipped' : ''}`;
                
                // Build rating requirement label
                const ratingLabel = isLocked ? 
                    `<div style="color: #ff4444; font-weight: bold; font-size: 11px; margin-bottom: 5px;">üîí Requires ${enchant.ratingRequired} Rating</div>` : 
                    `<div style="color: #44ff44; font-size: 11px; margin-bottom: 5px;">‚úì Rating Met (${enchant.ratingRequired})</div>`;

                let statsHTML = '<div class="item-stats">';
                Object.entries(enchant.stats).forEach(([stat, value]) => {
                    const sign = value > 0 ? '+' : '';
                    const displayValue = (value * 100).toFixed(0) + '%';
                    const displayName = stat.charAt(0).toUpperCase() + stat.slice(1);
                    statsHTML += `<div class="item-stat">${sign}${displayValue} ${displayName}</div>`;
                });
                statsHTML += '</div>';

                itemDiv.innerHTML = `
                    <div class="slot-info">Weapon Enchant</div>
                    <div class="item-tier" style="background: ${'#' + enchant.color.toString(16).padStart(6, '0')}">Legendary</div>
                    <div class="item-name" style="color: ${'#' + enchant.color.toString(16).padStart(6, '0')}">${enchant.name}</div>
                    <div class="item-level">Visual Rank 1</div>
                    ${ratingLabel}
                    ${statsHTML}
                    <div class="item-description">${enchant.desc}</div>
                    <div class="item-cost">
                        <span class="cost-amount">
                            <img src="https://rosebud.ai/assets/honor-token.webp?Aozw" style="width:18px;height:18px;">
                            ${enchant.cost.toLocaleString()}
                        </span>
                        <button class="buy-button" ${isLocked || !canAfford || isEquipped ? 'disabled' : ''}>
                            ${isEquipped ? 'Equipped' : (isLocked ? 'üîí Locked' : (canAfford ? 'Apply' : 'Need Honor'))}
                        </button>
                    </div>
                `;

                const buyBtn = itemDiv.querySelector('.buy-button');
                if (!isLocked && !isEquipped && canAfford) {
                    buyBtn.addEventListener('click', () => {
                        gameState.honor -= enchant.cost;
                        gameState.equippedGear.enchant = enchant.id;
                        addCombatLog(`‚ú® Applied ${enchant.name} to your team's weapons!`, 'buff');
                        soundManager.playMagic('C5');
                        
                        // Update current characters visuals
                        [...gameState.team].forEach(char => {
                            if (!char.userData.isPet) applyWeaponEnchant(char);
                        });
                        
                        renderEnchantItems();
                        updateUI();
                    });
                }

                container.appendChild(itemDiv);
            });
        }

        function purchaseGear(item) {
            // Check if can afford
            if (gameState.honor < item.cost) {
                addCombatLog('‚ùå Not enough honor!', 'error');
                return;
            }

            // Check rating requirement
            if (gameState.arenaRating < item.ratingRequired) {
                addCombatLog(`‚ùå Requires ${item.ratingRequired} rating!`, 'error');
                return;
            }

            // Deduct honor
            gameState.honor -= item.cost;

            // Equip the item
            if (item.slot === 'trinket1') {
                // Trinkets can go in either slot - find first empty slot
                if (gameState.equippedGear.trinket1 === null) {
                    gameState.equippedGear.trinket1 = item.id;
                } else if (gameState.equippedGear.trinket2 === null) {
                    gameState.equippedGear.trinket2 = item.id;
                } else {
                    // Both slots full, replace trinket1
                    gameState.equippedGear.trinket1 = item.id;
                }
            } else {
                // Regular gear - replace existing item in that slot
                gameState.equippedGear[item.slot] = item.id;
            }

            // Log the purchase
            addCombatLog(`‚úÖ Purchased ${item.name}!`, 'buff');
            
            // Show floating text notification
            showArenaAnnouncement(`Equipped: ${item.name}`, 1500);
            
            // Play a success sound effect would go here
            
            // Update UI
            updateUI();
            renderGearStatsSummary();
            renderShopItems(currentShopTab);
        }

        // ============================================
        // ROSTER MANAGEMENT SYSTEM
        // ============================================
        let selectedRosterSlot = 0;

        function openRosterManager() {
            document.getElementById('roster-modal').style.display = 'flex';
            renderRosterUI();
        }

        function closeRosterManager() {
            document.getElementById('roster-modal').style.display = 'none';
        }

        function renderRosterUI() {
            const activeContainer = document.getElementById('active-roster-display');
            const availableContainer = document.getElementById('roster-items-container');
            
            // Render active slots
            activeContainer.innerHTML = '';
            gameState.activeRoster.forEach((classId, index) => {
                const slot = document.createElement('div');
                const isSelected = selectedRosterSlot === index;
                slot.className = 'ui-panel';
                slot.style.width = '120px';
                slot.style.padding = '10px';
                slot.style.cursor = 'pointer';
                slot.style.border = isSelected ? '2px solid #00ffff' : '1px solid #8e6d3f';
                slot.style.boxShadow = isSelected ? '0 0 10px #00ffff' : 'none';
                
                slot.innerHTML = `
                    <div style="font-size: 10px; color: #888; text-transform: uppercase;">Slot ${index + 1}</div>
                    <img src="${CLASS_ICONS[classId]}" style="width: 48px; height: 48px; border-radius: 4px; margin: 5px 0;">
                    <div style="font-size: 12px; font-weight: bold; color: #ffd700;">${CLASSES[classId].name}</div>
                `;
                
                slot.onclick = () => {
                    selectedRosterSlot = index;
                    renderRosterUI();
                };
                
                activeContainer.appendChild(slot);
            });
            
            // Render available heroes categorized
            availableContainer.innerHTML = '';
            availableContainer.style.display = 'flex';
            availableContainer.style.flexDirection = 'column';
            availableContainer.style.gap = '20px';

            const categories = [
                { id: 'healer', name: 'Healers üíö', color: '#66ff66' },
                { id: 'melee', name: 'Melee DPS ‚öîÔ∏è', color: '#ff6666' },
                { id: 'ranged', name: 'Ranged DPS üèπ', color: '#66ccff' }
            ];

            categories.forEach(cat => {
                const catSection = document.createElement('div');
                catSection.innerHTML = `<h4 style="color: ${cat.color}; font-family: 'Cinzel', serif; margin-bottom: 10px; border-bottom: 1px solid ${cat.color}44;">${cat.name}</h4>`;
                
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(180px, 1fr))';
                grid.style.gap = '10px';

                Object.keys(CLASSES).forEach(classId => {
                    const hero = CLASSES[classId];
                    if (hero.role !== cat.id) return;

                    const isActive = gameState.activeRoster.includes(classId);
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.style.padding = '10px';
                    card.style.margin = '0';
                    card.style.borderColor = isActive ? '#00ff00' : '#8e6d3f';
                    card.style.opacity = isActive ? '0.6' : '1';
                    
                    card.innerHTML = `
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <img src="${CLASS_ICONS[classId]}" style="width: 32px; height: 32px; border-radius: 4px;">
                            <div>
                                <div style="font-weight: bold; color: #fff; font-size: 13px;">${hero.name}</div>
                                <div style="font-size: 9px; color: #aaa;">${cat.name.split(' ')[0]} Specialist</div>
                            </div>
                        </div>
                        ${isActive ? `<div style="font-size: 10px; color: #00ff00; margin-top: 5px; text-align: center;">In Team</div>` : ''}
                    `;
                    
                    card.onclick = () => swapHero(classId);
                    grid.appendChild(card);
                });

                catSection.appendChild(grid);
                availableContainer.appendChild(catSection);
            });
        }

        function swapHero(classId) {
            // Can't have duplicates in team
            if (gameState.activeRoster.includes(classId)) {
                addCombatLog(`‚ùå ${CLASSES[classId].name} is already in your team!`, 'error');
                return;
            }
            
            const oldHero = gameState.activeRoster[selectedRosterSlot];
            gameState.activeRoster[selectedRosterSlot] = classId;
            
            addCombatLog(`üë• Swapped ${CLASSES[oldHero].name} for ${CLASSES[classId].name}!`, 'buff');
            showArenaAnnouncement(`${CLASSES[classId].name} Joined Team!`, 1500);
            
            renderRosterUI();
            
            // Start a new match immediately to use the new team
            startNewMatch();
        }

        function checkRosterUnlocks() {
            // All heroes are unlocked by default now.
            return false;
        }

        // ============================================
        // CONQUEST SHOP SYSTEM
        // ============================================
        function openConquestShop() {
            document.getElementById('conquest-shop-modal').style.display = 'flex';
            document.getElementById('conquest-shop-amount').textContent = Math.floor(gameState.conquestPoints);
            document.getElementById('conquest-shop-cap').textContent = gameState.conquestCap;
            document.getElementById('conquest-shop-balance').textContent = Math.floor(gameState.conquestPoints);
            renderConquestShop();
        }

        function closeConquestShop() {
            document.getElementById('conquest-shop-modal').style.display = 'none';
        }

        function openSettings() {
            const modal = document.getElementById('settings-modal');
            modal.style.display = 'flex';
            
            // Sync audio settings
            document.getElementById('master-volume-slider').value = soundManager.masterVolume;
            document.getElementById('settings-mute-btn').textContent = soundManager.isMuted ? 'üîá' : 'üîä';
            
            // Update stats display
            const totalGames = gameState.wins + gameState.losses;
            const winRate = totalGames > 0 ? ((gameState.wins / totalGames) * 100).toFixed(1) : '0.0';
            
            document.getElementById('total-honor-display').textContent = Math.floor(gameState.honor).toLocaleString();
            document.getElementById('total-games-display').textContent = totalGames.toLocaleString();
            document.getElementById('total-winrate-display').textContent = winRate + '%';
            document.getElementById('total-conquest-display').textContent = Math.floor(gameState.conquestPoints).toLocaleString();
            
            // Update last save time
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const saveData = JSON.parse(savedData);
                    const lastSaveTime = new Date(saveData.timestamp);
                    const now = new Date();
                    const diffMs = now - lastSaveTime;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffSecs = Math.floor((diffMs % 60000) / 1000);
                    
                    let timeAgo = '';
                    if (diffMins > 60) {
                        const hours = Math.floor(diffMins / 60);
                        timeAgo = `${hours} hour${hours > 1 ? 's' : ''} ago`;
                    } else if (diffMins > 0) {
                        timeAgo = `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
                    } else {
                        timeAgo = `${diffSecs} second${diffSecs !== 1 ? 's' : ''} ago`;
                    }
                    
                    document.getElementById('last-save-time').textContent = `Last saved: ${timeAgo}`;
                } else {
                    document.getElementById('last-save-time').textContent = 'Last saved: Never';
                }
            } catch (error) {
                document.getElementById('last-save-time').textContent = 'Last saved: Unknown';
            }
        }

        function closeSettings() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        function openHistory() {
            const modal = document.getElementById('history-modal');
            const container = document.getElementById('history-container');
            container.innerHTML = '';
            
            // Populate summary
            document.getElementById('career-wins').textContent = (gameState.lifetimeWins || 0).toLocaleString();
            document.getElementById('career-peak').textContent = Math.floor(gameState.peakRating || 0).toLocaleString();
            document.getElementById('career-total').textContent = ((gameState.lifetimeWins || 0) + (gameState.lifetimeLosses || 0)).toLocaleString();

            if (!gameState.seasonHistory || gameState.seasonHistory.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No career history found yet. Fight some matches!</div>';
            } else {
                gameState.seasonHistory.forEach(entry => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        background: rgba(0, 0, 0, 0.4);
                        border: 1px solid ${entry.victory ? '#ffd700' : '#ff4444'};
                        border-left: 5px solid ${entry.victory ? '#ffd700' : '#ff4444'};
                        padding: 12px;
                        border-radius: 4px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;
                    
                    item.innerHTML = `
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: ${entry.victory ? '#ffd700' : '#ff4444'}; font-family: 'Cinzel', serif;">
                                ${entry.victory ? 'üèÜ VICTORY' : 'üíÄ DEFEAT'}
                                <span style="color: #888; font-weight: normal; font-size: 11px; margin-left: 10px;">${entry.date}</span>
                            </div>
                            <div style="font-size: 12px; color: #aaa; margin-top: 4px;">
                                Time: ${entry.time.toFixed(1)}s ‚Ä¢ Rating: ${entry.rating}
                            </div>
                        </div>
                        <div style="text-align: right; font-size: 12px;">
                            <div style="color: #ff6666;">Dmg: ${Math.round(entry.damage).toLocaleString()}</div>
                            <div style="color: #66ff66;">Heal: ${Math.round(entry.healing).toLocaleString()}</div>
                        </div>
                    `;
                    container.appendChild(item);
                });
            }
            
            modal.style.display = 'flex';
        }

        function closeHistory() {
            document.getElementById('history-modal').style.display = 'none';
        }

        function renderConquestShop() {
            const container = document.getElementById('conquest-items-container');
            container.innerHTML = '';

            CONQUEST_UPGRADES.forEach(upgrade => {
                const level = gameState.conquestUpgrades[upgrade.id] || 0;
                const isMaxLevel = level >= upgrade.maxLevel;
                const canAfford = gameState.conquestPoints >= upgrade.cost;

                const item = document.createElement('div');
                item.className = 'shop-item';
                if (isMaxLevel) item.classList.add('locked');
                if (!canAfford && !isMaxLevel) item.classList.add('cant-afford');

                item.style.background = 'linear-gradient(135deg, rgba(100, 50, 150, 0.4), rgba(60, 30, 90, 0.4))';
                item.style.borderColor = isMaxLevel ? '#666' : (canAfford ? '#ff00ff' : '#8e6d3f');

                item.innerHTML = `
                    <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">${upgrade.icon}</div>
                    <div class="item-name" style="color: #ff88ff;">${upgrade.name}</div>
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 10px;">Level ${level} / ${upgrade.maxLevel}</div>
                    <div class="item-description" style="color: #ffd700;">${upgrade.desc}</div>
                    <div class="item-cost" style="margin-top: 15px;">
                        <span class="cost-amount" style="color: #ff88ff;">
                            ‚öîÔ∏è ${upgrade.cost}
                        </span>
                        <button class="buy-button" ${!canAfford || isMaxLevel ? 'disabled' : ''} style="background: linear-gradient(180deg, #9966ff, #6633cc); border-color: #ff00ff;">
                            ${isMaxLevel ? 'MAX' : (canAfford ? 'Upgrade' : 'Not Enough')}
                        </button>
                    </div>
                `;

                const buyBtn = item.querySelector('.buy-button');
                if (canAfford && !isMaxLevel) {
                    buyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        purchaseConquestUpgrade(upgrade);
                    });
                }

                container.appendChild(item);
            });
        }

        function purchaseConquestUpgrade(upgrade) {
            if (gameState.conquestPoints < upgrade.cost) {
                addCombatLog('‚ùå Not enough Conquest!', 'error');
                return;
            }

            const currentLevel = gameState.conquestUpgrades[upgrade.id] || 0;
            if (currentLevel >= upgrade.maxLevel) {
                addCombatLog('‚ùå Already max level!', 'error');
                return;
            }

            // Deduct conquest
            gameState.conquestPoints -= upgrade.cost;
            gameState.conquestUpgrades[upgrade.id]++;

            // Log purchase
            addCombatLog(`‚úÖ Upgraded ${upgrade.name} to Level ${gameState.conquestUpgrades[upgrade.id]}!`, 'buff');
            showArenaAnnouncement(`${upgrade.name} Upgraded!`, 1500);

            // Update UI
            updateUI();
            renderConquestShop();
        }

        function renderTalentTree() {
            const container = document.getElementById('talent-tree-container');
            const pointsDisplay = document.getElementById('talent-points-available');
            const prestigeDisplay = document.getElementById('talent-prestige-level');
            
            if (!container) return;
            
            container.innerHTML = '';
            pointsDisplay.textContent = gameState.talentPoints;
            prestigeDisplay.textContent = gameState.prestigeLevel;

            const categories = ['Assault', 'Ironclad', 'Ascendance'];
            
            categories.forEach(category => {
                const catDiv = document.createElement('div');
                catDiv.style.display = 'flex';
                catDiv.style.flexDirection = 'column';
                catDiv.style.gap = '15px';
                
                const catTitle = document.createElement('h3');
                catTitle.textContent = category;
                catTitle.style.color = '#ffd700';
                catTitle.style.borderBottom = '1px solid #4a3a25';
                catTitle.style.paddingBottom = '5px';
                catTitle.style.margin = '0';
                catTitle.style.fontSize = '16px';
                catDiv.appendChild(catTitle);

                const catTalents = TALENTS.filter(t => t.category === category);
                catTalents.forEach(talent => {
                    const level = gameState.talents[talent.id] || 0;
                    const canAfford = gameState.talentPoints > 0;
                    const isMax = level >= talent.maxLevel;
                    
                    const talentCard = document.createElement('div');
                    talentCard.style.background = '#222';
                    talentCard.style.border = `1px solid ${level > 0 ? '#ffd700' : '#444'}`;
                    talentCard.style.padding = '12px';
                    talentCard.style.borderRadius = '4px';
                    talentCard.style.position = 'relative';
                    talentCard.style.cursor = (!isMax && canAfford) ? 'pointer' : 'default';
                    talentCard.style.transition = 'all 0.2s';
                    
                    if (!isMax && canAfford) {
                        talentCard.onmouseover = () => talentCard.style.borderColor = '#ffd700';
                        talentCard.onmouseout = () => talentCard.style.borderColor = (level > 0 ? '#ffd700' : '#444');
                    }

                    talentCard.onclick = () => {
                        if (!isMax && gameState.talentPoints > 0) {
                            upgradeTalent(talent.id);
                        }
                    };

                    talentCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                            <span style="font-size: 20px;">${talent.icon}</span>
                            <span style="color: ${isMax ? '#ffd700' : '#888'}; font-weight: bold; font-size: 12px;">${level}/${talent.maxLevel}</span>
                        </div>
                        <div style="color: #eee; font-weight: bold; font-size: 14px; margin-bottom: 4px;">${talent.name}</div>
                        <div style="color: #aaa; font-size: 11px; line-height: 1.3;">${talent.desc}</div>
                    `;

                    catDiv.appendChild(talentCard);
                });

                container.appendChild(catDiv);
            });
        }

        function upgradeTalent(talentId) {
            if (gameState.talentPoints <= 0) return;
            
            const talent = TALENTS.find(t => t.id === talentId);
            const currentLevel = gameState.talents[talentId] || 0;
            
            if (currentLevel < talent.maxLevel) {
                gameState.talents[talentId] = currentLevel + 1;
                gameState.talentPoints--;
                
                soundManager.playMagic('G4'); // Uplifting sound for talent
                showArenaAnnouncement(`${talent.name} Learned!`, 1500);
                
                renderTalentTree();
                saveGame();
            }
        }

        function openTalentTree() {
            document.getElementById('talent-modal').style.display = 'flex';
            renderTalentTree();
            soundManager.playClick();
        }

        function closeTalentTree() {
            document.getElementById('talent-modal').style.display = 'none';
            soundManager.playClick();
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        document.getElementById('talent-tree-btn').addEventListener('click', openTalentTree);
        document.getElementById('talent-close-btn').addEventListener('click', closeTalentTree);
        document.getElementById('prestige-btn').addEventListener('click', doPrestige);
        document.getElementById('review-prestige-btn').addEventListener('click', () => {
            document.getElementById('match-review-modal').style.display = 'none';
            if (gameState.reviewTimer) clearTimeout(gameState.reviewTimer);
            doPrestige();
        });
        document.getElementById('honor-shop-btn').addEventListener('click', openHonorShop);
        document.getElementById('shop-close-btn').addEventListener('click', closeHonorShop);
        document.getElementById('roster-btn').addEventListener('click', () => {
            document.getElementById('roster-btn').classList.remove('shop-available');
            openRosterManager();
        });
        document.getElementById('roster-close-btn').addEventListener('click', closeRosterManager);
        document.getElementById('conquest-shop-btn').addEventListener('click', openConquestShop);
        document.getElementById('conquest-shop-close-btn').addEventListener('click', closeConquestShop);
        document.getElementById('settings-btn').addEventListener('click', openSettings);
        document.getElementById('settings-close-btn').addEventListener('click', closeSettings);
        document.getElementById('history-btn').addEventListener('click', openHistory);
        document.getElementById('history-close-btn').addEventListener('click', closeHistory);

        // Mobile HUD Toggle
        document.getElementById('mobile-toggle-hud').addEventListener('click', (e) => {
            e.stopPropagation();
            const panel = document.getElementById('match-hud-panel');
            const toggleBtn = document.getElementById('mobile-toggle-hud');
            
            soundManager.playClick();
            panel.classList.toggle('collapsed');
            
            if (panel.classList.contains('collapsed')) {
                toggleBtn.innerHTML = '‚ñ≤ EXPAND HUD';
                addCombatLog("HUD Minimized for better visibility.", "buff");
            } else {
                toggleBtn.innerHTML = '‚ñº MINIMIZE HUD';
            }
        });

        // Mobile Menu Listeners
        const mobileMenuModal = document.getElementById('mobile-menu-modal');
        const mobileMenuTrigger = document.getElementById('mobile-menu-trigger');
        const mobileMenuClose = document.getElementById('mobile-menu-close');

        if (mobileMenuTrigger) {
            mobileMenuTrigger.addEventListener('click', () => {
                mobileMenuModal.style.display = 'block';
                soundManager.playClick();
                updateUI();
            });
        }

        if (mobileMenuClose) {
            mobileMenuClose.addEventListener('click', () => {
                mobileMenuModal.style.display = 'none';
                soundManager.playClick();
            });
        }

        // Mobile Action Buttons
        document.getElementById('m-btn-upgrades').addEventListener('click', () => {
            document.getElementById('upgrades-modal').style.display = 'flex';
            mobileMenuModal.style.display = 'none';
            renderUpgrades();
            soundManager.playClick();
        });
        document.getElementById('upgrades-close-btn').addEventListener('click', () => {
            document.getElementById('upgrades-modal').style.display = 'none';
            mobileMenuModal.style.display = 'block';
            soundManager.playClick();
        });

        document.getElementById('m-btn-shop').addEventListener('click', () => {
            openHonorShop();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-roster').addEventListener('click', () => {
            openRosterManager();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-vendor').addEventListener('click', () => {
            openConquestShop();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-talents').addEventListener('click', () => {
            document.getElementById('talent-modal').style.display = 'flex';
            renderTalentTree();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-history').addEventListener('click', () => {
            openHistory();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-settings').addEventListener('click', () => {
            openSettings();
            mobileMenuModal.style.display = 'none';
        });
        document.getElementById('m-btn-prestige').addEventListener('click', () => {
            if (gameState.arenaRating >= CONFIG.prestigeRequirement) {
                mobileMenuModal.style.display = 'none';
                doPrestige();
            }
        });

        const forfeitLogic = () => {
            // Remove confirm() as it may be blocked in some environments
            // Instead, we check if the match is actually in progress
            if (gameState.inMatch) {
                console.log('üè≥Ô∏è Forfeit triggered manually');
                addCombatLog('Team has forfeited the match!', 'death');
                
                // Stop all movement and casting immediately
                [...gameState.team, ...gameState.enemies].forEach(char => {
                    if (char.userData) {
                        char.userData.velocity?.set(0, 0, 0);
                        char.userData.castingAbility = null;
                        char.userData.castingTarget = null;
                        char.userData.ccUntil = 0;
                    }
                });

                // Hide forfeit buttons so they can't be double-clicked
                if (document.getElementById('forfeit-btn')) document.getElementById('forfeit-btn').style.display = 'none';
                if (document.getElementById('m-btn-forfeit')) document.getElementById('m-btn-forfeit').style.display = 'none';

                mobileMenuModal.style.display = 'none';
                
                // End match as loss
                endMatch(false);

                // Force a quick reset regardless of match review modal state
                if (gameState.reviewTimer) clearTimeout(gameState.reviewTimer);
                
                gameState.reviewTimer = setTimeout(() => {
                    // Force close the review modal and start next match
                    const modal = document.getElementById('match-review-modal');
                    if (modal) modal.style.display = 'none';
                    startNewMatch();
                }, 1000); // 1 second for visual feedback of "DEFEAT"
            } else {
                // If match isn't active but button was clicked, try to force start
                startNewMatch();
            }
        };

        document.getElementById('forfeit-btn').addEventListener('click', forfeitLogic);
        document.getElementById('m-btn-forfeit').addEventListener('click', forfeitLogic);

        // Team Doctrine listener
        document.getElementById('strategy-preset').addEventListener('change', (e) => {
            gameState.teamDoctrine = e.target.value;
            console.log(`üìú Team Doctrine changed to: ${gameState.teamDoctrine}`);
            addCombatLog(`Doctrine changed to: ${gameState.teamDoctrine.replace('_', ' ').toUpperCase()}`, 'buff');
            saveGame(); // Save preference immediately
        });

        // Audio Listeners
        document.getElementById('mute-toggle-btn').addEventListener('click', () => soundManager.toggleMute());
        document.getElementById('camera-toggle-btn').addEventListener('click', () => toggleCameraMode());
        document.getElementById('camera-next-btn').addEventListener('click', () => {
            if (spectatorCamera) spectatorCamera.cycleTarget(1);
        });
        document.getElementById('settings-mute-btn').addEventListener('click', () => {
            soundManager.toggleMute();
        });
        document.getElementById('master-volume-slider').addEventListener('input', (e) => {
            soundManager.setVolume(parseFloat(e.target.value));
        });

        document.getElementById('match-review-close-btn').addEventListener('click', () => {
            document.getElementById('match-review-modal').style.display = 'none';
            if (gameState.reviewTimer) clearTimeout(gameState.reviewTimer);
            startNewMatch();
        });
        document.getElementById('match-review-continue-btn').addEventListener('click', () => {
            document.getElementById('match-review-modal').style.display = 'none';
            if (gameState.reviewTimer) clearTimeout(gameState.reviewTimer);
            startNewMatch();
        });

        // Shop tab switching
        document.querySelectorAll('.shop-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchShopTab(tab.dataset.tab);
            });
        });

        // Close shop when clicking outside
        document.getElementById('honor-shop-modal').addEventListener('click', (e) => {
            if (e.target.id === 'honor-shop-modal') {
                closeHonorShop();
            }
        });

        document.getElementById('conquest-shop-modal').addEventListener('click', (e) => {
            if (e.target.id === 'conquest-shop-modal') {
                closeConquestShop();
            }
        });

        document.getElementById('settings-modal').addEventListener('click', (e) => {
            if (e.target.id === 'settings-modal') {
                closeSettings();
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('settings-manual-save').addEventListener('click', () => {
            console.log('üíæ Manual Save clicked');
            saveGame();
            alert('Game saved manually!');
        });
        document.getElementById('settings-export-save').addEventListener('click', () => {
            console.log('üì• Export Save clicked');
            exportSave();
        });
        document.getElementById('settings-import-save').addEventListener('click', () => {
            console.log('üì§ Import Save clicked');
            importSave();
        });

        // ESC key to close shops and settings
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const honorShop = document.getElementById('honor-shop-modal');
                const conquestShop = document.getElementById('conquest-shop-modal');
                const settingsModal = document.getElementById('settings-modal');
                
                if (honorShop.classList.contains('show')) {
                    closeHonorShop();
                } else if (conquestShop.style.display === 'flex') {
                    closeConquestShop();
                } else if (settingsModal.style.display === 'flex') {
                    closeSettings();
                }
            }
        });

        // ============================================
        // AAA CHARACTER ANIMATIONS
        // ============================================
        function updateCharacterAnimations(deltaTime) {
            const currentTime = performance.now();
            
            [...gameState.team, ...gameState.enemies].forEach(char => {
                if (!char.visible) return;

                const userData = char.userData;
                const parts = userData.animParts;
                const classType = userData.classType;

                // Update animation time
                userData.animationTime += deltaTime * userData.animationSpeed;
                userData.breathingPhase += deltaTime * 2;

                const time = userData.animationTime;
                const breathe = userData.breathingPhase;

                // Check special animation states
                const isCasting = (userData.castingUntil && currentTime < userData.castingUntil) || 
                                 (userData.castingAbility && userData.castingAbility.castTime > 0);
                const isAttacking = userData.attackingUntil && currentTime < userData.attackingUntil;

                // Calculate movement speed
                const currentSpeed = userData.velocity.length();
                const maxSpeed = userData.moveSpeed;
                const speedRatio = maxSpeed > 0 ? currentSpeed / maxSpeed : 0;
                
                // Determine animation state based on velocity
                let newState = 'idle';
                if (speedRatio > 0.7) {
                    newState = 'run';
                } else if (speedRatio > 0.3) {
                    newState = 'walk';
                } else if (speedRatio > 0.05) {
                    newState = 'shuffle';
                }

                // Handle GLTF animation switching if available
                if (userData.actions) {
                    let targetAction = 'idle';
                    if (isCasting) targetAction = 'cast';
                    else if (isAttacking) targetAction = 'attack';
                    else if (newState === 'run') targetAction = 'run';
                    else if (newState === 'walk' || newState === 'shuffle') targetAction = 'walk';

                    const action = userData.actions[targetAction] || userData.actions['idle'];
                    
                    if (action) {
                        // Switch animations with smooth crossfade
                        if (userData.currentActionName !== targetAction) {
                            // Log only for priests to help debug
                            if (userData.classType === 'priest') {
                                console.log(`üé¨ PRIEST: ${userData.currentActionName || 'none'} ‚Üí ${targetAction} (speed: ${currentSpeed.toFixed(2)})`);
                            }
                            
                            const prevActionName = userData.currentActionName;
                            const prevAction = userData.actions[prevActionName];
                            
                            if (prevAction && prevAction !== action) {
                                prevAction.fadeOut(0.3);
                            }
                            
                            action.reset()
                                  .setEffectiveTimeScale(1)
                                  .setEffectiveWeight(1)
                                  .fadeIn(0.3)
                                  .play();
                            userData.currentActionName = targetAction;
                        }
                        
                        // Ensure the action is always playing
                        if (!action.isRunning()) {
                            action.play();
                        }
                    }
                    
                    // If we have a GLTF model, we don't need the procedural logic below
                    return;
                }

                if (!parts) return;
                
                // State transition handling
                if (newState !== userData.animState) {
                    userData.prevAnimState = userData.animState;
                    userData.animState = newState;
                    userData.stateTransitionProgress = 0;
                    userData.animStateTime = 0;
                } else {
                    userData.animStateTime += deltaTime;
                    userData.stateTransitionProgress = Math.min(1, userData.stateTransitionProgress + deltaTime * 4);
                }
                
                // Walk cycle phase (for leg animation)
                if (currentSpeed > 0.05) {
                    const cycleSpeed = speedRatio * 8; // Faster cycle when running
                    userData.walkCyclePhase += deltaTime * cycleSpeed;
                }
                
                // ============================================
                // PROCEDURAL BODY LEAN (for turning)
                // ============================================
                if (userData.velocity.lengthSq() > 0.01) {
                    // Calculate angular velocity (how fast we're turning)
                    const currentAngle = Math.atan2(userData.velocity.x, userData.velocity.z);
                    const prevAngle = userData.prevMovementAngle || currentAngle;
                    let angleDiff = currentAngle - prevAngle;
                    
                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Target lean proportional to turn rate
                    userData.targetLean = THREE.MathUtils.clamp(angleDiff * 3, -0.3, 0.3);
                    userData.prevMovementAngle = currentAngle;
                } else {
                    userData.targetLean = 0;
                }
                
                // Smooth lean transition
                userData.leanAmount = THREE.MathUtils.lerp(userData.leanAmount, userData.targetLean, deltaTime * 8);

                // ============================================
                // APPLY MOVEMENT ANIMATIONS
                // ============================================
                
                const blendFactor = userData.stateTransitionProgress;
                
                // Reset base rotations
                if (parts.torso) parts.torso.rotation.set(0, 0, 0);
                if (parts.leftLeg) parts.leftLeg.rotation.set(0, 0, 0);
                if (parts.rightLeg) parts.rightLeg.rotation.set(0, 0, 0);
                if (parts.leftArm) parts.leftArm.rotation.set(0, 0, 0);
                if (parts.rightArm) parts.rightArm.rotation.set(0, 0, 0);

                // SPECIAL STATES OVERRIDE MOVEMENT
                if (isCasting && (classType === 'priest' || classType === 'mage' || classType === 'druid')) {
                    applyCastingAnimation(parts, time);
                    return;
                }

                if (isAttacking && (classType === 'warrior' || classType === 'hunter')) {
                    applyAttackAnimation(parts, userData, currentTime);
                    return;
                }

                // LOCOMOTION ANIMATION
                if (userData.animState === 'idle' || userData.animState === 'shuffle') {
                    applyIdleAnimation(parts, classType, time, breathe, speedRatio);
                } else if (userData.animState === 'walk' || userData.animState === 'run') {
                    applyWalkRunAnimation(parts, classType, userData, speedRatio, blendFactor);
                }
                
                // APPLY LEAN TO TORSO (works across all states)
                if (parts.torso) {
                    parts.torso.rotation.z += userData.leanAmount;
                }

                // Class-specific idle overlays
                applyClassIdleOverlays(parts, classType, time);
            });
        }

        // ============================================
        // ANIMATION HELPER FUNCTIONS
        // ============================================
        
        function applyCastingAnimation(parts, time) {
            if (parts.leftArm) {
                parts.leftArm.rotation.x = -0.8 + Math.sin(time * 5) * 0.1;
                parts.leftArm.rotation.z = -0.3;
            }
            if (parts.rightArm) {
                parts.rightArm.rotation.x = -0.8 + Math.sin(time * 5) * 0.1;
                parts.rightArm.rotation.z = 0.3;
            }
            if (parts.head) {
                parts.head.rotation.x = -0.2;
            }
            if (parts.staffHandle) {
                parts.staffHandle.rotation.z = Math.sin(time * 8) * 0.15;
            }
            if (parts.orb) {
                parts.orb.scale.setScalar(1.3 + Math.sin(time * 10) * 0.2);
            }
        }

        function applyAttackAnimation(parts, userData, currentTime) {
            const attackProgress = 1 - ((userData.attackingUntil - currentTime) / 300);
            const classType = userData.classType;
            
            if (classType === 'warrior') {
                // Overhead sword swing
                if (parts.rightArm) {
                    // Wind up (0-0.3), swing down (0.3-0.7), follow through (0.7-1.0)
                    if (attackProgress < 0.3) {
                        // Wind up
                        const windUp = attackProgress / 0.3;
                        parts.rightArm.rotation.x = -1.5 * windUp;
                        parts.rightArm.rotation.z = 0.6 * windUp;
                    } else {
                        // Swing down with follow-through
                        const swing = (attackProgress - 0.3) / 0.7;
                        parts.rightArm.rotation.x = -1.5 + (2.0 * swing); // Swings forward
                        parts.rightArm.rotation.z = 0.6 - (0.9 * swing);
                    }
                }
                if (parts.torso) {
                    // Torso rotation for power
                    const rotation = attackProgress < 0.5 ? attackProgress * 0.8 : 0.4 - ((attackProgress - 0.5) * 0.8);
                    parts.torso.rotation.y = rotation;
                }
                if (parts.swordBlade) {
                    parts.swordBlade.position.y = 2.1; // Keep in hand
                }
            } else if (classType === 'hunter') {
                // Bow draw and release
                if (parts.leftArm && parts.rightArm && parts.bowArc) {
                    if (attackProgress < 0.6) {
                        // Drawing bow
                        const drawProgress = attackProgress / 0.6;
                        parts.leftArm.rotation.x = -Math.PI / 2; // Hold bow forward
                        parts.leftArm.rotation.z = -0.3;
                        parts.rightArm.rotation.x = -Math.PI / 2; // Pull string back
                        parts.rightArm.rotation.z = 0.3 + (drawProgress * 0.6); // Pull back motion
                        
                        // Bow tilts forward
                        parts.bowArc.rotation.x = Math.PI / 2 - (0.2 * drawProgress);
                    } else {
                        // Release and recoil
                        const releaseProgress = (attackProgress - 0.6) / 0.4;
                        parts.leftArm.rotation.x = -Math.PI / 2 + (0.3 * releaseProgress);
                        parts.rightArm.rotation.x = -Math.PI / 2 + (0.4 * releaseProgress);
                        parts.bowArc.rotation.x = Math.PI / 2;
                    }
                }
                if (parts.torso) {
                    // Slight lean back when drawing
                    parts.torso.rotation.x = attackProgress < 0.6 ? -0.15 * (attackProgress / 0.6) : -0.15 + (0.15 * ((attackProgress - 0.6) / 0.4));
                }
            }
        }

        function applyIdleAnimation(parts, classType, time, breathe, speedRatio) {
            // Idle breathing - subtle torso movement
            if (parts.torso) {
                parts.torso.scale.y = 1 + Math.sin(breathe) * 0.02;
            }
            
            // Subtle weight shift in idle
            if (parts.leftLeg && parts.rightLeg && speedRatio < 0.05) {
                const shiftPhase = time * 0.3;
                parts.leftLeg.rotation.x = Math.sin(shiftPhase) * 0.03;
                parts.rightLeg.rotation.x = -Math.sin(shiftPhase) * 0.03;
            }
        }

        function applyWalkRunAnimation(parts, classType, userData, speedRatio, blendFactor) {
            const phase = userData.walkCyclePhase;
            const intensity = speedRatio; // More intense animation when running
            
            // LEG ANIMATION - Realistic foot stepping with lift
            if (parts.leftLeg && parts.rightLeg) {
                // Calculate swing phase for each leg
                const leftPhase = Math.sin(phase);
                const rightPhase = Math.sin(phase + Math.PI);
                
                // Forward/back swing
                const leftLegSwing = leftPhase * 0.6 * intensity;
                const rightLegSwing = rightPhase * 0.6 * intensity;
                
                parts.leftLeg.rotation.x = leftLegSwing;
                parts.rightLeg.rotation.x = rightLegSwing;
                
                // Foot lift - when leg swings forward, lift it up
                const leftLift = Math.max(0, leftPhase) * 0.15 * intensity; // Only lift when swinging forward
                const rightLift = Math.max(0, rightPhase) * 0.15 * intensity;
                
                parts.leftLeg.position.y = 0.45 + leftLift;
                parts.rightLeg.position.y = 0.45 + rightLift;
                
                // Subtle side-to-side sway
                parts.leftLeg.rotation.z = -Math.abs(leftLegSwing) * 0.08;
                parts.rightLeg.rotation.z = Math.abs(rightLegSwing) * 0.08;
            }
            
            // ARM SWING - Counter to legs for balance
            if (parts.leftArm && parts.rightArm) {
                const armSwingIntensity = classType === 'warrior' ? 0.3 : 0.2;
                
                parts.leftArm.rotation.x = Math.sin(phase + Math.PI) * armSwingIntensity * intensity;
                parts.rightArm.rotation.x = Math.sin(phase) * armSwingIntensity * intensity;
            }
            
            // TORSO BOB - Vertical movement from walk cycle
            if (parts.torso) {
                const bobAmount = Math.abs(Math.sin(phase * 2)) * 0.08 * intensity;
                parts.torso.position.y = 1.35 + bobAmount;
                
                // Forward lean when running
                parts.torso.rotation.x = -speedRatio * 0.15;
                
                // Slight torso rotation opposite to leg movement
                parts.torso.rotation.y = Math.sin(phase) * 0.08 * intensity;
            }
            
            // HEAD STABILIZATION - Head tries to stay level (inverse of body bob)
            if (parts.head || parts.helmet) {
                const headPart = parts.head || parts.helmet;
                headPart.rotation.x = speedRatio * 0.1; // Counter torso lean
            }
            
            // SHOULDER MOVEMENT
            if (parts.leftShoulder && parts.rightShoulder) {
                const shoulderSwing = Math.sin(phase) * 0.05 * intensity;
                parts.leftShoulder.rotation.z = -shoulderSwing;
                parts.rightShoulder.rotation.z = shoulderSwing;
            }
        }

        function applyClassIdleOverlays(parts, classType, time) {
            // These animations play on top of locomotion
            if (classType === 'warrior') {
                    // Battle ready stance - slight weapon sway
                    if (parts.swordBlade) {
                        parts.swordBlade.rotation.z = Math.sin(time * 0.5) * 0.05;
                    }
                    if (parts.rightArm) {
                        parts.rightArm.rotation.z = Math.sin(time * 0.5) * 0.03;
                    }
                    // Head looking around
                    if (parts.helmet) {
                        parts.helmet.rotation.y = Math.sin(time * 0.3) * 0.1;
                    }
                    // Shoulder movement with breathing
            }
            else if (classType === 'hunter') {
                // Alert stance - bow ready
                if (parts.bowArc) {
                    parts.bowArc.rotation.y += Math.sin(time * 0.4) * 0.04;
                }
            }
            else if (classType === 'priest') {
                if (parts.orb) {
                    parts.orb.position.y = 2.4 + Math.sin(time * 2) * 0.05;
                    parts.orb.scale.setScalar(1 + Math.sin(time * 2.5) * 0.08);
                }
                if (parts.lightAura) {
                    const auraPulse = 1 + Math.sin(time * 3) * 0.15;
                    parts.lightAura.scale.setScalar(auraPulse);
                    parts.lightAura.material.opacity = 0.15 + Math.sin(time * 2) * 0.05;
                }
                if (parts.circlet) {
                    parts.circlet.material.emissiveIntensity = 0.4 + Math.sin(time * 2) * 0.2;
                }
            }
            else if (classType === 'mage') {
                if (parts.orb) {
                    parts.orb.position.y = 2.5 + Math.sin(time * 2.5) * 0.08;
                    parts.orb.scale.setScalar(1 + Math.sin(time * 3) * 0.12);
                    if (parts.orb.material.emissiveIntensity !== undefined) {
                        parts.orb.material.emissiveIntensity = 1.0 + Math.sin(time * 4) * 0.3;
                    }
                }
                if (parts.energyRing1 && parts.energyRing2) {
                    parts.energyRing1.rotation.z = time * 0.8;
                    parts.energyRing2.rotation.x = time * -0.6;
                }
                if (parts.circlet) {
                    parts.circlet.material.emissiveIntensity = 0.7 + Math.sin(time * 2.5) * 0.3;
                }
            }
            else if (classType === 'druid') {
                if (parts.crystal) {
                    parts.crystal.rotation.y = time * 0.5;
                    parts.crystal.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
                    if (parts.crystal.material.emissiveIntensity !== undefined) {
                        parts.crystal.material.emissiveIntensity = 0.7 + Math.sin(time * 3) * 0.2;
                    }
                }
            }
        }

        // ============================================
        // PET ANIMATIONS (Independent from owner)
        // ============================================
        function updatePetAnimations(time) {
            const allPets = [...gameState.team, ...gameState.enemies].filter(entity => entity.userData.isPet);
            
            allPets.forEach(pet => {
                if (!pet.visible || pet.userData.health <= 0) return;
                
                const petData = pet.userData;
                const parts = petData.animParts;
                if (!parts) return;
                
                const petPhase = petData.walkCyclePhase || 0;
                
                // Reset positions/rotations
                if (parts.petLegs) {
                    parts.petLegs.forEach(leg => {
                        leg.rotation.set(0, 0, 0);
                    });
                }
                if (parts.petBody) {
                    parts.petBody.position.y = 0.3;
                    parts.petBody.rotation.set(0, 0, 0);
                    parts.petBody.scale.set(1, 1, 1);
                }
                if (parts.petHead) {
                    parts.petHead.position.z = 0.4;
                }
                
                // Apply animations based on state
                if (petData.animState === 'running' || petData.animState === 'walking') {
                    // Quadruped gait - front legs opposite to back legs
                    if (parts.petLegs && parts.petLegs.length === 4) {
                        const frontLeft = Math.sin(petPhase) * 0.4;
                        const frontRight = Math.sin(petPhase + Math.PI) * 0.4;
                        const backLeft = Math.sin(petPhase + Math.PI) * 0.4;
                        const backRight = Math.sin(petPhase) * 0.4;
                        
                        parts.petLegs[0].rotation.x = frontLeft; // Front left
                        parts.petLegs[1].rotation.x = frontRight; // Front right
                        parts.petLegs[2].rotation.x = backLeft; // Back left
                        parts.petLegs[3].rotation.x = backRight; // Back right
                    }
                    
                    // Body bob during movement
                    if (parts.petBody) {
                        parts.petBody.position.y = 0.3 + Math.abs(Math.sin(petPhase * 2)) * 0.06;
                    }
                } else if (petData.animState === 'attacking') {
                    // Lunge animation - head snap forward
                    if (parts.petHead) {
                        parts.petHead.position.z = 0.4 + Math.sin(time * 10) * 0.15;
                    }
                    if (parts.petBody) {
                        parts.petBody.rotation.x = Math.sin(time * 10) * 0.12;
                    }
                } else {
                    // Idle - breathing
                    if (parts.petBody) {
                        parts.petBody.scale.y = 1 + Math.sin(time * 0.002) * 0.03;
                    }
                }
                
                // Tail wag (always active)
                if (parts.tail) {
                    parts.tail.rotation.y = Math.sin(time * 0.004) * 0.4;
                    parts.tail.rotation.x = Math.PI / 4 + Math.sin(time * 0.003) * 0.15;
                }
            });
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let lastTime = performance.now();
        let lastIdleUpdate = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update Dynamic Spectator Camera
            if (spectatorCamera && spectatorCamera.enabled) {
                spectatorCamera.update(deltaTime);
            }

            // Update controls (for damping and internal state sync)
            controls.update();

            // Update combat
            updateCombat(deltaTime);

            // Update particles
            updateParticles(deltaTime);

            // Update character animations
            updateCharacterAnimations(deltaTime);
            
            // Update pet animations (independent)
            updatePetAnimations(currentTime);

            // Update GLTF animation mixers
            const allParticipants = [...gameState.team, ...gameState.enemies];
            for (let i = 0; i < allParticipants.length; i++) {
                const char = allParticipants[i];
                // Performance: Only update mixers for characters that are visible and in-scene
                if (char.visible && char.userData.mixer) {
                    char.userData.mixer.update(deltaTime);
                }
            }

            // Update nameplates
            updateNameplates();

            // Animate ring glow
            if (window.arenaRing) {
                window.arenaRing.material.emissiveIntensity = 0.3 + Math.sin(currentTime * 0.002) * 0.2;
            }

            // Update UI
            if (gameState.inMatch) {
                document.getElementById('match-timer').textContent = gameState.matchTime.toFixed(1);
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // IDLE/BACKGROUND LOOP
        // ============================================
        // Runs even when tab is not active using setInterval
        // Handles combat logic for true idle gameplay
        setInterval(() => {
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastIdleUpdate) / 1000;
            lastIdleUpdate = currentTime;

            // Run combat logic even when tab is inactive
            if (gameState.inMatch) {
                updateCombat(deltaTime);
            }

            // Update UI less frequently to save performance
            if (Math.random() < 0.1) { // 10% of the time
                updateUI();
            }
        }, 100); // Run 10 times per second

        // ============================================
        // SAVE SYSTEM
        // ============================================
        const SAVE_KEY = 'arenaIdleGame_save_v1';
        const AUTO_SAVE_INTERVAL = 30000; // Auto-save every 30 seconds
        let isResetting = false;

        function saveGame() {
            if (isResetting) return;
            try {
                // Build a clean gear snapshot ‚Äî only save non-null string values
                const gearSnapshot = {
                    weapon: null, head: null, shoulders: null, chest: null,
                    hands: null, legs: null, trinket1: null, trinket2: null, enchant: null
                };
                if (gameState.equippedGear) {
                    ['weapon','head','shoulders','chest','hands','legs','trinket1','trinket2','enchant'].forEach(slot => {
                        const val = gameState.equippedGear[slot];
                        gearSnapshot[slot] = (val && typeof val === 'string' && val !== 'null' && val !== 'undefined') ? val : null;
                    });
                }
                
                const saveData = {
                    version: 1,
                    timestamp: Date.now(),
                    gameState: {
                        honor: gameState.honor,
                        conquestPoints: gameState.conquestPoints,
                        arenaRating: gameState.arenaRating,
                        wins: gameState.wins,
                        losses: gameState.losses,
                        matchNumber: gameState.matchNumber,
                        conquestCap: gameState.conquestCap,
                        winStreak: gameState.winStreak,
                        longestWinStreak: gameState.longestWinStreak,
                        totalKills: gameState.totalKills,
                        activeRoster: [...gameState.activeRoster],
                        teamDoctrine: gameState.teamDoctrine || 'balanced',
                        unlockedClasses: [...(gameState.unlockedClasses || [])],
                        upgrades: { ...gameState.upgrades },
                        equippedGear: gearSnapshot,
                        conquestUpgrades: { ...gameState.conquestUpgrades },
                        // Career data that MUST persist across prestiges
                        prestigeLevel: gameState.prestigeLevel || 0,
                        talentPoints: gameState.talentPoints || 0,
                        talents: { ...(gameState.talents || {}) },
                        seasonHistory: gameState.seasonHistory ? [...gameState.seasonHistory] : [],
                        lifetimeWins: gameState.lifetimeWins || 0,
                        lifetimeLosses: gameState.lifetimeLosses || 0,
                        peakRating: gameState.peakRating || 0,
                        arenaTitle: gameState.arenaTitle || 'Combatant'
                    }
                };
                
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                console.log('üíæ Game saved successfully');
                
                // Update last save time display if settings is open
                const settingsModal = document.getElementById('settings-modal');
                if (settingsModal && settingsModal.style.display === 'flex') {
                    document.getElementById('last-save-time').textContent = 'Last saved: Just now';
                }
            } catch (error) {
                console.error('‚ùå Failed to save game:', error);
            }
        }

        function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) {
                    console.log('No save data found, starting fresh');
                    return false;
                }

                const saveData = JSON.parse(savedData);
                
                // Check version compatibility
                if (saveData.version !== 1) {
                    console.warn('Save version mismatch, starting fresh');
                    return false;
                }

                const saved = saveData.gameState;
                
                // Restore game state
                gameState.honor = saved.honor || 0;
                gameState.conquestPoints = saved.conquestPoints || 0;
                gameState.arenaRating = saved.arenaRating || 0;
                gameState.wins = saved.wins || 0;
                gameState.losses = saved.losses || 0;
                gameState.matchNumber = saved.matchNumber || 0;
                gameState.conquestCap = saved.conquestCap || 1000;
                gameState.winStreak = saved.winStreak || 0;
                gameState.longestWinStreak = saved.longestWinStreak || 0;
                gameState.totalKills = saved.totalKills || 0;
                
                // Restore Roster
                if (saved.activeRoster) {
                    gameState.activeRoster = [...saved.activeRoster];
                }
                if (saved.teamDoctrine) {
                    gameState.teamDoctrine = saved.teamDoctrine;
                    const presetEl = document.getElementById('strategy-preset');
                    if (presetEl) presetEl.value = gameState.teamDoctrine;
                }
                if (saved.unlockedClasses) {
                    gameState.unlockedClasses = [...saved.unlockedClasses];
                }
                
                // Restore upgrades
                if (saved.upgrades) {
                    Object.assign(gameState.upgrades, saved.upgrades);
                }
                
                // Restore equipped gear - FULL REPLACEMENT with database validation
                // First, start with a completely clean object
                gameState.equippedGear = {
                    weapon: null, head: null, shoulders: null, chest: null,
                    hands: null, legs: null, trinket1: null, trinket2: null, enchant: null
                };
                if (saved.equippedGear && typeof saved.equippedGear === 'object') {
                    // Build set of all valid IDs from current game database
                    const dbIds = new Set();
                    PVP_GEAR.weapons.forEach(i => dbIds.add(i.id));
                    PVP_GEAR.armor.forEach(i => dbIds.add(i.id));
                    PVP_GEAR.trinkets.forEach(i => dbIds.add(i.id));
                    Object.keys(ENCHANTS).forEach(id => dbIds.add(id));
                    
                    ['weapon','head','shoulders','chest','hands','legs','trinket1','trinket2','enchant'].forEach(slot => {
                        const id = saved.equippedGear[slot];
                        // Triple validation: must be truthy, must be string, must exist in DB
                        if (id && typeof id === 'string' && id !== 'null' && id !== 'undefined' && dbIds.has(id)) {
                            gameState.equippedGear[slot] = id;
                        }
                        // If any check fails, slot stays null (from the clean object above)
                    });
                }
                
                // Restore conquest upgrades
                if (saved.conquestUpgrades) {
                    Object.assign(gameState.conquestUpgrades, saved.conquestUpgrades);
                }
                
                // Restore career/prestige data (these MUST persist across seasons)
                gameState.prestigeLevel = saved.prestigeLevel || 0;
                gameState.talentPoints = saved.talentPoints || 0;
                if (saved.talents) gameState.talents = { ...saved.talents };
                if (saved.seasonHistory) gameState.seasonHistory = [...saved.seasonHistory];
                gameState.lifetimeWins = saved.lifetimeWins || 0;
                gameState.lifetimeLosses = saved.lifetimeLosses || 0;
                gameState.peakRating = saved.peakRating || 0;
                if (saved.arenaTitle) gameState.arenaTitle = saved.arenaTitle;
                
                // Debug: Log gear state on load so we can verify
                const gearSlots = ['weapon','head','shoulders','chest','hands','legs','trinket1','trinket2','enchant'];
                const loadedGearCount = gearSlots.filter(s => gameState.equippedGear[s] && gameState.equippedGear[s] !== null).length;
                console.log(`üì¶ Gear loaded: ${loadedGearCount}/9`, JSON.stringify(gameState.equippedGear));

                console.log('‚úÖ Game loaded successfully');
                console.log(`Progress: ${gameState.wins}W-${gameState.losses}L, Rating: ${Math.floor(gameState.arenaRating)}, Honor: ${gameState.honor}`);
                
                return true;
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to load game:', error);
                return false;
            }
        }

        // Global listener for the Reset button to bypass any potential scoping or propagation issues
        window.addEventListener('mousedown', (e) => {
            const resetBtn = document.getElementById('settings-reset-all');
            if (resetBtn && (e.target === resetBtn || resetBtn.contains(e.target))) {
                console.log('üí• Global mousedown detected on reset button');
                e.preventDefault();
                e.stopPropagation();
                handleResetRequest();
            }
        }, true); // Use capture phase for maximum priority

        let resetConfirmationStep = 0;
        function handleResetRequest() {
            resetConfirmationStep++;
            const btn = document.getElementById('settings-reset-all');
            
            if (resetConfirmationStep === 1) {
                if (btn) {
                    btn.style.background = 'linear-gradient(180deg, #ff8800, #cc6600)';
                    btn.textContent = '‚ö†Ô∏è ARE YOU SURE? CLICK AGAIN';
                }
                // Reset the step if they don't click again within 3 seconds
                setTimeout(() => {
                    if (resetConfirmationStep === 1) {
                        resetConfirmationStep = 0;
                        if (btn) {
                            btn.style.background = 'linear-gradient(180deg, #f44336, #c62828)';
                            btn.textContent = 'üóëÔ∏è RESET ALL PROGRESS';
                        }
                    }
                }, 3000);
            } else if (resetConfirmationStep === 2) {
                if (btn) {
                    btn.style.background = 'linear-gradient(180deg, #ff0000, #990000)';
                    btn.textContent = 'üî• FINAL WARNING! CLICK TO WIPE';
                }
            } else {
                resetGame();
            }
        }

        function resetGame() {
            console.log('üîÑ resetGame() triggered');
            
            try {
                // Stop any further saving globally
                isResetting = true;
                
                // Clear storage immediately
                localStorage.clear(); 
                sessionStorage.clear();
                
                // Wipe critical state in memory
                Object.assign(gameState, {
                    honor: 0,
                    arenaRating: 0,
                    wins: 0,
                    losses: 0,
                    prestigeLevel: 0,
                    conquestPoints: 0,
                    talentPoints: 0,
                    talents: {}
                });

                // Clear gear
                if (gameState.equippedGear) {
                    Object.keys(gameState.equippedGear).forEach(k => gameState.equippedGear[k] = null);
                }
                
                console.log('üóëÔ∏è Progress wiped. Force reloading...');
                
                // Hard reload to clear all variables
                window.location.replace(window.location.pathname + window.location.search);
            } catch (error) {
                console.error('Failed to reset game:', error);
                // Fallback: just reload anyway
                window.location.reload();
            }
        }

        // Export save data (for backup)
        function exportSave() {
            try {
                const saveData = localStorage.getItem(SAVE_KEY);
                if (!saveData) {
                    alert('No save data to export');
                    return;
                }

                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `arena-idle-save-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log('üì• Save exported successfully');
            } catch (error) {
                console.error('Failed to export save:', error);
                alert('Failed to export save data');
            }
        }

        // Import save data (from backup)
        function importSave() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const saveData = JSON.parse(event.target.result);
                        localStorage.setItem(SAVE_KEY, event.target.result);
                        console.log('üì§ Save imported successfully');
                        
                        setTimeout(() => {
                            location.reload(); // Reload to apply imported save
                        }, 1000);
                    } catch (error) {
                        console.error('Failed to import save:', error);
                        alert('Invalid save file');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Expose save system functions to window for HTML onclick handlers
        window.saveGame = saveGame;
        window.resetGame = resetGame;
        window.exportSave = exportSave;
        window.importSave = importSave;

        // Auto-save interval
        setInterval(() => {
            saveGame();
        }, AUTO_SAVE_INTERVAL);

        // Save before page unload
        window.addEventListener('beforeunload', () => {
            saveGame();
        });

        // Keyboard shortcuts for save system
        document.addEventListener('keydown', (e) => {
            // Ctrl+S or Cmd+S to manual save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveGame();
            }
        });

        // ============================================
        // EXPOSE TO GLOBAL SCOPE (for console debugging)
        // ============================================
        window.gameDebug = {
            // GLTF Model Functions
            loadGLTFModel,
            replaceCharacterWithGLTF,
            replaceClassWithGLTF,
            testLoadModel,
            MODEL_URLS,
            modelCache,
            
            // Game State
            gameState,
            scene,
            camera,
            renderer,
            
            // Useful for testing
            THREE
        };
        
        console.log('üéÆ Game Debug Tools Available!');
        console.log('Access via: window.gameDebug');
        console.log('');
        console.log('üì¶ GLTF Model Functions:');
        console.log('  gameDebug.testLoadModel("modelKey") - Load and display a test model');
        console.log('  gameDebug.replaceClassWithGLTF("warrior", "modelKey") - Replace all warriors');
        console.log('  gameDebug.MODEL_URLS - View available model URLs');
        console.log('  gameDebug.modelCache - View cached models');
        console.log('');
        console.log('üí° Upload .glb files to assets, add URL to MODEL_URLS, then test!');

        // ============================================
        // INITIALIZE
        // ============================================
        
        async function initGame() {
            // Load saved game first
            loadGame();
            
            // Ensure all classes are unlocked (No rating requirements)
            gameState.unlockedClasses = Object.keys(CLASSES);
            
            // Ensure career stats are initialized if not in save
            if (gameState.lifetimeWins === undefined) gameState.lifetimeWins = 0;
            if (gameState.lifetimeLosses === undefined) gameState.lifetimeLosses = 0;
            if (gameState.peakRating === undefined) gameState.peakRating = gameState.arenaRating;

            // Force gear count to be correct immediately after load
            updateGearCountDisplay();

            // Load Arena Environment
            await createNagrandArena();
            await createArenaGates();

            updateUI();
            renderUpgrades();
            
            // Initialize arena rating display
            const ratingEl = document.getElementById('current-rating');
            if (ratingEl) ratingEl.textContent = Math.floor(gameState.arenaRating);
            
            // Kick off first match
            await startNewMatch();
            
            // Start render loop
            animate();
            
            console.log('‚öîÔ∏è Arena Legends initialized and ready!');
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
